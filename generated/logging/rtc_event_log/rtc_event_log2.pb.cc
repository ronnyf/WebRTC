// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rtc_event_log2.proto

#include "rtc_event_log2.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/io/zero_copy_stream_impl_lite.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace webrtc {
namespace rtclog2 {

inline constexpr RtpHeaderExtensionConfig::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        transmission_time_offset_id_{0},
        absolute_send_time_id_{0},
        transport_sequence_number_id_{0},
        video_rotation_id_{0},
        audio_level_id_{0},
        dependency_descriptor_id_{0} {}

template <typename>
PROTOBUF_CONSTEXPR RtpHeaderExtensionConfig::RtpHeaderExtensionConfig(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RtpHeaderExtensionConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RtpHeaderExtensionConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RtpHeaderExtensionConfigDefaultTypeInternal() {}
  union {
    RtpHeaderExtensionConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RtpHeaderExtensionConfigDefaultTypeInternal _RtpHeaderExtensionConfig_default_instance_;

inline constexpr RouteChange::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_{::int64_t{0}},
        connected_{false},
        overhead_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR RouteChange::RouteChange(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RouteChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RouteChangeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RouteChangeDefaultTypeInternal() {}
  union {
    RouteChange _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RouteChangeDefaultTypeInternal _RouteChange_default_instance_;

inline constexpr RemoteEstimates::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        link_capacity_lower_kbps_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        link_capacity_upper_kbps_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        link_capacity_lower_kbps_{0u},
        link_capacity_upper_kbps_{0u},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR RemoteEstimates::RemoteEstimates(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct RemoteEstimatesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoteEstimatesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoteEstimatesDefaultTypeInternal() {}
  union {
    RemoteEstimates _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoteEstimatesDefaultTypeInternal _RemoteEstimates_default_instance_;

inline constexpr OutgoingRtcpPackets::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        raw_packet_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        raw_packet_blobs_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR OutgoingRtcpPackets::OutgoingRtcpPackets(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct OutgoingRtcpPacketsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OutgoingRtcpPacketsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OutgoingRtcpPacketsDefaultTypeInternal() {}
  union {
    OutgoingRtcpPackets _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OutgoingRtcpPacketsDefaultTypeInternal _OutgoingRtcpPackets_default_instance_;

inline constexpr NetEqSetMinimumDelay::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        remote_ssrc_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        minimum_delay_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        remote_ssrc_{0u},
        minimum_delay_ms_{0},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR NetEqSetMinimumDelay::NetEqSetMinimumDelay(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct NetEqSetMinimumDelayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetEqSetMinimumDelayDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetEqSetMinimumDelayDefaultTypeInternal() {}
  union {
    NetEqSetMinimumDelay _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetEqSetMinimumDelayDefaultTypeInternal _NetEqSetMinimumDelay_default_instance_;

inline constexpr LossBasedBweUpdates::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        bitrate_bps_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        fraction_loss_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        total_packets_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        bitrate_bps_{0u},
        fraction_loss_{0u},
        total_packets_{0u},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR LossBasedBweUpdates::LossBasedBweUpdates(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct LossBasedBweUpdatesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LossBasedBweUpdatesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LossBasedBweUpdatesDefaultTypeInternal() {}
  union {
    LossBasedBweUpdates _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LossBasedBweUpdatesDefaultTypeInternal _LossBasedBweUpdates_default_instance_;

inline constexpr IncomingRtcpPackets::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        raw_packet_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        raw_packet_blobs_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR IncomingRtcpPackets::IncomingRtcpPackets(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct IncomingRtcpPacketsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IncomingRtcpPacketsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IncomingRtcpPacketsDefaultTypeInternal() {}
  union {
    IncomingRtcpPackets _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IncomingRtcpPacketsDefaultTypeInternal _IncomingRtcpPackets_default_instance_;

inline constexpr IceCandidatePairEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_{::int64_t{0}},
        event_type_{static_cast< ::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType >(0)},
        candidate_pair_id_{0u},
        transaction_id_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR IceCandidatePairEvent::IceCandidatePairEvent(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct IceCandidatePairEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IceCandidatePairEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IceCandidatePairEventDefaultTypeInternal() {}
  union {
    IceCandidatePairEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IceCandidatePairEventDefaultTypeInternal _IceCandidatePairEvent_default_instance_;

inline constexpr IceCandidatePairConfig::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_{::int64_t{0}},
        config_type_{static_cast< ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType >(0)},
        candidate_pair_id_{0u},
        local_candidate_type_{static_cast< ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType >(0)},
        local_relay_protocol_{static_cast< ::webrtc::rtclog2::IceCandidatePairConfig_Protocol >(0)},
        local_network_type_{static_cast< ::webrtc::rtclog2::IceCandidatePairConfig_NetworkType >(0)},
        local_address_family_{static_cast< ::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily >(0)},
        remote_candidate_type_{static_cast< ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType >(0)},
        remote_address_family_{static_cast< ::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily >(0)},
        candidate_pair_protocol_{static_cast< ::webrtc::rtclog2::IceCandidatePairConfig_Protocol >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR IceCandidatePairConfig::IceCandidatePairConfig(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct IceCandidatePairConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IceCandidatePairConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IceCandidatePairConfigDefaultTypeInternal() {}
  union {
    IceCandidatePairConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IceCandidatePairConfigDefaultTypeInternal _IceCandidatePairConfig_default_instance_;

inline constexpr GenericPacketSent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        packet_number_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        overhead_length_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        payload_length_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        padding_length_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        packet_number_{::int64_t{0}},
        overhead_length_{0},
        payload_length_{0},
        padding_length_{0},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR GenericPacketSent::GenericPacketSent(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct GenericPacketSentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenericPacketSentDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenericPacketSentDefaultTypeInternal() {}
  union {
    GenericPacketSent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenericPacketSentDefaultTypeInternal _GenericPacketSent_default_instance_;

inline constexpr GenericPacketReceived::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        packet_number_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        packet_length_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        packet_number_{::int64_t{0}},
        packet_length_{0},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR GenericPacketReceived::GenericPacketReceived(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct GenericPacketReceivedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenericPacketReceivedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenericPacketReceivedDefaultTypeInternal() {}
  union {
    GenericPacketReceived _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenericPacketReceivedDefaultTypeInternal _GenericPacketReceived_default_instance_;

inline constexpr GenericAckReceived::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        packet_number_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        acked_packet_number_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        receive_acked_packet_time_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        packet_number_{::int64_t{0}},
        acked_packet_number_{::int64_t{0}},
        receive_acked_packet_time_ms_{::int64_t{0}},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR GenericAckReceived::GenericAckReceived(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct GenericAckReceivedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenericAckReceivedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenericAckReceivedDefaultTypeInternal() {}
  union {
    GenericAckReceived _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenericAckReceivedDefaultTypeInternal _GenericAckReceived_default_instance_;

inline constexpr FrameDecodedEvents::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ssrc_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        render_time_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        width_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        height_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        codec_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        qp_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        render_time_ms_{::int64_t{0}},
        ssrc_{0u},
        width_{0},
        height_{0},
        codec_{static_cast< ::webrtc::rtclog2::FrameDecodedEvents_Codec >(0)},
        qp_{0u},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR FrameDecodedEvents::FrameDecodedEvents(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct FrameDecodedEventsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameDecodedEventsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameDecodedEventsDefaultTypeInternal() {}
  union {
    FrameDecodedEvents _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameDecodedEventsDefaultTypeInternal _FrameDecodedEvents_default_instance_;

inline constexpr Event::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Event::Event(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct EventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventDefaultTypeInternal() {}
  union {
    Event _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventDefaultTypeInternal _Event_default_instance_;

inline constexpr EndLogEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_{::int64_t{0}} {}

template <typename>
PROTOBUF_CONSTEXPR EndLogEvent::EndLogEvent(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct EndLogEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EndLogEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EndLogEventDefaultTypeInternal() {}
  union {
    EndLogEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EndLogEventDefaultTypeInternal _EndLogEvent_default_instance_;

inline constexpr DtlsWritableState::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_{::int64_t{0}},
        writable_{false} {}

template <typename>
PROTOBUF_CONSTEXPR DtlsWritableState::DtlsWritableState(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct DtlsWritableStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DtlsWritableStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DtlsWritableStateDefaultTypeInternal() {}
  union {
    DtlsWritableState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DtlsWritableStateDefaultTypeInternal _DtlsWritableState_default_instance_;

inline constexpr DtlsTransportStateEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_{::int64_t{0}},
        dtls_transport_state_{static_cast< ::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR DtlsTransportStateEvent::DtlsTransportStateEvent(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct DtlsTransportStateEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DtlsTransportStateEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DtlsTransportStateEventDefaultTypeInternal() {}
  union {
    DtlsTransportStateEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DtlsTransportStateEventDefaultTypeInternal _DtlsTransportStateEvent_default_instance_;

inline constexpr DependencyDescriptorsWireInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        start_end_bit_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        template_id_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        frame_id_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        extended_infos_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        start_end_bit_{0u},
        template_id_{0u},
        frame_id_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR DependencyDescriptorsWireInfo::DependencyDescriptorsWireInfo(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct DependencyDescriptorsWireInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DependencyDescriptorsWireInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DependencyDescriptorsWireInfoDefaultTypeInternal() {}
  union {
    DependencyDescriptorsWireInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DependencyDescriptorsWireInfoDefaultTypeInternal _DependencyDescriptorsWireInfo_default_instance_;

inline constexpr DelayBasedBweUpdates::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        bitrate_bps_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        detector_state_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        bitrate_bps_{0u},
        detector_state_{static_cast< ::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState >(0)},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR DelayBasedBweUpdates::DelayBasedBweUpdates(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct DelayBasedBweUpdatesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DelayBasedBweUpdatesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DelayBasedBweUpdatesDefaultTypeInternal() {}
  union {
    DelayBasedBweUpdates _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DelayBasedBweUpdatesDefaultTypeInternal _DelayBasedBweUpdates_default_instance_;

inline constexpr BweProbeResultSuccess::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_{::int64_t{0}},
        id_{0u},
        bitrate_bps_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR BweProbeResultSuccess::BweProbeResultSuccess(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct BweProbeResultSuccessDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BweProbeResultSuccessDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BweProbeResultSuccessDefaultTypeInternal() {}
  union {
    BweProbeResultSuccess _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BweProbeResultSuccessDefaultTypeInternal _BweProbeResultSuccess_default_instance_;

inline constexpr BweProbeResultFailure::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_{::int64_t{0}},
        id_{0u},
        failure_{static_cast< ::webrtc::rtclog2::BweProbeResultFailure_FailureReason >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR BweProbeResultFailure::BweProbeResultFailure(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct BweProbeResultFailureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BweProbeResultFailureDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BweProbeResultFailureDefaultTypeInternal() {}
  union {
    BweProbeResultFailure _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BweProbeResultFailureDefaultTypeInternal _BweProbeResultFailure_default_instance_;

inline constexpr BweProbeCluster::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_{::int64_t{0}},
        id_{0u},
        bitrate_bps_{0u},
        min_packets_{0u},
        min_bytes_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR BweProbeCluster::BweProbeCluster(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct BweProbeClusterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BweProbeClusterDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BweProbeClusterDefaultTypeInternal() {}
  union {
    BweProbeCluster _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BweProbeClusterDefaultTypeInternal _BweProbeCluster_default_instance_;

inline constexpr BeginLogEvent::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_{::int64_t{0}},
        utc_time_ms_{::int64_t{0}},
        version_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR BeginLogEvent::BeginLogEvent(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct BeginLogEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BeginLogEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BeginLogEventDefaultTypeInternal() {}
  union {
    BeginLogEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BeginLogEventDefaultTypeInternal _BeginLogEvent_default_instance_;

inline constexpr AudioPlayoutEvents::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        local_ssrc_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        local_ssrc_{0u},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR AudioPlayoutEvents::AudioPlayoutEvents(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct AudioPlayoutEventsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioPlayoutEventsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioPlayoutEventsDefaultTypeInternal() {}
  union {
    AudioPlayoutEvents _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioPlayoutEventsDefaultTypeInternal _AudioPlayoutEvents_default_instance_;

inline constexpr AudioNetworkAdaptations::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        bitrate_bps_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        frame_length_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        uplink_packet_loss_fraction_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        enable_fec_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        enable_dtx_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        num_channels_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_ms_{::int64_t{0}},
        bitrate_bps_{0},
        frame_length_ms_{0},
        uplink_packet_loss_fraction_{0u},
        enable_fec_{false},
        enable_dtx_{false},
        num_channels_{0u},
        number_of_deltas_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR AudioNetworkAdaptations::AudioNetworkAdaptations(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct AudioNetworkAdaptationsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioNetworkAdaptationsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioNetworkAdaptationsDefaultTypeInternal() {}
  union {
    AudioNetworkAdaptations _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioNetworkAdaptationsDefaultTypeInternal _AudioNetworkAdaptations_default_instance_;

inline constexpr AlrState::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_{::int64_t{0}},
        in_alr_{false} {}

template <typename>
PROTOBUF_CONSTEXPR AlrState::AlrState(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct AlrStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AlrStateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AlrStateDefaultTypeInternal() {}
  union {
    AlrState _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AlrStateDefaultTypeInternal _AlrState_default_instance_;

inline constexpr VideoSendStreamConfig::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        header_extensions_{nullptr},
        timestamp_ms_{::int64_t{0}},
        ssrc_{0u},
        rtx_ssrc_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR VideoSendStreamConfig::VideoSendStreamConfig(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct VideoSendStreamConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoSendStreamConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoSendStreamConfigDefaultTypeInternal() {}
  union {
    VideoSendStreamConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoSendStreamConfigDefaultTypeInternal _VideoSendStreamConfig_default_instance_;

inline constexpr VideoRecvStreamConfig::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        header_extensions_{nullptr},
        timestamp_ms_{::int64_t{0}},
        remote_ssrc_{0u},
        local_ssrc_{0u},
        rtx_ssrc_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR VideoRecvStreamConfig::VideoRecvStreamConfig(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct VideoRecvStreamConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoRecvStreamConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoRecvStreamConfigDefaultTypeInternal() {}
  union {
    VideoRecvStreamConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoRecvStreamConfigDefaultTypeInternal _VideoRecvStreamConfig_default_instance_;

inline constexpr OutgoingRtpPackets::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        marker_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        payload_type_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        sequence_number_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        rtp_timestamp_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ssrc_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        payload_size_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        header_size_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        padding_size_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        transport_sequence_number_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        transmission_time_offset_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        absolute_send_time_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        video_rotation_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        audio_level_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        voice_activity_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        dependency_descriptor_{nullptr},
        timestamp_ms_{::int64_t{0}},
        payload_type_{0u},
        sequence_number_{0u},
        rtp_timestamp_{0u},
        ssrc_{0u},
        payload_size_{0u},
        header_size_{0u},
        padding_size_{0u},
        number_of_deltas_{0u},
        marker_{false},
        voice_activity_{false},
        transport_sequence_number_{0u},
        transmission_time_offset_{0},
        absolute_send_time_{0u},
        video_rotation_{0u},
        audio_level_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR OutgoingRtpPackets::OutgoingRtpPackets(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct OutgoingRtpPacketsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OutgoingRtpPacketsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OutgoingRtpPacketsDefaultTypeInternal() {}
  union {
    OutgoingRtpPackets _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OutgoingRtpPacketsDefaultTypeInternal _OutgoingRtpPackets_default_instance_;

inline constexpr IncomingRtpPackets::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        timestamp_ms_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        marker_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        payload_type_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        sequence_number_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        rtp_timestamp_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        ssrc_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        payload_size_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        header_size_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        padding_size_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        transport_sequence_number_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        transmission_time_offset_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        absolute_send_time_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        video_rotation_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        audio_level_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        voice_activity_deltas_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        dependency_descriptor_{nullptr},
        timestamp_ms_{::int64_t{0}},
        payload_type_{0u},
        sequence_number_{0u},
        rtp_timestamp_{0u},
        ssrc_{0u},
        payload_size_{0u},
        header_size_{0u},
        padding_size_{0u},
        number_of_deltas_{0u},
        marker_{false},
        voice_activity_{false},
        transport_sequence_number_{0u},
        transmission_time_offset_{0},
        absolute_send_time_{0u},
        video_rotation_{0u},
        audio_level_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR IncomingRtpPackets::IncomingRtpPackets(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct IncomingRtpPacketsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IncomingRtpPacketsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IncomingRtpPacketsDefaultTypeInternal() {}
  union {
    IncomingRtpPackets _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IncomingRtpPacketsDefaultTypeInternal _IncomingRtpPackets_default_instance_;

inline constexpr AudioSendStreamConfig::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        header_extensions_{nullptr},
        timestamp_ms_{::int64_t{0}},
        ssrc_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR AudioSendStreamConfig::AudioSendStreamConfig(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct AudioSendStreamConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioSendStreamConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioSendStreamConfigDefaultTypeInternal() {}
  union {
    AudioSendStreamConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioSendStreamConfigDefaultTypeInternal _AudioSendStreamConfig_default_instance_;

inline constexpr AudioRecvStreamConfig::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        header_extensions_{nullptr},
        timestamp_ms_{::int64_t{0}},
        remote_ssrc_{0u},
        local_ssrc_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR AudioRecvStreamConfig::AudioRecvStreamConfig(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct AudioRecvStreamConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioRecvStreamConfigDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioRecvStreamConfigDefaultTypeInternal() {}
  union {
    AudioRecvStreamConfig _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioRecvStreamConfigDefaultTypeInternal _AudioRecvStreamConfig_default_instance_;

inline constexpr EventStream::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : stream_{},
        incoming_rtp_packets_{},
        outgoing_rtp_packets_{},
        incoming_rtcp_packets_{},
        outgoing_rtcp_packets_{},
        audio_playout_events_{},
        frame_decoded_events_{},
        begin_log_events_{},
        end_log_events_{},
        loss_based_bwe_updates_{},
        delay_based_bwe_updates_{},
        audio_network_adaptations_{},
        probe_clusters_{},
        probe_success_{},
        probe_failure_{},
        alr_states_{},
        ice_candidate_configs_{},
        ice_candidate_events_{},
        dtls_transport_state_events_{},
        dtls_writable_states_{},
        generic_packets_sent_{},
        generic_packets_received_{},
        generic_acks_received_{},
        route_changes_{},
        remote_estimates_{},
        neteq_set_minimum_delay_{},
        audio_recv_stream_configs_{},
        audio_send_stream_configs_{},
        video_recv_stream_configs_{},
        video_send_stream_configs_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR EventStream::EventStream(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct EventStreamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventStreamDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventStreamDefaultTypeInternal() {}
  union {
    EventStream _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventStreamDefaultTypeInternal _EventStream_default_instance_;
}  // namespace rtclog2
}  // namespace webrtc
namespace webrtc {
namespace rtclog2 {
PROTOBUF_CONSTINIT const uint32_t FrameDecodedEvents_Codec_internal_data_[] = {
    393216u, 0u, };
bool FrameDecodedEvents_Codec_IsValid(int value) {
  return 0 <= value && value <= 5;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    FrameDecodedEvents_Codec_strings[6] = {};

static const char FrameDecodedEvents_Codec_names[] = {
    "CODEC_AV1"
    "CODEC_GENERIC"
    "CODEC_H264"
    "CODEC_UNKNOWN"
    "CODEC_VP8"
    "CODEC_VP9"
};

static const ::google::protobuf::internal::EnumEntry FrameDecodedEvents_Codec_entries[] =
    {
        {{&FrameDecodedEvents_Codec_names[0], 9}, 4},
        {{&FrameDecodedEvents_Codec_names[9], 13}, 1},
        {{&FrameDecodedEvents_Codec_names[22], 10}, 5},
        {{&FrameDecodedEvents_Codec_names[32], 13}, 0},
        {{&FrameDecodedEvents_Codec_names[45], 9}, 2},
        {{&FrameDecodedEvents_Codec_names[54], 9}, 3},
};

static const int FrameDecodedEvents_Codec_entries_by_number[] = {
    3,  // 0 -> CODEC_UNKNOWN
    1,  // 1 -> CODEC_GENERIC
    4,  // 2 -> CODEC_VP8
    5,  // 3 -> CODEC_VP9
    0,  // 4 -> CODEC_AV1
    2,  // 5 -> CODEC_H264
};

const std::string& FrameDecodedEvents_Codec_Name(FrameDecodedEvents_Codec value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          FrameDecodedEvents_Codec_entries, FrameDecodedEvents_Codec_entries_by_number,
          6, FrameDecodedEvents_Codec_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      FrameDecodedEvents_Codec_entries, FrameDecodedEvents_Codec_entries_by_number, 6,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : FrameDecodedEvents_Codec_strings[idx].get();
}

bool FrameDecodedEvents_Codec_Parse(absl::string_view name, FrameDecodedEvents_Codec* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      FrameDecodedEvents_Codec_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<FrameDecodedEvents_Codec>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_UNKNOWN;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_GENERIC;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_VP8;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_VP9;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_AV1;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::CODEC_H264;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::Codec_MIN;
constexpr FrameDecodedEvents_Codec FrameDecodedEvents::Codec_MAX;
constexpr int FrameDecodedEvents::Codec_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t DelayBasedBweUpdates_DetectorState_internal_data_[] = {
    262144u, 0u, };
bool DelayBasedBweUpdates_DetectorState_IsValid(int value) {
  return 0 <= value && value <= 3;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    DelayBasedBweUpdates_DetectorState_strings[4] = {};

static const char DelayBasedBweUpdates_DetectorState_names[] = {
    "BWE_NORMAL"
    "BWE_OVERUSING"
    "BWE_UNDERUSING"
    "BWE_UNKNOWN_STATE"
};

static const ::google::protobuf::internal::EnumEntry DelayBasedBweUpdates_DetectorState_entries[] =
    {
        {{&DelayBasedBweUpdates_DetectorState_names[0], 10}, 1},
        {{&DelayBasedBweUpdates_DetectorState_names[10], 13}, 3},
        {{&DelayBasedBweUpdates_DetectorState_names[23], 14}, 2},
        {{&DelayBasedBweUpdates_DetectorState_names[37], 17}, 0},
};

static const int DelayBasedBweUpdates_DetectorState_entries_by_number[] = {
    3,  // 0 -> BWE_UNKNOWN_STATE
    0,  // 1 -> BWE_NORMAL
    2,  // 2 -> BWE_UNDERUSING
    1,  // 3 -> BWE_OVERUSING
};

const std::string& DelayBasedBweUpdates_DetectorState_Name(DelayBasedBweUpdates_DetectorState value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          DelayBasedBweUpdates_DetectorState_entries, DelayBasedBweUpdates_DetectorState_entries_by_number,
          4, DelayBasedBweUpdates_DetectorState_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      DelayBasedBweUpdates_DetectorState_entries, DelayBasedBweUpdates_DetectorState_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : DelayBasedBweUpdates_DetectorState_strings[idx].get();
}

bool DelayBasedBweUpdates_DetectorState_Parse(absl::string_view name, DelayBasedBweUpdates_DetectorState* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      DelayBasedBweUpdates_DetectorState_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DelayBasedBweUpdates_DetectorState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::BWE_UNKNOWN_STATE;
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::BWE_NORMAL;
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::BWE_UNDERUSING;
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::BWE_OVERUSING;
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::DetectorState_MIN;
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::DetectorState_MAX;
constexpr int DelayBasedBweUpdates::DetectorState_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t BweProbeResultFailure_FailureReason_internal_data_[] = {
    262144u, 0u, };
bool BweProbeResultFailure_FailureReason_IsValid(int value) {
  return 0 <= value && value <= 3;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    BweProbeResultFailure_FailureReason_strings[4] = {};

static const char BweProbeResultFailure_FailureReason_names[] = {
    "INVALID_SEND_RECEIVE_INTERVAL"
    "INVALID_SEND_RECEIVE_RATIO"
    "TIMEOUT"
    "UNKNOWN"
};

static const ::google::protobuf::internal::EnumEntry BweProbeResultFailure_FailureReason_entries[] =
    {
        {{&BweProbeResultFailure_FailureReason_names[0], 29}, 1},
        {{&BweProbeResultFailure_FailureReason_names[29], 26}, 2},
        {{&BweProbeResultFailure_FailureReason_names[55], 7}, 3},
        {{&BweProbeResultFailure_FailureReason_names[62], 7}, 0},
};

static const int BweProbeResultFailure_FailureReason_entries_by_number[] = {
    3,  // 0 -> UNKNOWN
    0,  // 1 -> INVALID_SEND_RECEIVE_INTERVAL
    1,  // 2 -> INVALID_SEND_RECEIVE_RATIO
    2,  // 3 -> TIMEOUT
};

const std::string& BweProbeResultFailure_FailureReason_Name(BweProbeResultFailure_FailureReason value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          BweProbeResultFailure_FailureReason_entries, BweProbeResultFailure_FailureReason_entries_by_number,
          4, BweProbeResultFailure_FailureReason_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      BweProbeResultFailure_FailureReason_entries, BweProbeResultFailure_FailureReason_entries_by_number, 4,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : BweProbeResultFailure_FailureReason_strings[idx].get();
}

bool BweProbeResultFailure_FailureReason_Parse(absl::string_view name, BweProbeResultFailure_FailureReason* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      BweProbeResultFailure_FailureReason_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<BweProbeResultFailure_FailureReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::UNKNOWN;
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::INVALID_SEND_RECEIVE_INTERVAL;
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::INVALID_SEND_RECEIVE_RATIO;
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::TIMEOUT;
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::FailureReason_MIN;
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure::FailureReason_MAX;
constexpr int BweProbeResultFailure::FailureReason_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t IceCandidatePairConfig_IceCandidatePairConfigType_internal_data_[] = {
    327680u, 0u, };
bool IceCandidatePairConfig_IceCandidatePairConfigType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    IceCandidatePairConfig_IceCandidatePairConfigType_strings[5] = {};

static const char IceCandidatePairConfig_IceCandidatePairConfigType_names[] = {
    "ADDED"
    "DESTROYED"
    "SELECTED"
    "UNKNOWN_CONFIG_TYPE"
    "UPDATED"
};

static const ::google::protobuf::internal::EnumEntry IceCandidatePairConfig_IceCandidatePairConfigType_entries[] =
    {
        {{&IceCandidatePairConfig_IceCandidatePairConfigType_names[0], 5}, 1},
        {{&IceCandidatePairConfig_IceCandidatePairConfigType_names[5], 9}, 3},
        {{&IceCandidatePairConfig_IceCandidatePairConfigType_names[14], 8}, 4},
        {{&IceCandidatePairConfig_IceCandidatePairConfigType_names[22], 19}, 0},
        {{&IceCandidatePairConfig_IceCandidatePairConfigType_names[41], 7}, 2},
};

static const int IceCandidatePairConfig_IceCandidatePairConfigType_entries_by_number[] = {
    3,  // 0 -> UNKNOWN_CONFIG_TYPE
    0,  // 1 -> ADDED
    4,  // 2 -> UPDATED
    1,  // 3 -> DESTROYED
    2,  // 4 -> SELECTED
};

const std::string& IceCandidatePairConfig_IceCandidatePairConfigType_Name(IceCandidatePairConfig_IceCandidatePairConfigType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          IceCandidatePairConfig_IceCandidatePairConfigType_entries, IceCandidatePairConfig_IceCandidatePairConfigType_entries_by_number,
          5, IceCandidatePairConfig_IceCandidatePairConfigType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      IceCandidatePairConfig_IceCandidatePairConfigType_entries, IceCandidatePairConfig_IceCandidatePairConfigType_entries_by_number, 5,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : IceCandidatePairConfig_IceCandidatePairConfigType_strings[idx].get();
}

bool IceCandidatePairConfig_IceCandidatePairConfigType_Parse(absl::string_view name, IceCandidatePairConfig_IceCandidatePairConfigType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      IceCandidatePairConfig_IceCandidatePairConfigType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairConfig_IceCandidatePairConfigType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::UNKNOWN_CONFIG_TYPE;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::ADDED;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::UPDATED;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::DESTROYED;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::SELECTED;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::IceCandidatePairConfigType_MIN;
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::IceCandidatePairConfigType_MAX;
constexpr int IceCandidatePairConfig::IceCandidatePairConfigType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t IceCandidatePairConfig_IceCandidateType_internal_data_[] = {
    327680u, 0u, };
bool IceCandidatePairConfig_IceCandidateType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    IceCandidatePairConfig_IceCandidateType_strings[5] = {};

static const char IceCandidatePairConfig_IceCandidateType_names[] = {
    "LOCAL"
    "PRFLX"
    "RELAY"
    "STUN"
    "UNKNOWN_CANDIDATE_TYPE"
};

static const ::google::protobuf::internal::EnumEntry IceCandidatePairConfig_IceCandidateType_entries[] =
    {
        {{&IceCandidatePairConfig_IceCandidateType_names[0], 5}, 1},
        {{&IceCandidatePairConfig_IceCandidateType_names[5], 5}, 3},
        {{&IceCandidatePairConfig_IceCandidateType_names[10], 5}, 4},
        {{&IceCandidatePairConfig_IceCandidateType_names[15], 4}, 2},
        {{&IceCandidatePairConfig_IceCandidateType_names[19], 22}, 0},
};

static const int IceCandidatePairConfig_IceCandidateType_entries_by_number[] = {
    4,  // 0 -> UNKNOWN_CANDIDATE_TYPE
    0,  // 1 -> LOCAL
    3,  // 2 -> STUN
    1,  // 3 -> PRFLX
    2,  // 4 -> RELAY
};

const std::string& IceCandidatePairConfig_IceCandidateType_Name(IceCandidatePairConfig_IceCandidateType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          IceCandidatePairConfig_IceCandidateType_entries, IceCandidatePairConfig_IceCandidateType_entries_by_number,
          5, IceCandidatePairConfig_IceCandidateType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      IceCandidatePairConfig_IceCandidateType_entries, IceCandidatePairConfig_IceCandidateType_entries_by_number, 5,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : IceCandidatePairConfig_IceCandidateType_strings[idx].get();
}

bool IceCandidatePairConfig_IceCandidateType_Parse(absl::string_view name, IceCandidatePairConfig_IceCandidateType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      IceCandidatePairConfig_IceCandidateType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairConfig_IceCandidateType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::UNKNOWN_CANDIDATE_TYPE;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::LOCAL;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::STUN;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::PRFLX;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::RELAY;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::IceCandidateType_MIN;
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::IceCandidateType_MAX;
constexpr int IceCandidatePairConfig::IceCandidateType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t IceCandidatePairConfig_Protocol_internal_data_[] = {
    327680u, 0u, };
bool IceCandidatePairConfig_Protocol_IsValid(int value) {
  return 0 <= value && value <= 4;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    IceCandidatePairConfig_Protocol_strings[5] = {};

static const char IceCandidatePairConfig_Protocol_names[] = {
    "SSLTCP"
    "TCP"
    "TLS"
    "UDP"
    "UNKNOWN_PROTOCOL"
};

static const ::google::protobuf::internal::EnumEntry IceCandidatePairConfig_Protocol_entries[] =
    {
        {{&IceCandidatePairConfig_Protocol_names[0], 6}, 3},
        {{&IceCandidatePairConfig_Protocol_names[6], 3}, 2},
        {{&IceCandidatePairConfig_Protocol_names[9], 3}, 4},
        {{&IceCandidatePairConfig_Protocol_names[12], 3}, 1},
        {{&IceCandidatePairConfig_Protocol_names[15], 16}, 0},
};

static const int IceCandidatePairConfig_Protocol_entries_by_number[] = {
    4,  // 0 -> UNKNOWN_PROTOCOL
    3,  // 1 -> UDP
    1,  // 2 -> TCP
    0,  // 3 -> SSLTCP
    2,  // 4 -> TLS
};

const std::string& IceCandidatePairConfig_Protocol_Name(IceCandidatePairConfig_Protocol value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          IceCandidatePairConfig_Protocol_entries, IceCandidatePairConfig_Protocol_entries_by_number,
          5, IceCandidatePairConfig_Protocol_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      IceCandidatePairConfig_Protocol_entries, IceCandidatePairConfig_Protocol_entries_by_number, 5,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : IceCandidatePairConfig_Protocol_strings[idx].get();
}

bool IceCandidatePairConfig_Protocol_Parse(absl::string_view name, IceCandidatePairConfig_Protocol* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      IceCandidatePairConfig_Protocol_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairConfig_Protocol>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::UNKNOWN_PROTOCOL;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::UDP;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::TCP;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::SSLTCP;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::TLS;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::Protocol_MIN;
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig::Protocol_MAX;
constexpr int IceCandidatePairConfig::Protocol_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t IceCandidatePairConfig_AddressFamily_internal_data_[] = {
    196608u, 0u, };
bool IceCandidatePairConfig_AddressFamily_IsValid(int value) {
  return 0 <= value && value <= 2;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    IceCandidatePairConfig_AddressFamily_strings[3] = {};

static const char IceCandidatePairConfig_AddressFamily_names[] = {
    "IPV4"
    "IPV6"
    "UNKNOWN_ADDRESS_FAMILY"
};

static const ::google::protobuf::internal::EnumEntry IceCandidatePairConfig_AddressFamily_entries[] =
    {
        {{&IceCandidatePairConfig_AddressFamily_names[0], 4}, 1},
        {{&IceCandidatePairConfig_AddressFamily_names[4], 4}, 2},
        {{&IceCandidatePairConfig_AddressFamily_names[8], 22}, 0},
};

static const int IceCandidatePairConfig_AddressFamily_entries_by_number[] = {
    2,  // 0 -> UNKNOWN_ADDRESS_FAMILY
    0,  // 1 -> IPV4
    1,  // 2 -> IPV6
};

const std::string& IceCandidatePairConfig_AddressFamily_Name(IceCandidatePairConfig_AddressFamily value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          IceCandidatePairConfig_AddressFamily_entries, IceCandidatePairConfig_AddressFamily_entries_by_number,
          3, IceCandidatePairConfig_AddressFamily_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      IceCandidatePairConfig_AddressFamily_entries, IceCandidatePairConfig_AddressFamily_entries_by_number, 3,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : IceCandidatePairConfig_AddressFamily_strings[idx].get();
}

bool IceCandidatePairConfig_AddressFamily_Parse(absl::string_view name, IceCandidatePairConfig_AddressFamily* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      IceCandidatePairConfig_AddressFamily_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairConfig_AddressFamily>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::UNKNOWN_ADDRESS_FAMILY;
constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::IPV4;
constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::IPV6;
constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::AddressFamily_MIN;
constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::AddressFamily_MAX;
constexpr int IceCandidatePairConfig::AddressFamily_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t IceCandidatePairConfig_NetworkType_internal_data_[] = {
    393216u, 0u, };
bool IceCandidatePairConfig_NetworkType_IsValid(int value) {
  return 0 <= value && value <= 5;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    IceCandidatePairConfig_NetworkType_strings[6] = {};

static const char IceCandidatePairConfig_NetworkType_names[] = {
    "CELLULAR"
    "ETHERNET"
    "LOOPBACK"
    "UNKNOWN_NETWORK_TYPE"
    "VPN"
    "WIFI"
};

static const ::google::protobuf::internal::EnumEntry IceCandidatePairConfig_NetworkType_entries[] =
    {
        {{&IceCandidatePairConfig_NetworkType_names[0], 8}, 3},
        {{&IceCandidatePairConfig_NetworkType_names[8], 8}, 1},
        {{&IceCandidatePairConfig_NetworkType_names[16], 8}, 5},
        {{&IceCandidatePairConfig_NetworkType_names[24], 20}, 0},
        {{&IceCandidatePairConfig_NetworkType_names[44], 3}, 4},
        {{&IceCandidatePairConfig_NetworkType_names[47], 4}, 2},
};

static const int IceCandidatePairConfig_NetworkType_entries_by_number[] = {
    3,  // 0 -> UNKNOWN_NETWORK_TYPE
    1,  // 1 -> ETHERNET
    5,  // 2 -> WIFI
    0,  // 3 -> CELLULAR
    4,  // 4 -> VPN
    2,  // 5 -> LOOPBACK
};

const std::string& IceCandidatePairConfig_NetworkType_Name(IceCandidatePairConfig_NetworkType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          IceCandidatePairConfig_NetworkType_entries, IceCandidatePairConfig_NetworkType_entries_by_number,
          6, IceCandidatePairConfig_NetworkType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      IceCandidatePairConfig_NetworkType_entries, IceCandidatePairConfig_NetworkType_entries_by_number, 6,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : IceCandidatePairConfig_NetworkType_strings[idx].get();
}

bool IceCandidatePairConfig_NetworkType_Parse(absl::string_view name, IceCandidatePairConfig_NetworkType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      IceCandidatePairConfig_NetworkType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairConfig_NetworkType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::UNKNOWN_NETWORK_TYPE;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::ETHERNET;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::WIFI;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::CELLULAR;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::VPN;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::LOOPBACK;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::NetworkType_MIN;
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig::NetworkType_MAX;
constexpr int IceCandidatePairConfig::NetworkType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t IceCandidatePairEvent_IceCandidatePairEventType_internal_data_[] = {
    327680u, 0u, };
bool IceCandidatePairEvent_IceCandidatePairEventType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    IceCandidatePairEvent_IceCandidatePairEventType_strings[5] = {};

static const char IceCandidatePairEvent_IceCandidatePairEventType_names[] = {
    "CHECK_RECEIVED"
    "CHECK_RESPONSE_RECEIVED"
    "CHECK_RESPONSE_SENT"
    "CHECK_SENT"
    "UNKNOWN_CHECK_TYPE"
};

static const ::google::protobuf::internal::EnumEntry IceCandidatePairEvent_IceCandidatePairEventType_entries[] =
    {
        {{&IceCandidatePairEvent_IceCandidatePairEventType_names[0], 14}, 2},
        {{&IceCandidatePairEvent_IceCandidatePairEventType_names[14], 23}, 4},
        {{&IceCandidatePairEvent_IceCandidatePairEventType_names[37], 19}, 3},
        {{&IceCandidatePairEvent_IceCandidatePairEventType_names[56], 10}, 1},
        {{&IceCandidatePairEvent_IceCandidatePairEventType_names[66], 18}, 0},
};

static const int IceCandidatePairEvent_IceCandidatePairEventType_entries_by_number[] = {
    4,  // 0 -> UNKNOWN_CHECK_TYPE
    3,  // 1 -> CHECK_SENT
    0,  // 2 -> CHECK_RECEIVED
    2,  // 3 -> CHECK_RESPONSE_SENT
    1,  // 4 -> CHECK_RESPONSE_RECEIVED
};

const std::string& IceCandidatePairEvent_IceCandidatePairEventType_Name(IceCandidatePairEvent_IceCandidatePairEventType value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          IceCandidatePairEvent_IceCandidatePairEventType_entries, IceCandidatePairEvent_IceCandidatePairEventType_entries_by_number,
          5, IceCandidatePairEvent_IceCandidatePairEventType_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      IceCandidatePairEvent_IceCandidatePairEventType_entries, IceCandidatePairEvent_IceCandidatePairEventType_entries_by_number, 5,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : IceCandidatePairEvent_IceCandidatePairEventType_strings[idx].get();
}

bool IceCandidatePairEvent_IceCandidatePairEventType_Parse(absl::string_view name, IceCandidatePairEvent_IceCandidatePairEventType* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      IceCandidatePairEvent_IceCandidatePairEventType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<IceCandidatePairEvent_IceCandidatePairEventType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::UNKNOWN_CHECK_TYPE;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::CHECK_SENT;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::CHECK_RECEIVED;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::CHECK_RESPONSE_SENT;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::CHECK_RESPONSE_RECEIVED;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::IceCandidatePairEventType_MIN;
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::IceCandidatePairEventType_MAX;
constexpr int IceCandidatePairEvent::IceCandidatePairEventType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
PROTOBUF_CONSTINIT const uint32_t DtlsTransportStateEvent_DtlsTransportState_internal_data_[] = {
    393216u, 0u, };
bool DtlsTransportStateEvent_DtlsTransportState_IsValid(int value) {
  return 0 <= value && value <= 5;
}
static ::google::protobuf::internal::ExplicitlyConstructed<std::string>
    DtlsTransportStateEvent_DtlsTransportState_strings[6] = {};

static const char DtlsTransportStateEvent_DtlsTransportState_names[] = {
    "DTLS_TRANSPORT_CLOSED"
    "DTLS_TRANSPORT_CONNECTED"
    "DTLS_TRANSPORT_CONNECTING"
    "DTLS_TRANSPORT_FAILED"
    "DTLS_TRANSPORT_NEW"
    "UNKNOWN_DTLS_TRANSPORT_STATE"
};

static const ::google::protobuf::internal::EnumEntry DtlsTransportStateEvent_DtlsTransportState_entries[] =
    {
        {{&DtlsTransportStateEvent_DtlsTransportState_names[0], 21}, 4},
        {{&DtlsTransportStateEvent_DtlsTransportState_names[21], 24}, 3},
        {{&DtlsTransportStateEvent_DtlsTransportState_names[45], 25}, 2},
        {{&DtlsTransportStateEvent_DtlsTransportState_names[70], 21}, 5},
        {{&DtlsTransportStateEvent_DtlsTransportState_names[91], 18}, 1},
        {{&DtlsTransportStateEvent_DtlsTransportState_names[109], 28}, 0},
};

static const int DtlsTransportStateEvent_DtlsTransportState_entries_by_number[] = {
    5,  // 0 -> UNKNOWN_DTLS_TRANSPORT_STATE
    4,  // 1 -> DTLS_TRANSPORT_NEW
    2,  // 2 -> DTLS_TRANSPORT_CONNECTING
    1,  // 3 -> DTLS_TRANSPORT_CONNECTED
    0,  // 4 -> DTLS_TRANSPORT_CLOSED
    3,  // 5 -> DTLS_TRANSPORT_FAILED
};

const std::string& DtlsTransportStateEvent_DtlsTransportState_Name(DtlsTransportStateEvent_DtlsTransportState value) {
  static const bool kDummy =
      ::google::protobuf::internal::InitializeEnumStrings(
          DtlsTransportStateEvent_DtlsTransportState_entries, DtlsTransportStateEvent_DtlsTransportState_entries_by_number,
          6, DtlsTransportStateEvent_DtlsTransportState_strings);
  (void)kDummy;

  int idx = ::google::protobuf::internal::LookUpEnumName(
      DtlsTransportStateEvent_DtlsTransportState_entries, DtlsTransportStateEvent_DtlsTransportState_entries_by_number, 6,
      value);
  return idx == -1 ? ::google::protobuf::internal::GetEmptyString()
                   : DtlsTransportStateEvent_DtlsTransportState_strings[idx].get();
}

bool DtlsTransportStateEvent_DtlsTransportState_Parse(absl::string_view name, DtlsTransportStateEvent_DtlsTransportState* value) {
  int int_value;
  bool success = ::google::protobuf::internal::LookUpEnumValue(
      DtlsTransportStateEvent_DtlsTransportState_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<DtlsTransportStateEvent_DtlsTransportState>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::UNKNOWN_DTLS_TRANSPORT_STATE;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DTLS_TRANSPORT_NEW;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DTLS_TRANSPORT_CONNECTING;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DTLS_TRANSPORT_CONNECTED;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DTLS_TRANSPORT_CLOSED;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DTLS_TRANSPORT_FAILED;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DtlsTransportState_MIN;
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::DtlsTransportState_MAX;
constexpr int DtlsTransportStateEvent::DtlsTransportState_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class EventStream::_Internal {
 public:
};

EventStream::EventStream(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.EventStream)
}
inline PROTOBUF_NDEBUG_INLINE EventStream::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : stream_{visibility, arena, from.stream_},
        incoming_rtp_packets_{visibility, arena, from.incoming_rtp_packets_},
        outgoing_rtp_packets_{visibility, arena, from.outgoing_rtp_packets_},
        incoming_rtcp_packets_{visibility, arena, from.incoming_rtcp_packets_},
        outgoing_rtcp_packets_{visibility, arena, from.outgoing_rtcp_packets_},
        audio_playout_events_{visibility, arena, from.audio_playout_events_},
        frame_decoded_events_{visibility, arena, from.frame_decoded_events_},
        begin_log_events_{visibility, arena, from.begin_log_events_},
        end_log_events_{visibility, arena, from.end_log_events_},
        loss_based_bwe_updates_{visibility, arena, from.loss_based_bwe_updates_},
        delay_based_bwe_updates_{visibility, arena, from.delay_based_bwe_updates_},
        audio_network_adaptations_{visibility, arena, from.audio_network_adaptations_},
        probe_clusters_{visibility, arena, from.probe_clusters_},
        probe_success_{visibility, arena, from.probe_success_},
        probe_failure_{visibility, arena, from.probe_failure_},
        alr_states_{visibility, arena, from.alr_states_},
        ice_candidate_configs_{visibility, arena, from.ice_candidate_configs_},
        ice_candidate_events_{visibility, arena, from.ice_candidate_events_},
        dtls_transport_state_events_{visibility, arena, from.dtls_transport_state_events_},
        dtls_writable_states_{visibility, arena, from.dtls_writable_states_},
        generic_packets_sent_{visibility, arena, from.generic_packets_sent_},
        generic_packets_received_{visibility, arena, from.generic_packets_received_},
        generic_acks_received_{visibility, arena, from.generic_acks_received_},
        route_changes_{visibility, arena, from.route_changes_},
        remote_estimates_{visibility, arena, from.remote_estimates_},
        neteq_set_minimum_delay_{visibility, arena, from.neteq_set_minimum_delay_},
        audio_recv_stream_configs_{visibility, arena, from.audio_recv_stream_configs_},
        audio_send_stream_configs_{visibility, arena, from.audio_send_stream_configs_},
        video_recv_stream_configs_{visibility, arena, from.video_recv_stream_configs_},
        video_send_stream_configs_{visibility, arena, from.video_send_stream_configs_},
        _cached_size_{0} {}

EventStream::EventStream(
    ::google::protobuf::Arena* arena,
    const EventStream& from)
    : ::google::protobuf::MessageLite(arena) {
  EventStream* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.EventStream)
}
inline PROTOBUF_NDEBUG_INLINE EventStream::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : stream_{visibility, arena},
        incoming_rtp_packets_{visibility, arena},
        outgoing_rtp_packets_{visibility, arena},
        incoming_rtcp_packets_{visibility, arena},
        outgoing_rtcp_packets_{visibility, arena},
        audio_playout_events_{visibility, arena},
        frame_decoded_events_{visibility, arena},
        begin_log_events_{visibility, arena},
        end_log_events_{visibility, arena},
        loss_based_bwe_updates_{visibility, arena},
        delay_based_bwe_updates_{visibility, arena},
        audio_network_adaptations_{visibility, arena},
        probe_clusters_{visibility, arena},
        probe_success_{visibility, arena},
        probe_failure_{visibility, arena},
        alr_states_{visibility, arena},
        ice_candidate_configs_{visibility, arena},
        ice_candidate_events_{visibility, arena},
        dtls_transport_state_events_{visibility, arena},
        dtls_writable_states_{visibility, arena},
        generic_packets_sent_{visibility, arena},
        generic_packets_received_{visibility, arena},
        generic_acks_received_{visibility, arena},
        route_changes_{visibility, arena},
        remote_estimates_{visibility, arena},
        neteq_set_minimum_delay_{visibility, arena},
        audio_recv_stream_configs_{visibility, arena},
        audio_send_stream_configs_{visibility, arena},
        video_recv_stream_configs_{visibility, arena},
        video_send_stream_configs_{visibility, arena},
        _cached_size_{0} {}

inline void EventStream::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
EventStream::~EventStream() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.EventStream)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void EventStream::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void EventStream::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.EventStream)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stream_.Clear();
  _impl_.incoming_rtp_packets_.Clear();
  _impl_.outgoing_rtp_packets_.Clear();
  _impl_.incoming_rtcp_packets_.Clear();
  _impl_.outgoing_rtcp_packets_.Clear();
  _impl_.audio_playout_events_.Clear();
  _impl_.frame_decoded_events_.Clear();
  _impl_.begin_log_events_.Clear();
  _impl_.end_log_events_.Clear();
  _impl_.loss_based_bwe_updates_.Clear();
  _impl_.delay_based_bwe_updates_.Clear();
  _impl_.audio_network_adaptations_.Clear();
  _impl_.probe_clusters_.Clear();
  _impl_.probe_success_.Clear();
  _impl_.probe_failure_.Clear();
  _impl_.alr_states_.Clear();
  _impl_.ice_candidate_configs_.Clear();
  _impl_.ice_candidate_events_.Clear();
  _impl_.dtls_transport_state_events_.Clear();
  _impl_.dtls_writable_states_.Clear();
  _impl_.generic_packets_sent_.Clear();
  _impl_.generic_packets_received_.Clear();
  _impl_.generic_acks_received_.Clear();
  _impl_.route_changes_.Clear();
  _impl_.remote_estimates_.Clear();
  _impl_.neteq_set_minimum_delay_.Clear();
  _impl_.audio_recv_stream_configs_.Clear();
  _impl_.audio_send_stream_configs_.Clear();
  _impl_.video_recv_stream_configs_.Clear();
  _impl_.video_send_stream_configs_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EventStream::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 30, 30, 0, 15> EventStream::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    104, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    32640,  // skipmap
    offsetof(decltype(_table_), field_entries),
    30,  // num_field_entries
    30,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_EventStream_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .webrtc.rtclog2.Event stream = 1 [deprecated = true];
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.stream_)}},
    // repeated .webrtc.rtclog2.IncomingRtpPackets incoming_rtp_packets = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.incoming_rtp_packets_)}},
    // repeated .webrtc.rtclog2.OutgoingRtpPackets outgoing_rtp_packets = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 2, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.outgoing_rtp_packets_)}},
    // repeated .webrtc.rtclog2.IncomingRtcpPackets incoming_rtcp_packets = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 3, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.incoming_rtcp_packets_)}},
    // repeated .webrtc.rtclog2.OutgoingRtcpPackets outgoing_rtcp_packets = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 4, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.outgoing_rtcp_packets_)}},
    // repeated .webrtc.rtclog2.AudioPlayoutEvents audio_playout_events = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 63, 5, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.audio_playout_events_)}},
    // repeated .webrtc.rtclog2.FrameDecodedEvents frame_decoded_events = 7;
    {::_pbi::TcParser::FastMtR1,
     {58, 63, 6, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.frame_decoded_events_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .webrtc.rtclog2.BeginLogEvent begin_log_events = 16;
    {::_pbi::TcParser::FastMtR2,
     {386, 63, 7, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.begin_log_events_)}},
    // repeated .webrtc.rtclog2.EndLogEvent end_log_events = 17;
    {::_pbi::TcParser::FastMtR2,
     {394, 63, 8, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.end_log_events_)}},
    // repeated .webrtc.rtclog2.LossBasedBweUpdates loss_based_bwe_updates = 18;
    {::_pbi::TcParser::FastMtR2,
     {402, 63, 9, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.loss_based_bwe_updates_)}},
    // repeated .webrtc.rtclog2.DelayBasedBweUpdates delay_based_bwe_updates = 19;
    {::_pbi::TcParser::FastMtR2,
     {410, 63, 10, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.delay_based_bwe_updates_)}},
    // repeated .webrtc.rtclog2.AudioNetworkAdaptations audio_network_adaptations = 20;
    {::_pbi::TcParser::FastMtR2,
     {418, 63, 11, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.audio_network_adaptations_)}},
    // repeated .webrtc.rtclog2.BweProbeCluster probe_clusters = 21;
    {::_pbi::TcParser::FastMtR2,
     {426, 63, 12, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.probe_clusters_)}},
    // repeated .webrtc.rtclog2.BweProbeResultSuccess probe_success = 22;
    {::_pbi::TcParser::FastMtR2,
     {434, 63, 13, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.probe_success_)}},
    // repeated .webrtc.rtclog2.BweProbeResultFailure probe_failure = 23;
    {::_pbi::TcParser::FastMtR2,
     {442, 63, 14, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.probe_failure_)}},
    // repeated .webrtc.rtclog2.AlrState alr_states = 24;
    {::_pbi::TcParser::FastMtR2,
     {450, 63, 15, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.alr_states_)}},
    // repeated .webrtc.rtclog2.IceCandidatePairConfig ice_candidate_configs = 25;
    {::_pbi::TcParser::FastMtR2,
     {458, 63, 16, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.ice_candidate_configs_)}},
    // repeated .webrtc.rtclog2.IceCandidatePairEvent ice_candidate_events = 26;
    {::_pbi::TcParser::FastMtR2,
     {466, 63, 17, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.ice_candidate_events_)}},
    // repeated .webrtc.rtclog2.DtlsTransportStateEvent dtls_transport_state_events = 27;
    {::_pbi::TcParser::FastMtR2,
     {474, 63, 18, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.dtls_transport_state_events_)}},
    // repeated .webrtc.rtclog2.DtlsWritableState dtls_writable_states = 28;
    {::_pbi::TcParser::FastMtR2,
     {482, 63, 19, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.dtls_writable_states_)}},
    // repeated .webrtc.rtclog2.GenericPacketSent generic_packets_sent = 29;
    {::_pbi::TcParser::FastMtR2,
     {490, 63, 20, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.generic_packets_sent_)}},
    // repeated .webrtc.rtclog2.GenericPacketReceived generic_packets_received = 30;
    {::_pbi::TcParser::FastMtR2,
     {498, 63, 21, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.generic_packets_received_)}},
    // repeated .webrtc.rtclog2.GenericAckReceived generic_acks_received = 31;
    {::_pbi::TcParser::FastMtR2,
     {506, 63, 22, PROTOBUF_FIELD_OFFSET(EventStream, _impl_.generic_acks_received_)}},
  }}, {{
    33, 0, 5,
    65532, 24, 65535, 26, 65535, 26, 65535, 26, 65295, 26,
    65535, 65535
  }}, {{
    // repeated .webrtc.rtclog2.Event stream = 1 [deprecated = true];
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.stream_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.IncomingRtpPackets incoming_rtp_packets = 2;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.incoming_rtp_packets_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.OutgoingRtpPackets outgoing_rtp_packets = 3;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.outgoing_rtp_packets_), 0, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.IncomingRtcpPackets incoming_rtcp_packets = 4;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.incoming_rtcp_packets_), 0, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.OutgoingRtcpPackets outgoing_rtcp_packets = 5;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.outgoing_rtcp_packets_), 0, 4,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.AudioPlayoutEvents audio_playout_events = 6;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.audio_playout_events_), 0, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.FrameDecodedEvents frame_decoded_events = 7;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.frame_decoded_events_), 0, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.BeginLogEvent begin_log_events = 16;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.begin_log_events_), 0, 7,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.EndLogEvent end_log_events = 17;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.end_log_events_), 0, 8,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.LossBasedBweUpdates loss_based_bwe_updates = 18;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.loss_based_bwe_updates_), 0, 9,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.DelayBasedBweUpdates delay_based_bwe_updates = 19;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.delay_based_bwe_updates_), 0, 10,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.AudioNetworkAdaptations audio_network_adaptations = 20;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.audio_network_adaptations_), 0, 11,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.BweProbeCluster probe_clusters = 21;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.probe_clusters_), 0, 12,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.BweProbeResultSuccess probe_success = 22;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.probe_success_), 0, 13,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.BweProbeResultFailure probe_failure = 23;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.probe_failure_), 0, 14,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.AlrState alr_states = 24;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.alr_states_), 0, 15,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.IceCandidatePairConfig ice_candidate_configs = 25;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.ice_candidate_configs_), 0, 16,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.IceCandidatePairEvent ice_candidate_events = 26;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.ice_candidate_events_), 0, 17,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.DtlsTransportStateEvent dtls_transport_state_events = 27;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.dtls_transport_state_events_), 0, 18,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.DtlsWritableState dtls_writable_states = 28;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.dtls_writable_states_), 0, 19,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.GenericPacketSent generic_packets_sent = 29;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.generic_packets_sent_), 0, 20,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.GenericPacketReceived generic_packets_received = 30;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.generic_packets_received_), 0, 21,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.GenericAckReceived generic_acks_received = 31;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.generic_acks_received_), 0, 22,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.RouteChange route_changes = 32;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.route_changes_), 0, 23,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.RemoteEstimates remote_estimates = 33;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.remote_estimates_), 0, 24,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.NetEqSetMinimumDelay neteq_set_minimum_delay = 34;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.neteq_set_minimum_delay_), 0, 25,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.AudioRecvStreamConfig audio_recv_stream_configs = 101;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.audio_recv_stream_configs_), 0, 26,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.AudioSendStreamConfig audio_send_stream_configs = 102;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.audio_send_stream_configs_), 0, 27,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.VideoRecvStreamConfig video_recv_stream_configs = 103;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.video_recv_stream_configs_), 0, 28,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .webrtc.rtclog2.VideoSendStreamConfig video_send_stream_configs = 104;
    {PROTOBUF_FIELD_OFFSET(EventStream, _impl_.video_send_stream_configs_), 0, 29,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::Event>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::IncomingRtpPackets>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::OutgoingRtpPackets>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::IncomingRtcpPackets>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::OutgoingRtcpPackets>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::AudioPlayoutEvents>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::FrameDecodedEvents>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::BeginLogEvent>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::EndLogEvent>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::LossBasedBweUpdates>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::DelayBasedBweUpdates>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::AudioNetworkAdaptations>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::BweProbeCluster>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::BweProbeResultSuccess>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::BweProbeResultFailure>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::AlrState>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::IceCandidatePairConfig>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::IceCandidatePairEvent>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::DtlsTransportStateEvent>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::DtlsWritableState>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::GenericPacketSent>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::GenericPacketReceived>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::GenericAckReceived>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::RouteChange>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::RemoteEstimates>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::NetEqSetMinimumDelay>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::AudioRecvStreamConfig>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::AudioSendStreamConfig>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::VideoRecvStreamConfig>()},
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::VideoSendStreamConfig>()},
  }}, {{
  }},
};

::uint8_t* EventStream::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.EventStream)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .webrtc.rtclog2.Event stream = 1 [deprecated = true];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stream_size()); i < n; i++) {
    const auto& repfield = this->_internal_stream().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.IncomingRtpPackets incoming_rtp_packets = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_incoming_rtp_packets_size()); i < n; i++) {
    const auto& repfield = this->_internal_incoming_rtp_packets().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.OutgoingRtpPackets outgoing_rtp_packets = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outgoing_rtp_packets_size()); i < n; i++) {
    const auto& repfield = this->_internal_outgoing_rtp_packets().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.IncomingRtcpPackets incoming_rtcp_packets = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_incoming_rtcp_packets_size()); i < n; i++) {
    const auto& repfield = this->_internal_incoming_rtcp_packets().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.OutgoingRtcpPackets outgoing_rtcp_packets = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_outgoing_rtcp_packets_size()); i < n; i++) {
    const auto& repfield = this->_internal_outgoing_rtcp_packets().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.AudioPlayoutEvents audio_playout_events = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_audio_playout_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_audio_playout_events().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.FrameDecodedEvents frame_decoded_events = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_frame_decoded_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_frame_decoded_events().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.BeginLogEvent begin_log_events = 16;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_begin_log_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_begin_log_events().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.EndLogEvent end_log_events = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_end_log_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_end_log_events().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.LossBasedBweUpdates loss_based_bwe_updates = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_loss_based_bwe_updates_size()); i < n; i++) {
    const auto& repfield = this->_internal_loss_based_bwe_updates().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.DelayBasedBweUpdates delay_based_bwe_updates = 19;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_delay_based_bwe_updates_size()); i < n; i++) {
    const auto& repfield = this->_internal_delay_based_bwe_updates().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(19, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.AudioNetworkAdaptations audio_network_adaptations = 20;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_audio_network_adaptations_size()); i < n; i++) {
    const auto& repfield = this->_internal_audio_network_adaptations().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.BweProbeCluster probe_clusters = 21;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_probe_clusters_size()); i < n; i++) {
    const auto& repfield = this->_internal_probe_clusters().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(21, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.BweProbeResultSuccess probe_success = 22;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_probe_success_size()); i < n; i++) {
    const auto& repfield = this->_internal_probe_success().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.BweProbeResultFailure probe_failure = 23;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_probe_failure_size()); i < n; i++) {
    const auto& repfield = this->_internal_probe_failure().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(23, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.AlrState alr_states = 24;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_alr_states_size()); i < n; i++) {
    const auto& repfield = this->_internal_alr_states().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(24, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.IceCandidatePairConfig ice_candidate_configs = 25;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ice_candidate_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_ice_candidate_configs().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(25, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.IceCandidatePairEvent ice_candidate_events = 26;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ice_candidate_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_ice_candidate_events().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(26, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.DtlsTransportStateEvent dtls_transport_state_events = 27;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dtls_transport_state_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_dtls_transport_state_events().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(27, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.DtlsWritableState dtls_writable_states = 28;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_dtls_writable_states_size()); i < n; i++) {
    const auto& repfield = this->_internal_dtls_writable_states().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(28, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.GenericPacketSent generic_packets_sent = 29;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_generic_packets_sent_size()); i < n; i++) {
    const auto& repfield = this->_internal_generic_packets_sent().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(29, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.GenericPacketReceived generic_packets_received = 30;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_generic_packets_received_size()); i < n; i++) {
    const auto& repfield = this->_internal_generic_packets_received().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(30, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.GenericAckReceived generic_acks_received = 31;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_generic_acks_received_size()); i < n; i++) {
    const auto& repfield = this->_internal_generic_acks_received().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(31, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.RouteChange route_changes = 32;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_route_changes_size()); i < n; i++) {
    const auto& repfield = this->_internal_route_changes().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(32, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.RemoteEstimates remote_estimates = 33;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_remote_estimates_size()); i < n; i++) {
    const auto& repfield = this->_internal_remote_estimates().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(33, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.NetEqSetMinimumDelay neteq_set_minimum_delay = 34;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_neteq_set_minimum_delay_size()); i < n; i++) {
    const auto& repfield = this->_internal_neteq_set_minimum_delay().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(34, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.AudioRecvStreamConfig audio_recv_stream_configs = 101;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_audio_recv_stream_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_audio_recv_stream_configs().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(101, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.AudioSendStreamConfig audio_send_stream_configs = 102;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_audio_send_stream_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_audio_send_stream_configs().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(102, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.VideoRecvStreamConfig video_recv_stream_configs = 103;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_video_recv_stream_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_video_recv_stream_configs().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(103, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .webrtc.rtclog2.VideoSendStreamConfig video_send_stream_configs = 104;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_video_send_stream_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_video_send_stream_configs().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(104, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.EventStream)
  return target;
}

::size_t EventStream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.EventStream)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .webrtc.rtclog2.Event stream = 1 [deprecated = true];
  total_size += 1UL * this->_internal_stream_size();
  for (const auto& msg : this->_internal_stream()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.IncomingRtpPackets incoming_rtp_packets = 2;
  total_size += 1UL * this->_internal_incoming_rtp_packets_size();
  for (const auto& msg : this->_internal_incoming_rtp_packets()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.OutgoingRtpPackets outgoing_rtp_packets = 3;
  total_size += 1UL * this->_internal_outgoing_rtp_packets_size();
  for (const auto& msg : this->_internal_outgoing_rtp_packets()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.IncomingRtcpPackets incoming_rtcp_packets = 4;
  total_size += 1UL * this->_internal_incoming_rtcp_packets_size();
  for (const auto& msg : this->_internal_incoming_rtcp_packets()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.OutgoingRtcpPackets outgoing_rtcp_packets = 5;
  total_size += 1UL * this->_internal_outgoing_rtcp_packets_size();
  for (const auto& msg : this->_internal_outgoing_rtcp_packets()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.AudioPlayoutEvents audio_playout_events = 6;
  total_size += 1UL * this->_internal_audio_playout_events_size();
  for (const auto& msg : this->_internal_audio_playout_events()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.FrameDecodedEvents frame_decoded_events = 7;
  total_size += 1UL * this->_internal_frame_decoded_events_size();
  for (const auto& msg : this->_internal_frame_decoded_events()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.BeginLogEvent begin_log_events = 16;
  total_size += 2UL * this->_internal_begin_log_events_size();
  for (const auto& msg : this->_internal_begin_log_events()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.EndLogEvent end_log_events = 17;
  total_size += 2UL * this->_internal_end_log_events_size();
  for (const auto& msg : this->_internal_end_log_events()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.LossBasedBweUpdates loss_based_bwe_updates = 18;
  total_size += 2UL * this->_internal_loss_based_bwe_updates_size();
  for (const auto& msg : this->_internal_loss_based_bwe_updates()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.DelayBasedBweUpdates delay_based_bwe_updates = 19;
  total_size += 2UL * this->_internal_delay_based_bwe_updates_size();
  for (const auto& msg : this->_internal_delay_based_bwe_updates()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.AudioNetworkAdaptations audio_network_adaptations = 20;
  total_size += 2UL * this->_internal_audio_network_adaptations_size();
  for (const auto& msg : this->_internal_audio_network_adaptations()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.BweProbeCluster probe_clusters = 21;
  total_size += 2UL * this->_internal_probe_clusters_size();
  for (const auto& msg : this->_internal_probe_clusters()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.BweProbeResultSuccess probe_success = 22;
  total_size += 2UL * this->_internal_probe_success_size();
  for (const auto& msg : this->_internal_probe_success()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.BweProbeResultFailure probe_failure = 23;
  total_size += 2UL * this->_internal_probe_failure_size();
  for (const auto& msg : this->_internal_probe_failure()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.AlrState alr_states = 24;
  total_size += 2UL * this->_internal_alr_states_size();
  for (const auto& msg : this->_internal_alr_states()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.IceCandidatePairConfig ice_candidate_configs = 25;
  total_size += 2UL * this->_internal_ice_candidate_configs_size();
  for (const auto& msg : this->_internal_ice_candidate_configs()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.IceCandidatePairEvent ice_candidate_events = 26;
  total_size += 2UL * this->_internal_ice_candidate_events_size();
  for (const auto& msg : this->_internal_ice_candidate_events()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.DtlsTransportStateEvent dtls_transport_state_events = 27;
  total_size += 2UL * this->_internal_dtls_transport_state_events_size();
  for (const auto& msg : this->_internal_dtls_transport_state_events()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.DtlsWritableState dtls_writable_states = 28;
  total_size += 2UL * this->_internal_dtls_writable_states_size();
  for (const auto& msg : this->_internal_dtls_writable_states()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.GenericPacketSent generic_packets_sent = 29;
  total_size += 2UL * this->_internal_generic_packets_sent_size();
  for (const auto& msg : this->_internal_generic_packets_sent()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.GenericPacketReceived generic_packets_received = 30;
  total_size += 2UL * this->_internal_generic_packets_received_size();
  for (const auto& msg : this->_internal_generic_packets_received()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.GenericAckReceived generic_acks_received = 31;
  total_size += 2UL * this->_internal_generic_acks_received_size();
  for (const auto& msg : this->_internal_generic_acks_received()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.RouteChange route_changes = 32;
  total_size += 2UL * this->_internal_route_changes_size();
  for (const auto& msg : this->_internal_route_changes()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.RemoteEstimates remote_estimates = 33;
  total_size += 2UL * this->_internal_remote_estimates_size();
  for (const auto& msg : this->_internal_remote_estimates()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.NetEqSetMinimumDelay neteq_set_minimum_delay = 34;
  total_size += 2UL * this->_internal_neteq_set_minimum_delay_size();
  for (const auto& msg : this->_internal_neteq_set_minimum_delay()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.AudioRecvStreamConfig audio_recv_stream_configs = 101;
  total_size += 2UL * this->_internal_audio_recv_stream_configs_size();
  for (const auto& msg : this->_internal_audio_recv_stream_configs()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.AudioSendStreamConfig audio_send_stream_configs = 102;
  total_size += 2UL * this->_internal_audio_send_stream_configs_size();
  for (const auto& msg : this->_internal_audio_send_stream_configs()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.VideoRecvStreamConfig video_recv_stream_configs = 103;
  total_size += 2UL * this->_internal_video_recv_stream_configs_size();
  for (const auto& msg : this->_internal_video_recv_stream_configs()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .webrtc.rtclog2.VideoSendStreamConfig video_send_stream_configs = 104;
  total_size += 2UL * this->_internal_video_send_stream_configs_size();
  for (const auto& msg : this->_internal_video_send_stream_configs()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void EventStream::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EventStream*>(
      &from));
}

void EventStream::MergeFrom(const EventStream& from) {
  EventStream* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.EventStream)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_stream()->MergeFrom(
      from._internal_stream());
  _this->_internal_mutable_incoming_rtp_packets()->MergeFrom(
      from._internal_incoming_rtp_packets());
  _this->_internal_mutable_outgoing_rtp_packets()->MergeFrom(
      from._internal_outgoing_rtp_packets());
  _this->_internal_mutable_incoming_rtcp_packets()->MergeFrom(
      from._internal_incoming_rtcp_packets());
  _this->_internal_mutable_outgoing_rtcp_packets()->MergeFrom(
      from._internal_outgoing_rtcp_packets());
  _this->_internal_mutable_audio_playout_events()->MergeFrom(
      from._internal_audio_playout_events());
  _this->_internal_mutable_frame_decoded_events()->MergeFrom(
      from._internal_frame_decoded_events());
  _this->_internal_mutable_begin_log_events()->MergeFrom(
      from._internal_begin_log_events());
  _this->_internal_mutable_end_log_events()->MergeFrom(
      from._internal_end_log_events());
  _this->_internal_mutable_loss_based_bwe_updates()->MergeFrom(
      from._internal_loss_based_bwe_updates());
  _this->_internal_mutable_delay_based_bwe_updates()->MergeFrom(
      from._internal_delay_based_bwe_updates());
  _this->_internal_mutable_audio_network_adaptations()->MergeFrom(
      from._internal_audio_network_adaptations());
  _this->_internal_mutable_probe_clusters()->MergeFrom(
      from._internal_probe_clusters());
  _this->_internal_mutable_probe_success()->MergeFrom(
      from._internal_probe_success());
  _this->_internal_mutable_probe_failure()->MergeFrom(
      from._internal_probe_failure());
  _this->_internal_mutable_alr_states()->MergeFrom(
      from._internal_alr_states());
  _this->_internal_mutable_ice_candidate_configs()->MergeFrom(
      from._internal_ice_candidate_configs());
  _this->_internal_mutable_ice_candidate_events()->MergeFrom(
      from._internal_ice_candidate_events());
  _this->_internal_mutable_dtls_transport_state_events()->MergeFrom(
      from._internal_dtls_transport_state_events());
  _this->_internal_mutable_dtls_writable_states()->MergeFrom(
      from._internal_dtls_writable_states());
  _this->_internal_mutable_generic_packets_sent()->MergeFrom(
      from._internal_generic_packets_sent());
  _this->_internal_mutable_generic_packets_received()->MergeFrom(
      from._internal_generic_packets_received());
  _this->_internal_mutable_generic_acks_received()->MergeFrom(
      from._internal_generic_acks_received());
  _this->_internal_mutable_route_changes()->MergeFrom(
      from._internal_route_changes());
  _this->_internal_mutable_remote_estimates()->MergeFrom(
      from._internal_remote_estimates());
  _this->_internal_mutable_neteq_set_minimum_delay()->MergeFrom(
      from._internal_neteq_set_minimum_delay());
  _this->_internal_mutable_audio_recv_stream_configs()->MergeFrom(
      from._internal_audio_recv_stream_configs());
  _this->_internal_mutable_audio_send_stream_configs()->MergeFrom(
      from._internal_audio_send_stream_configs());
  _this->_internal_mutable_video_recv_stream_configs()->MergeFrom(
      from._internal_video_recv_stream_configs());
  _this->_internal_mutable_video_send_stream_configs()->MergeFrom(
      from._internal_video_send_stream_configs());
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventStream::CopyFrom(const EventStream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.EventStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool EventStream::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* EventStream::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void EventStream::InternalSwap(EventStream* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.stream_.InternalSwap(&other->_impl_.stream_);
  _impl_.incoming_rtp_packets_.InternalSwap(&other->_impl_.incoming_rtp_packets_);
  _impl_.outgoing_rtp_packets_.InternalSwap(&other->_impl_.outgoing_rtp_packets_);
  _impl_.incoming_rtcp_packets_.InternalSwap(&other->_impl_.incoming_rtcp_packets_);
  _impl_.outgoing_rtcp_packets_.InternalSwap(&other->_impl_.outgoing_rtcp_packets_);
  _impl_.audio_playout_events_.InternalSwap(&other->_impl_.audio_playout_events_);
  _impl_.frame_decoded_events_.InternalSwap(&other->_impl_.frame_decoded_events_);
  _impl_.begin_log_events_.InternalSwap(&other->_impl_.begin_log_events_);
  _impl_.end_log_events_.InternalSwap(&other->_impl_.end_log_events_);
  _impl_.loss_based_bwe_updates_.InternalSwap(&other->_impl_.loss_based_bwe_updates_);
  _impl_.delay_based_bwe_updates_.InternalSwap(&other->_impl_.delay_based_bwe_updates_);
  _impl_.audio_network_adaptations_.InternalSwap(&other->_impl_.audio_network_adaptations_);
  _impl_.probe_clusters_.InternalSwap(&other->_impl_.probe_clusters_);
  _impl_.probe_success_.InternalSwap(&other->_impl_.probe_success_);
  _impl_.probe_failure_.InternalSwap(&other->_impl_.probe_failure_);
  _impl_.alr_states_.InternalSwap(&other->_impl_.alr_states_);
  _impl_.ice_candidate_configs_.InternalSwap(&other->_impl_.ice_candidate_configs_);
  _impl_.ice_candidate_events_.InternalSwap(&other->_impl_.ice_candidate_events_);
  _impl_.dtls_transport_state_events_.InternalSwap(&other->_impl_.dtls_transport_state_events_);
  _impl_.dtls_writable_states_.InternalSwap(&other->_impl_.dtls_writable_states_);
  _impl_.generic_packets_sent_.InternalSwap(&other->_impl_.generic_packets_sent_);
  _impl_.generic_packets_received_.InternalSwap(&other->_impl_.generic_packets_received_);
  _impl_.generic_acks_received_.InternalSwap(&other->_impl_.generic_acks_received_);
  _impl_.route_changes_.InternalSwap(&other->_impl_.route_changes_);
  _impl_.remote_estimates_.InternalSwap(&other->_impl_.remote_estimates_);
  _impl_.neteq_set_minimum_delay_.InternalSwap(&other->_impl_.neteq_set_minimum_delay_);
  _impl_.audio_recv_stream_configs_.InternalSwap(&other->_impl_.audio_recv_stream_configs_);
  _impl_.audio_send_stream_configs_.InternalSwap(&other->_impl_.audio_send_stream_configs_);
  _impl_.video_recv_stream_configs_.InternalSwap(&other->_impl_.video_recv_stream_configs_);
  _impl_.video_send_stream_configs_.InternalSwap(&other->_impl_.video_send_stream_configs_);
}

std::string EventStream::GetTypeName() const {
  return "webrtc.rtclog2.EventStream";
}

// ===================================================================

class Event::_Internal {
 public:
};

Event::Event(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.Event)
}
Event::Event(
    ::google::protobuf::Arena* arena, const Event& from)
    : Event(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE Event::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Event::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
Event::~Event() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.Event)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void Event::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Event::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.Event)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* Event::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 0, 0, 0, 2> Event::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    0, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967295,  // skipmap
    offsetof(decltype(_table_), field_names),  // no field_entries
    0,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Event_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }},
  // no field_entries, or aux_entries
  {{
  }},
};

::uint8_t* Event::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.Event)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.Event)
  return target;
}

::size_t Event::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.Event)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void Event::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Event*>(
      &from));
}

void Event::MergeFrom(const Event& from) {
  Event* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.Event)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Event::CopyFrom(const Event& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.Event)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Event::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Event::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Event::InternalSwap(Event* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string Event::GetTypeName() const {
  return "webrtc.rtclog2.Event";
}

// ===================================================================

class GenericPacketReceived::_Internal {
 public:
  using HasBits = decltype(std::declval<GenericPacketReceived>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_packet_number(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_packet_length(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_packet_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_packet_length_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

GenericPacketReceived::GenericPacketReceived(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.GenericPacketReceived)
}
inline PROTOBUF_NDEBUG_INLINE GenericPacketReceived::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        packet_number_deltas_(arena, from.packet_number_deltas_),
        packet_length_deltas_(arena, from.packet_length_deltas_) {}

GenericPacketReceived::GenericPacketReceived(
    ::google::protobuf::Arena* arena,
    const GenericPacketReceived& from)
    : ::google::protobuf::MessageLite(arena) {
  GenericPacketReceived* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.GenericPacketReceived)
}
inline PROTOBUF_NDEBUG_INLINE GenericPacketReceived::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        packet_number_deltas_(arena),
        packet_length_deltas_(arena) {}

inline void GenericPacketReceived::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
GenericPacketReceived::~GenericPacketReceived() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.GenericPacketReceived)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void GenericPacketReceived::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.packet_number_deltas_.Destroy();
  _impl_.packet_length_deltas_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void GenericPacketReceived::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.GenericPacketReceived)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.packet_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.packet_length_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_deltas_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.number_of_deltas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GenericPacketReceived::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 0, 2> GenericPacketReceived::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_._has_bits_),
    0, // no _extensions_
    19, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294475768,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_GenericPacketReceived_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional uint32 number_of_deltas = 16;
    {::_pbi::TcParser::FastV32S2,
     {384, 6, 0, PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.number_of_deltas_)}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.timestamp_ms_)}},
    // optional int64 packet_number = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 4, 0, PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.packet_number_)}},
    // optional int32 packet_length = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 5, 0, PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.packet_length_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int64 packet_number = 2;
    {PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.packet_number_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int32 packet_length = 3;
    {PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.packet_length_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 number_of_deltas = 16;
    {PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 17;
    {PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes packet_number_deltas = 18;
    {PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.packet_number_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes packet_length_deltas = 19;
    {PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.packet_length_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* GenericPacketReceived::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.GenericPacketReceived)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional int64 packet_number = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<2>(
            stream, this->_internal_packet_number(), target);
  }

  // optional int32 packet_length = 3;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_packet_length(), target);
  }

  // optional uint32 number_of_deltas = 16;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        16, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 17;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(17, _s, target);
  }

  // optional bytes packet_number_deltas = 18;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_packet_number_deltas();
    target = stream->WriteBytesMaybeAliased(18, _s, target);
  }

  // optional bytes packet_length_deltas = 19;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_packet_length_deltas();
    target = stream->WriteBytesMaybeAliased(19, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.GenericPacketReceived)
  return target;
}

::size_t GenericPacketReceived::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.GenericPacketReceived)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes timestamp_ms_deltas = 17;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes packet_number_deltas = 18;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_packet_number_deltas());
    }

    // optional bytes packet_length_deltas = 19;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_packet_length_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional int64 packet_number = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_packet_number());
    }

    // optional int32 packet_length = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_packet_length());
    }

    // optional uint32 number_of_deltas = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void GenericPacketReceived::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GenericPacketReceived*>(
      &from));
}

void GenericPacketReceived::MergeFrom(const GenericPacketReceived& from) {
  GenericPacketReceived* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.GenericPacketReceived)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_packet_number_deltas(from._internal_packet_number_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_packet_length_deltas(from._internal_packet_length_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.packet_number_ = from._impl_.packet_number_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.packet_length_ = from._impl_.packet_length_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GenericPacketReceived::CopyFrom(const GenericPacketReceived& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.GenericPacketReceived)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool GenericPacketReceived::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* GenericPacketReceived::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void GenericPacketReceived::InternalSwap(GenericPacketReceived* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.packet_number_deltas_, &other->_impl_.packet_number_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.packet_length_deltas_, &other->_impl_.packet_length_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.number_of_deltas_)
      + sizeof(GenericPacketReceived::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(GenericPacketReceived, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string GenericPacketReceived::GetTypeName() const {
  return "webrtc.rtclog2.GenericPacketReceived";
}

// ===================================================================

class GenericPacketSent::_Internal {
 public:
  using HasBits = decltype(std::declval<GenericPacketSent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_packet_number(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_overhead_length(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_payload_length(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_padding_length(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_packet_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_overhead_length_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_payload_length_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_padding_length_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

GenericPacketSent::GenericPacketSent(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.GenericPacketSent)
}
inline PROTOBUF_NDEBUG_INLINE GenericPacketSent::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        packet_number_deltas_(arena, from.packet_number_deltas_),
        overhead_length_deltas_(arena, from.overhead_length_deltas_),
        payload_length_deltas_(arena, from.payload_length_deltas_),
        padding_length_deltas_(arena, from.padding_length_deltas_) {}

GenericPacketSent::GenericPacketSent(
    ::google::protobuf::Arena* arena,
    const GenericPacketSent& from)
    : ::google::protobuf::MessageLite(arena) {
  GenericPacketSent* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.GenericPacketSent)
}
inline PROTOBUF_NDEBUG_INLINE GenericPacketSent::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        packet_number_deltas_(arena),
        overhead_length_deltas_(arena),
        payload_length_deltas_(arena),
        padding_length_deltas_(arena) {}

inline void GenericPacketSent::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
GenericPacketSent::~GenericPacketSent() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.GenericPacketSent)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void GenericPacketSent::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.packet_number_deltas_.Destroy();
  _impl_.overhead_length_deltas_.Destroy();
  _impl_.payload_length_deltas_.Destroy();
  _impl_.padding_length_deltas_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void GenericPacketSent::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.GenericPacketSent)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.packet_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.overhead_length_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.payload_length_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.padding_length_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.overhead_length_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.overhead_length_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.payload_length_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_deltas_) -
        reinterpret_cast<char*>(&_impl_.payload_length_)) + sizeof(_impl_.number_of_deltas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GenericPacketSent::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 11, 0, 0, 2> GenericPacketSent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_._has_bits_),
    0, // no _extensions_
    21, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4292902880,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_GenericPacketSent_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional uint32 number_of_deltas = 16;
    {::_pbi::TcParser::FastV32S2,
     {384, 10, 0, PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.number_of_deltas_)}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 5, 0, PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.timestamp_ms_)}},
    // optional int64 packet_number = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 6, 0, PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.packet_number_)}},
    // optional int32 overhead_length = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 7, 0, PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.overhead_length_)}},
    // optional int32 payload_length = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 8, 0, PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.payload_length_)}},
    // optional int32 padding_length = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 9, 0, PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.padding_length_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int64 packet_number = 2;
    {PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.packet_number_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int32 overhead_length = 3;
    {PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.overhead_length_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 payload_length = 4;
    {PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.payload_length_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 padding_length = 5;
    {PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.padding_length_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 number_of_deltas = 16;
    {PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 17;
    {PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes packet_number_deltas = 18;
    {PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.packet_number_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes overhead_length_deltas = 19;
    {PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.overhead_length_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes payload_length_deltas = 20;
    {PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.payload_length_deltas_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes padding_length_deltas = 21;
    {PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.padding_length_deltas_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* GenericPacketSent::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.GenericPacketSent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional int64 packet_number = 2;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<2>(
            stream, this->_internal_packet_number(), target);
  }

  // optional int32 overhead_length = 3;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_overhead_length(), target);
  }

  // optional int32 payload_length = 4;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_payload_length(), target);
  }

  // optional int32 padding_length = 5;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<5>(
            stream, this->_internal_padding_length(), target);
  }

  // optional uint32 number_of_deltas = 16;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        16, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 17;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(17, _s, target);
  }

  // optional bytes packet_number_deltas = 18;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_packet_number_deltas();
    target = stream->WriteBytesMaybeAliased(18, _s, target);
  }

  // optional bytes overhead_length_deltas = 19;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_overhead_length_deltas();
    target = stream->WriteBytesMaybeAliased(19, _s, target);
  }

  // optional bytes payload_length_deltas = 20;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_payload_length_deltas();
    target = stream->WriteBytesMaybeAliased(20, _s, target);
  }

  // optional bytes padding_length_deltas = 21;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_padding_length_deltas();
    target = stream->WriteBytesMaybeAliased(21, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.GenericPacketSent)
  return target;
}

::size_t GenericPacketSent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.GenericPacketSent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 17;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes packet_number_deltas = 18;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_packet_number_deltas());
    }

    // optional bytes overhead_length_deltas = 19;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_overhead_length_deltas());
    }

    // optional bytes payload_length_deltas = 20;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_payload_length_deltas());
    }

    // optional bytes padding_length_deltas = 21;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_padding_length_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional int64 packet_number = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_packet_number());
    }

    // optional int32 overhead_length = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_overhead_length());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional int32 payload_length = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_payload_length());
    }

    // optional int32 padding_length = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_padding_length());
    }

    // optional uint32 number_of_deltas = 16;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void GenericPacketSent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GenericPacketSent*>(
      &from));
}

void GenericPacketSent::MergeFrom(const GenericPacketSent& from) {
  GenericPacketSent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.GenericPacketSent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_packet_number_deltas(from._internal_packet_number_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_overhead_length_deltas(from._internal_overhead_length_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_payload_length_deltas(from._internal_payload_length_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_padding_length_deltas(from._internal_padding_length_deltas());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.packet_number_ = from._impl_.packet_number_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.overhead_length_ = from._impl_.overhead_length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.payload_length_ = from._impl_.payload_length_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.padding_length_ = from._impl_.padding_length_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GenericPacketSent::CopyFrom(const GenericPacketSent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.GenericPacketSent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool GenericPacketSent::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* GenericPacketSent::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void GenericPacketSent::InternalSwap(GenericPacketSent* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.packet_number_deltas_, &other->_impl_.packet_number_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.overhead_length_deltas_, &other->_impl_.overhead_length_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payload_length_deltas_, &other->_impl_.payload_length_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.padding_length_deltas_, &other->_impl_.padding_length_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.number_of_deltas_)
      + sizeof(GenericPacketSent::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(GenericPacketSent, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string GenericPacketSent::GetTypeName() const {
  return "webrtc.rtclog2.GenericPacketSent";
}

// ===================================================================

class GenericAckReceived::_Internal {
 public:
  using HasBits = decltype(std::declval<GenericAckReceived>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_packet_number(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_acked_packet_number(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_receive_acked_packet_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_packet_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_acked_packet_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_receive_acked_packet_time_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

GenericAckReceived::GenericAckReceived(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.GenericAckReceived)
}
inline PROTOBUF_NDEBUG_INLINE GenericAckReceived::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        packet_number_deltas_(arena, from.packet_number_deltas_),
        acked_packet_number_deltas_(arena, from.acked_packet_number_deltas_),
        receive_acked_packet_time_ms_deltas_(arena, from.receive_acked_packet_time_ms_deltas_) {}

GenericAckReceived::GenericAckReceived(
    ::google::protobuf::Arena* arena,
    const GenericAckReceived& from)
    : ::google::protobuf::MessageLite(arena) {
  GenericAckReceived* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.GenericAckReceived)
}
inline PROTOBUF_NDEBUG_INLINE GenericAckReceived::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        packet_number_deltas_(arena),
        acked_packet_number_deltas_(arena),
        receive_acked_packet_time_ms_deltas_(arena) {}

inline void GenericAckReceived::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
GenericAckReceived::~GenericAckReceived() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.GenericAckReceived)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void GenericAckReceived::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.packet_number_deltas_.Destroy();
  _impl_.acked_packet_number_deltas_.Destroy();
  _impl_.receive_acked_packet_time_ms_deltas_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void GenericAckReceived::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.GenericAckReceived)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.packet_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.acked_packet_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.receive_acked_packet_time_ms_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.receive_acked_packet_time_ms_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.receive_acked_packet_time_ms_));
  }
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GenericAckReceived::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 9, 0, 0, 2> GenericAckReceived::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_._has_bits_),
    0, // no _extensions_
    20, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4293951472,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_GenericAckReceived_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional uint32 number_of_deltas = 16;
    {::_pbi::TcParser::FastV32S2,
     {384, 8, 0, PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.number_of_deltas_)}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 4, 0, PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.timestamp_ms_)}},
    // optional int64 packet_number = 2;
    {::_pbi::TcParser::FastV64S1,
     {16, 5, 0, PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.packet_number_)}},
    // optional int64 acked_packet_number = 3;
    {::_pbi::TcParser::FastV64S1,
     {24, 6, 0, PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.acked_packet_number_)}},
    // optional int64 receive_acked_packet_time_ms = 4;
    {::_pbi::TcParser::FastV64S1,
     {32, 7, 0, PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.receive_acked_packet_time_ms_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int64 packet_number = 2;
    {PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.packet_number_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int64 acked_packet_number = 3;
    {PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.acked_packet_number_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int64 receive_acked_packet_time_ms = 4;
    {PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.receive_acked_packet_time_ms_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 number_of_deltas = 16;
    {PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 17;
    {PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes packet_number_deltas = 18;
    {PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.packet_number_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes acked_packet_number_deltas = 19;
    {PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.acked_packet_number_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes receive_acked_packet_time_ms_deltas = 20;
    {PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.receive_acked_packet_time_ms_deltas_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* GenericAckReceived::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.GenericAckReceived)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional int64 packet_number = 2;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<2>(
            stream, this->_internal_packet_number(), target);
  }

  // optional int64 acked_packet_number = 3;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<3>(
            stream, this->_internal_acked_packet_number(), target);
  }

  // optional int64 receive_acked_packet_time_ms = 4;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<4>(
            stream, this->_internal_receive_acked_packet_time_ms(), target);
  }

  // optional uint32 number_of_deltas = 16;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        16, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 17;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(17, _s, target);
  }

  // optional bytes packet_number_deltas = 18;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_packet_number_deltas();
    target = stream->WriteBytesMaybeAliased(18, _s, target);
  }

  // optional bytes acked_packet_number_deltas = 19;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_acked_packet_number_deltas();
    target = stream->WriteBytesMaybeAliased(19, _s, target);
  }

  // optional bytes receive_acked_packet_time_ms_deltas = 20;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_receive_acked_packet_time_ms_deltas();
    target = stream->WriteBytesMaybeAliased(20, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.GenericAckReceived)
  return target;
}

::size_t GenericAckReceived::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.GenericAckReceived)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 17;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes packet_number_deltas = 18;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_packet_number_deltas());
    }

    // optional bytes acked_packet_number_deltas = 19;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_acked_packet_number_deltas());
    }

    // optional bytes receive_acked_packet_time_ms_deltas = 20;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_receive_acked_packet_time_ms_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional int64 packet_number = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_packet_number());
    }

    // optional int64 acked_packet_number = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_acked_packet_number());
    }

    // optional int64 receive_acked_packet_time_ms = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_receive_acked_packet_time_ms());
    }

  }
  // optional uint32 number_of_deltas = 16;
  if (cached_has_bits & 0x00000100u) {
    total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                    this->_internal_number_of_deltas());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void GenericAckReceived::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GenericAckReceived*>(
      &from));
}

void GenericAckReceived::MergeFrom(const GenericAckReceived& from) {
  GenericAckReceived* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.GenericAckReceived)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_packet_number_deltas(from._internal_packet_number_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_acked_packet_number_deltas(from._internal_acked_packet_number_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_receive_acked_packet_time_ms_deltas(from._internal_receive_acked_packet_time_ms_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.packet_number_ = from._impl_.packet_number_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.acked_packet_number_ = from._impl_.acked_packet_number_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.receive_acked_packet_time_ms_ = from._impl_.receive_acked_packet_time_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_number_of_deltas(from._internal_number_of_deltas());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GenericAckReceived::CopyFrom(const GenericAckReceived& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.GenericAckReceived)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool GenericAckReceived::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* GenericAckReceived::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void GenericAckReceived::InternalSwap(GenericAckReceived* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.packet_number_deltas_, &other->_impl_.packet_number_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.acked_packet_number_deltas_, &other->_impl_.acked_packet_number_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.receive_acked_packet_time_ms_deltas_, &other->_impl_.receive_acked_packet_time_ms_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.number_of_deltas_)
      + sizeof(GenericAckReceived::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(GenericAckReceived, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string GenericAckReceived::GetTypeName() const {
  return "webrtc.rtclog2.GenericAckReceived";
}

// ===================================================================

class DependencyDescriptorsWireInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DependencyDescriptorsWireInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_._has_bits_);
  static void set_has_start_end_bit(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_start_end_bit_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_template_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_template_id_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_frame_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_frame_id_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_extended_infos(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DependencyDescriptorsWireInfo::DependencyDescriptorsWireInfo(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.DependencyDescriptorsWireInfo)
}
inline PROTOBUF_NDEBUG_INLINE DependencyDescriptorsWireInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        start_end_bit_deltas_(arena, from.start_end_bit_deltas_),
        template_id_deltas_(arena, from.template_id_deltas_),
        frame_id_deltas_(arena, from.frame_id_deltas_),
        extended_infos_(arena, from.extended_infos_) {}

DependencyDescriptorsWireInfo::DependencyDescriptorsWireInfo(
    ::google::protobuf::Arena* arena,
    const DependencyDescriptorsWireInfo& from)
    : ::google::protobuf::MessageLite(arena) {
  DependencyDescriptorsWireInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, start_end_bit_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, start_end_bit_),
           offsetof(Impl_, frame_id_) -
               offsetof(Impl_, start_end_bit_) +
               sizeof(Impl_::frame_id_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.DependencyDescriptorsWireInfo)
}
inline PROTOBUF_NDEBUG_INLINE DependencyDescriptorsWireInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        start_end_bit_deltas_(arena),
        template_id_deltas_(arena),
        frame_id_deltas_(arena),
        extended_infos_(arena) {}

inline void DependencyDescriptorsWireInfo::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, start_end_bit_),
           0,
           offsetof(Impl_, frame_id_) -
               offsetof(Impl_, start_end_bit_) +
               sizeof(Impl_::frame_id_));
}
DependencyDescriptorsWireInfo::~DependencyDescriptorsWireInfo() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void DependencyDescriptorsWireInfo::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.start_end_bit_deltas_.Destroy();
  _impl_.template_id_deltas_.Destroy();
  _impl_.frame_id_deltas_.Destroy();
  _impl_.extended_infos_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void DependencyDescriptorsWireInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.start_end_bit_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.template_id_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.frame_id_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.extended_infos_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&_impl_.start_end_bit_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.frame_id_) -
        reinterpret_cast<char*>(&_impl_.start_end_bit_)) + sizeof(_impl_.frame_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DependencyDescriptorsWireInfo::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 0, 2> DependencyDescriptorsWireInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_DependencyDescriptorsWireInfo_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 start_end_bit = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 4, 0, PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.start_end_bit_)}},
    // optional bytes start_end_bit_deltas = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.start_end_bit_deltas_)}},
    // optional uint32 template_id = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 5, 0, PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.template_id_)}},
    // optional bytes template_id_deltas = 4;
    {::_pbi::TcParser::FastBS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.template_id_deltas_)}},
    // optional uint32 frame_id = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 6, 0, PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.frame_id_)}},
    // optional bytes frame_id_deltas = 6;
    {::_pbi::TcParser::FastBS1,
     {50, 2, 0, PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.frame_id_deltas_)}},
    // optional bytes extended_infos = 7;
    {::_pbi::TcParser::FastBS1,
     {58, 3, 0, PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.extended_infos_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 start_end_bit = 1;
    {PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.start_end_bit_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes start_end_bit_deltas = 2;
    {PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.start_end_bit_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 template_id = 3;
    {PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.template_id_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes template_id_deltas = 4;
    {PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.template_id_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 frame_id = 5;
    {PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.frame_id_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes frame_id_deltas = 6;
    {PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.frame_id_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes extended_infos = 7;
    {PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.extended_infos_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* DependencyDescriptorsWireInfo::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 start_end_bit = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_start_end_bit(), target);
  }

  // optional bytes start_end_bit_deltas = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_start_end_bit_deltas();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // optional uint32 template_id = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_template_id(), target);
  }

  // optional bytes template_id_deltas = 4;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_template_id_deltas();
    target = stream->WriteBytesMaybeAliased(4, _s, target);
  }

  // optional uint32 frame_id = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_frame_id(), target);
  }

  // optional bytes frame_id_deltas = 6;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_frame_id_deltas();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  // optional bytes extended_infos = 7;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_extended_infos();
    target = stream->WriteBytesMaybeAliased(7, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  return target;
}

::size_t DependencyDescriptorsWireInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes start_end_bit_deltas = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_start_end_bit_deltas());
    }

    // optional bytes template_id_deltas = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_template_id_deltas());
    }

    // optional bytes frame_id_deltas = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_frame_id_deltas());
    }

    // optional bytes extended_infos = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_extended_infos());
    }

    // optional uint32 start_end_bit = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_start_end_bit());
    }

    // optional uint32 template_id = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_template_id());
    }

    // optional uint32 frame_id = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_frame_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void DependencyDescriptorsWireInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DependencyDescriptorsWireInfo*>(
      &from));
}

void DependencyDescriptorsWireInfo::MergeFrom(const DependencyDescriptorsWireInfo& from) {
  DependencyDescriptorsWireInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_start_end_bit_deltas(from._internal_start_end_bit_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_template_id_deltas(from._internal_template_id_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_frame_id_deltas(from._internal_frame_id_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_extended_infos(from._internal_extended_infos());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.start_end_bit_ = from._impl_.start_end_bit_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.template_id_ = from._impl_.template_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.frame_id_ = from._impl_.frame_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DependencyDescriptorsWireInfo::CopyFrom(const DependencyDescriptorsWireInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.DependencyDescriptorsWireInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DependencyDescriptorsWireInfo::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* DependencyDescriptorsWireInfo::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void DependencyDescriptorsWireInfo::InternalSwap(DependencyDescriptorsWireInfo* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.start_end_bit_deltas_, &other->_impl_.start_end_bit_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.template_id_deltas_, &other->_impl_.template_id_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.frame_id_deltas_, &other->_impl_.frame_id_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.extended_infos_, &other->_impl_.extended_infos_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.frame_id_)
      + sizeof(DependencyDescriptorsWireInfo::_impl_.frame_id_)
      - PROTOBUF_FIELD_OFFSET(DependencyDescriptorsWireInfo, _impl_.start_end_bit_)>(
          reinterpret_cast<char*>(&_impl_.start_end_bit_),
          reinterpret_cast<char*>(&other->_impl_.start_end_bit_));
}

std::string DependencyDescriptorsWireInfo::GetTypeName() const {
  return "webrtc.rtclog2.DependencyDescriptorsWireInfo";
}

// ===================================================================

class IncomingRtpPackets::_Internal {
 public:
  using HasBits = decltype(std::declval<IncomingRtpPackets>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_marker(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_payload_type(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_sequence_number(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_rtp_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_payload_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_header_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_padding_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_transport_sequence_number(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_transmission_time_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_absolute_send_time(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_video_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_audio_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_voice_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& dependency_descriptor(const IncomingRtpPackets* msg);
  static void set_has_dependency_descriptor(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_marker_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_payload_type_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sequence_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rtp_timestamp_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ssrc_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_payload_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_header_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_padding_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_transport_sequence_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_transmission_time_offset_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_absolute_send_time_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_video_rotation_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_audio_level_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_voice_activity_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& IncomingRtpPackets::_Internal::dependency_descriptor(const IncomingRtpPackets* msg) {
  return *msg->_impl_.dependency_descriptor_;
}
IncomingRtpPackets::IncomingRtpPackets(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.IncomingRtpPackets)
}
inline PROTOBUF_NDEBUG_INLINE IncomingRtpPackets::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        marker_deltas_(arena, from.marker_deltas_),
        payload_type_deltas_(arena, from.payload_type_deltas_),
        sequence_number_deltas_(arena, from.sequence_number_deltas_),
        rtp_timestamp_deltas_(arena, from.rtp_timestamp_deltas_),
        ssrc_deltas_(arena, from.ssrc_deltas_),
        payload_size_deltas_(arena, from.payload_size_deltas_),
        header_size_deltas_(arena, from.header_size_deltas_),
        padding_size_deltas_(arena, from.padding_size_deltas_),
        transport_sequence_number_deltas_(arena, from.transport_sequence_number_deltas_),
        transmission_time_offset_deltas_(arena, from.transmission_time_offset_deltas_),
        absolute_send_time_deltas_(arena, from.absolute_send_time_deltas_),
        video_rotation_deltas_(arena, from.video_rotation_deltas_),
        audio_level_deltas_(arena, from.audio_level_deltas_),
        voice_activity_deltas_(arena, from.voice_activity_deltas_) {}

IncomingRtpPackets::IncomingRtpPackets(
    ::google::protobuf::Arena* arena,
    const IncomingRtpPackets& from)
    : ::google::protobuf::MessageLite(arena) {
  IncomingRtpPackets* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.dependency_descriptor_ = (cached_has_bits & 0x00008000u)
                ? CreateMaybeMessage<::webrtc::rtclog2::DependencyDescriptorsWireInfo>(arena, *from._impl_.dependency_descriptor_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, audio_level_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::audio_level_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.IncomingRtpPackets)
}
inline PROTOBUF_NDEBUG_INLINE IncomingRtpPackets::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        marker_deltas_(arena),
        payload_type_deltas_(arena),
        sequence_number_deltas_(arena),
        rtp_timestamp_deltas_(arena),
        ssrc_deltas_(arena),
        payload_size_deltas_(arena),
        header_size_deltas_(arena),
        padding_size_deltas_(arena),
        transport_sequence_number_deltas_(arena),
        transmission_time_offset_deltas_(arena),
        absolute_send_time_deltas_(arena),
        video_rotation_deltas_(arena),
        audio_level_deltas_(arena),
        voice_activity_deltas_(arena) {}

inline void IncomingRtpPackets::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, dependency_descriptor_),
           0,
           offsetof(Impl_, audio_level_) -
               offsetof(Impl_, dependency_descriptor_) +
               sizeof(Impl_::audio_level_));
}
IncomingRtpPackets::~IncomingRtpPackets() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.IncomingRtpPackets)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void IncomingRtpPackets::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.marker_deltas_.Destroy();
  _impl_.payload_type_deltas_.Destroy();
  _impl_.sequence_number_deltas_.Destroy();
  _impl_.rtp_timestamp_deltas_.Destroy();
  _impl_.ssrc_deltas_.Destroy();
  _impl_.payload_size_deltas_.Destroy();
  _impl_.header_size_deltas_.Destroy();
  _impl_.padding_size_deltas_.Destroy();
  _impl_.transport_sequence_number_deltas_.Destroy();
  _impl_.transmission_time_offset_deltas_.Destroy();
  _impl_.absolute_send_time_deltas_.Destroy();
  _impl_.video_rotation_deltas_.Destroy();
  _impl_.audio_level_deltas_.Destroy();
  _impl_.voice_activity_deltas_.Destroy();
  delete _impl_.dependency_descriptor_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void IncomingRtpPackets::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.IncomingRtpPackets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.marker_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.payload_type_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.sequence_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.rtp_timestamp_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.ssrc_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.payload_size_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.header_size_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.padding_size_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.transport_sequence_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      _impl_.transmission_time_offset_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      _impl_.absolute_send_time_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00001000u) {
      _impl_.video_rotation_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00002000u) {
      _impl_.audio_level_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00004000u) {
      _impl_.voice_activity_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00008000u) {
      ABSL_DCHECK(_impl_.dependency_descriptor_ != nullptr);
      _impl_.dependency_descriptor_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.padding_size_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.padding_size_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.number_of_deltas_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.audio_level_) -
        reinterpret_cast<char*>(&_impl_.number_of_deltas_)) + sizeof(_impl_.audio_level_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IncomingRtpPackets::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 32, 1, 0, 9> IncomingRtpPackets::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_._has_bits_),
    0, // no _extensions_
    120, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4292884544,  // skipmap
    offsetof(decltype(_table_), field_entries),
    32,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_IncomingRtpPackets_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 16, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.timestamp_ms_)}},
    // optional bool marker = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 25, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.marker_)}},
    // optional uint32 payload_type = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 17, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.payload_type_)}},
    // optional uint32 sequence_number = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 18, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.sequence_number_)}},
    // optional fixed32 rtp_timestamp = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 19, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.rtp_timestamp_)}},
    // optional fixed32 ssrc = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 20, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.ssrc_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 payload_size = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 21, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.payload_size_)}},
    // optional uint32 header_size = 9;
    {::_pbi::TcParser::FastV32S1,
     {72, 22, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.header_size_)}},
    // optional uint32 padding_size = 10;
    {::_pbi::TcParser::FastV32S1,
     {80, 23, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.padding_size_)}},
    // optional uint32 number_of_deltas = 11;
    {::_pbi::TcParser::FastV32S1,
     {88, 24, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.number_of_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 transport_sequence_number = 15;
    {::_pbi::TcParser::FastV32S1,
     {120, 27, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.transport_sequence_number_)}},
    // optional int32 transmission_time_offset = 16;
    {::_pbi::TcParser::FastV32S2,
     {384, 28, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.transmission_time_offset_)}},
    // optional uint32 absolute_send_time = 17;
    {::_pbi::TcParser::FastV32S2,
     {392, 29, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.absolute_send_time_)}},
    // optional uint32 video_rotation = 18;
    {::_pbi::TcParser::FastV32S2,
     {400, 30, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.video_rotation_)}},
    // optional uint32 audio_level = 19;
    {::_pbi::TcParser::FastV32S2,
     {408, 31, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.audio_level_)}},
    // optional bool voice_activity = 20;
    {::_pbi::TcParser::FastV8S2,
     {416, 26, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.voice_activity_)}},
    // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
    {::_pbi::TcParser::FastMtS2,
     {426, 15, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.dependency_descriptor_)}},
    // optional bytes marker_deltas = 102;
    {::_pbi::TcParser::FastBS2,
     {1714, 1, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.marker_deltas_)}},
    // optional bytes payload_type_deltas = 103;
    {::_pbi::TcParser::FastBS2,
     {1722, 2, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.payload_type_deltas_)}},
    // optional bytes sequence_number_deltas = 104;
    {::_pbi::TcParser::FastBS2,
     {1730, 3, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.sequence_number_deltas_)}},
    // optional bytes rtp_timestamp_deltas = 105;
    {::_pbi::TcParser::FastBS2,
     {1738, 4, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.rtp_timestamp_deltas_)}},
    // optional bytes ssrc_deltas = 106;
    {::_pbi::TcParser::FastBS2,
     {1746, 5, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.ssrc_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional bytes payload_size_deltas = 108;
    {::_pbi::TcParser::FastBS2,
     {1762, 6, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.payload_size_deltas_)}},
    // optional bytes header_size_deltas = 109;
    {::_pbi::TcParser::FastBS2,
     {1770, 7, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.header_size_deltas_)}},
    // optional bytes padding_size_deltas = 110;
    {::_pbi::TcParser::FastBS2,
     {1778, 8, 0, PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.padding_size_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    101, 0, 2,
    15424, 17, 65520, 28,
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional bool marker = 2;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.marker_), _Internal::kHasBitsOffset + 25, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint32 payload_type = 3;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.payload_type_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 sequence_number = 4;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.sequence_number_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional fixed32 rtp_timestamp = 5;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.rtp_timestamp_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional fixed32 ssrc = 6;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.ssrc_), _Internal::kHasBitsOffset + 20, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional uint32 payload_size = 8;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.payload_size_), _Internal::kHasBitsOffset + 21, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 header_size = 9;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.header_size_), _Internal::kHasBitsOffset + 22, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 padding_size = 10;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.padding_size_), _Internal::kHasBitsOffset + 23, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 number_of_deltas = 11;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 24, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 transport_sequence_number = 15;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.transport_sequence_number_), _Internal::kHasBitsOffset + 27, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional int32 transmission_time_offset = 16;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.transmission_time_offset_), _Internal::kHasBitsOffset + 28, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 absolute_send_time = 17;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.absolute_send_time_), _Internal::kHasBitsOffset + 29, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 video_rotation = 18;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.video_rotation_), _Internal::kHasBitsOffset + 30, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 audio_level = 19;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.audio_level_), _Internal::kHasBitsOffset + 31, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool voice_activity = 20;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.voice_activity_), _Internal::kHasBitsOffset + 26, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.dependency_descriptor_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bytes timestamp_ms_deltas = 101;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes marker_deltas = 102;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.marker_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes payload_type_deltas = 103;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.payload_type_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes sequence_number_deltas = 104;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.sequence_number_deltas_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes rtp_timestamp_deltas = 105;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.rtp_timestamp_deltas_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes ssrc_deltas = 106;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.ssrc_deltas_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes payload_size_deltas = 108;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.payload_size_deltas_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes header_size_deltas = 109;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.header_size_deltas_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes padding_size_deltas = 110;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.padding_size_deltas_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes transport_sequence_number_deltas = 115;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.transport_sequence_number_deltas_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes transmission_time_offset_deltas = 116;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.transmission_time_offset_deltas_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes absolute_send_time_deltas = 117;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.absolute_send_time_deltas_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes video_rotation_deltas = 118;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.video_rotation_deltas_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes audio_level_deltas = 119;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.audio_level_deltas_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes voice_activity_deltas = 120;
    {PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.voice_activity_deltas_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::DependencyDescriptorsWireInfo>()},
  }}, {{
  }},
};

::uint8_t* IncomingRtpPackets::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.IncomingRtpPackets)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional bool marker = 2;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_marker(), target);
  }

  // optional uint32 payload_type = 3;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_payload_type(), target);
  }

  // optional uint32 sequence_number = 4;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_sequence_number(), target);
  }

  // optional fixed32 rtp_timestamp = 5;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        5, this->_internal_rtp_timestamp(), target);
  }

  // optional fixed32 ssrc = 6;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        6, this->_internal_ssrc(), target);
  }

  // optional uint32 payload_size = 8;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_payload_size(), target);
  }

  // optional uint32 header_size = 9;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_header_size(), target);
  }

  // optional uint32 padding_size = 10;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        10, this->_internal_padding_size(), target);
  }

  // optional uint32 number_of_deltas = 11;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        11, this->_internal_number_of_deltas(), target);
  }

  // optional uint32 transport_sequence_number = 15;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        15, this->_internal_transport_sequence_number(), target);
  }

  // optional int32 transmission_time_offset = 16;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        16, this->_internal_transmission_time_offset(), target);
  }

  // optional uint32 absolute_send_time = 17;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        17, this->_internal_absolute_send_time(), target);
  }

  // optional uint32 video_rotation = 18;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        18, this->_internal_video_rotation(), target);
  }

  // optional uint32 audio_level = 19;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        19, this->_internal_audio_level(), target);
  }

  // optional bool voice_activity = 20;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        20, this->_internal_voice_activity(), target);
  }

  // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        21, _Internal::dependency_descriptor(this),
        _Internal::dependency_descriptor(this).GetCachedSize(), target, stream);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(101, _s, target);
  }

  // optional bytes marker_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_marker_deltas();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  // optional bytes payload_type_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_payload_type_deltas();
    target = stream->WriteBytesMaybeAliased(103, _s, target);
  }

  // optional bytes sequence_number_deltas = 104;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_sequence_number_deltas();
    target = stream->WriteBytesMaybeAliased(104, _s, target);
  }

  // optional bytes rtp_timestamp_deltas = 105;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_rtp_timestamp_deltas();
    target = stream->WriteBytesMaybeAliased(105, _s, target);
  }

  // optional bytes ssrc_deltas = 106;
  if (cached_has_bits & 0x00000020u) {
    const std::string& _s = this->_internal_ssrc_deltas();
    target = stream->WriteBytesMaybeAliased(106, _s, target);
  }

  // optional bytes payload_size_deltas = 108;
  if (cached_has_bits & 0x00000040u) {
    const std::string& _s = this->_internal_payload_size_deltas();
    target = stream->WriteBytesMaybeAliased(108, _s, target);
  }

  // optional bytes header_size_deltas = 109;
  if (cached_has_bits & 0x00000080u) {
    const std::string& _s = this->_internal_header_size_deltas();
    target = stream->WriteBytesMaybeAliased(109, _s, target);
  }

  // optional bytes padding_size_deltas = 110;
  if (cached_has_bits & 0x00000100u) {
    const std::string& _s = this->_internal_padding_size_deltas();
    target = stream->WriteBytesMaybeAliased(110, _s, target);
  }

  // optional bytes transport_sequence_number_deltas = 115;
  if (cached_has_bits & 0x00000200u) {
    const std::string& _s = this->_internal_transport_sequence_number_deltas();
    target = stream->WriteBytesMaybeAliased(115, _s, target);
  }

  // optional bytes transmission_time_offset_deltas = 116;
  if (cached_has_bits & 0x00000400u) {
    const std::string& _s = this->_internal_transmission_time_offset_deltas();
    target = stream->WriteBytesMaybeAliased(116, _s, target);
  }

  // optional bytes absolute_send_time_deltas = 117;
  if (cached_has_bits & 0x00000800u) {
    const std::string& _s = this->_internal_absolute_send_time_deltas();
    target = stream->WriteBytesMaybeAliased(117, _s, target);
  }

  // optional bytes video_rotation_deltas = 118;
  if (cached_has_bits & 0x00001000u) {
    const std::string& _s = this->_internal_video_rotation_deltas();
    target = stream->WriteBytesMaybeAliased(118, _s, target);
  }

  // optional bytes audio_level_deltas = 119;
  if (cached_has_bits & 0x00002000u) {
    const std::string& _s = this->_internal_audio_level_deltas();
    target = stream->WriteBytesMaybeAliased(119, _s, target);
  }

  // optional bytes voice_activity_deltas = 120;
  if (cached_has_bits & 0x00004000u) {
    const std::string& _s = this->_internal_voice_activity_deltas();
    target = stream->WriteBytesMaybeAliased(120, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.IncomingRtpPackets)
  return target;
}

::size_t IncomingRtpPackets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.IncomingRtpPackets)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes marker_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_marker_deltas());
    }

    // optional bytes payload_type_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_payload_type_deltas());
    }

    // optional bytes sequence_number_deltas = 104;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_sequence_number_deltas());
    }

    // optional bytes rtp_timestamp_deltas = 105;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_rtp_timestamp_deltas());
    }

    // optional bytes ssrc_deltas = 106;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_ssrc_deltas());
    }

    // optional bytes payload_size_deltas = 108;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_payload_size_deltas());
    }

    // optional bytes header_size_deltas = 109;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_header_size_deltas());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bytes padding_size_deltas = 110;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_padding_size_deltas());
    }

    // optional bytes transport_sequence_number_deltas = 115;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_transport_sequence_number_deltas());
    }

    // optional bytes transmission_time_offset_deltas = 116;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_transmission_time_offset_deltas());
    }

    // optional bytes absolute_send_time_deltas = 117;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_absolute_send_time_deltas());
    }

    // optional bytes video_rotation_deltas = 118;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_video_rotation_deltas());
    }

    // optional bytes audio_level_deltas = 119;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_audio_level_deltas());
    }

    // optional bytes voice_activity_deltas = 120;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_voice_activity_deltas());
    }

    // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
    if (cached_has_bits & 0x00008000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.dependency_descriptor_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 payload_type = 3;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_payload_type());
    }

    // optional uint32 sequence_number = 4;
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_sequence_number());
    }

    // optional fixed32 rtp_timestamp = 5;
    if (cached_has_bits & 0x00080000u) {
      total_size += 5;
    }

    // optional fixed32 ssrc = 6;
    if (cached_has_bits & 0x00100000u) {
      total_size += 5;
    }

    // optional uint32 payload_size = 8;
    if (cached_has_bits & 0x00200000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_payload_size());
    }

    // optional uint32 header_size = 9;
    if (cached_has_bits & 0x00400000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_header_size());
    }

    // optional uint32 padding_size = 10;
    if (cached_has_bits & 0x00800000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_padding_size());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 number_of_deltas = 11;
    if (cached_has_bits & 0x01000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_number_of_deltas());
    }

    // optional bool marker = 2;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2;
    }

    // optional bool voice_activity = 20;
    if (cached_has_bits & 0x04000000u) {
      total_size += 3;
    }

    // optional uint32 transport_sequence_number = 15;
    if (cached_has_bits & 0x08000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_transport_sequence_number());
    }

    // optional int32 transmission_time_offset = 16;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_transmission_time_offset());
    }

    // optional uint32 absolute_send_time = 17;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_absolute_send_time());
    }

    // optional uint32 video_rotation = 18;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_video_rotation());
    }

    // optional uint32 audio_level = 19;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_audio_level());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void IncomingRtpPackets::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IncomingRtpPackets*>(
      &from));
}

void IncomingRtpPackets::MergeFrom(const IncomingRtpPackets& from) {
  IncomingRtpPackets* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.IncomingRtpPackets)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_marker_deltas(from._internal_marker_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_payload_type_deltas(from._internal_payload_type_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_sequence_number_deltas(from._internal_sequence_number_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_rtp_timestamp_deltas(from._internal_rtp_timestamp_deltas());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_ssrc_deltas(from._internal_ssrc_deltas());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_payload_size_deltas(from._internal_payload_size_deltas());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_header_size_deltas(from._internal_header_size_deltas());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_padding_size_deltas(from._internal_padding_size_deltas());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_set_transport_sequence_number_deltas(from._internal_transport_sequence_number_deltas());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_set_transmission_time_offset_deltas(from._internal_transmission_time_offset_deltas());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_set_absolute_send_time_deltas(from._internal_absolute_send_time_deltas());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_set_video_rotation_deltas(from._internal_video_rotation_deltas());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_set_audio_level_deltas(from._internal_audio_level_deltas());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_set_voice_activity_deltas(from._internal_voice_activity_deltas());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_dependency_descriptor()->::webrtc::rtclog2::DependencyDescriptorsWireInfo::MergeFrom(
          from._internal_dependency_descriptor());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.payload_type_ = from._impl_.payload_type_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.sequence_number_ = from._impl_.sequence_number_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.rtp_timestamp_ = from._impl_.rtp_timestamp_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.ssrc_ = from._impl_.ssrc_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.payload_size_ = from._impl_.payload_size_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.header_size_ = from._impl_.header_size_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.padding_size_ = from._impl_.padding_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.marker_ = from._impl_.marker_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.voice_activity_ = from._impl_.voice_activity_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.transport_sequence_number_ = from._impl_.transport_sequence_number_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.transmission_time_offset_ = from._impl_.transmission_time_offset_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.absolute_send_time_ = from._impl_.absolute_send_time_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.video_rotation_ = from._impl_.video_rotation_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.audio_level_ = from._impl_.audio_level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IncomingRtpPackets::CopyFrom(const IncomingRtpPackets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.IncomingRtpPackets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool IncomingRtpPackets::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* IncomingRtpPackets::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void IncomingRtpPackets::InternalSwap(IncomingRtpPackets* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.marker_deltas_, &other->_impl_.marker_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payload_type_deltas_, &other->_impl_.payload_type_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.sequence_number_deltas_, &other->_impl_.sequence_number_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.rtp_timestamp_deltas_, &other->_impl_.rtp_timestamp_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ssrc_deltas_, &other->_impl_.ssrc_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payload_size_deltas_, &other->_impl_.payload_size_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.header_size_deltas_, &other->_impl_.header_size_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.padding_size_deltas_, &other->_impl_.padding_size_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.transport_sequence_number_deltas_, &other->_impl_.transport_sequence_number_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.transmission_time_offset_deltas_, &other->_impl_.transmission_time_offset_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.absolute_send_time_deltas_, &other->_impl_.absolute_send_time_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.video_rotation_deltas_, &other->_impl_.video_rotation_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.audio_level_deltas_, &other->_impl_.audio_level_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.voice_activity_deltas_, &other->_impl_.voice_activity_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.audio_level_)
      + sizeof(IncomingRtpPackets::_impl_.audio_level_)
      - PROTOBUF_FIELD_OFFSET(IncomingRtpPackets, _impl_.dependency_descriptor_)>(
          reinterpret_cast<char*>(&_impl_.dependency_descriptor_),
          reinterpret_cast<char*>(&other->_impl_.dependency_descriptor_));
}

std::string IncomingRtpPackets::GetTypeName() const {
  return "webrtc.rtclog2.IncomingRtpPackets";
}

// ===================================================================

class OutgoingRtpPackets::_Internal {
 public:
  using HasBits = decltype(std::declval<OutgoingRtpPackets>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_marker(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_payload_type(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_sequence_number(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_rtp_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_payload_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_header_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_padding_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_transport_sequence_number(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_transmission_time_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_absolute_send_time(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_video_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_audio_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_voice_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& dependency_descriptor(const OutgoingRtpPackets* msg);
  static void set_has_dependency_descriptor(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_marker_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_payload_type_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sequence_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rtp_timestamp_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ssrc_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_payload_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_header_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_padding_size_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_transport_sequence_number_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_transmission_time_offset_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_absolute_send_time_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_video_rotation_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_audio_level_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_voice_activity_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& OutgoingRtpPackets::_Internal::dependency_descriptor(const OutgoingRtpPackets* msg) {
  return *msg->_impl_.dependency_descriptor_;
}
OutgoingRtpPackets::OutgoingRtpPackets(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.OutgoingRtpPackets)
}
inline PROTOBUF_NDEBUG_INLINE OutgoingRtpPackets::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        marker_deltas_(arena, from.marker_deltas_),
        payload_type_deltas_(arena, from.payload_type_deltas_),
        sequence_number_deltas_(arena, from.sequence_number_deltas_),
        rtp_timestamp_deltas_(arena, from.rtp_timestamp_deltas_),
        ssrc_deltas_(arena, from.ssrc_deltas_),
        payload_size_deltas_(arena, from.payload_size_deltas_),
        header_size_deltas_(arena, from.header_size_deltas_),
        padding_size_deltas_(arena, from.padding_size_deltas_),
        transport_sequence_number_deltas_(arena, from.transport_sequence_number_deltas_),
        transmission_time_offset_deltas_(arena, from.transmission_time_offset_deltas_),
        absolute_send_time_deltas_(arena, from.absolute_send_time_deltas_),
        video_rotation_deltas_(arena, from.video_rotation_deltas_),
        audio_level_deltas_(arena, from.audio_level_deltas_),
        voice_activity_deltas_(arena, from.voice_activity_deltas_) {}

OutgoingRtpPackets::OutgoingRtpPackets(
    ::google::protobuf::Arena* arena,
    const OutgoingRtpPackets& from)
    : ::google::protobuf::MessageLite(arena) {
  OutgoingRtpPackets* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.dependency_descriptor_ = (cached_has_bits & 0x00008000u)
                ? CreateMaybeMessage<::webrtc::rtclog2::DependencyDescriptorsWireInfo>(arena, *from._impl_.dependency_descriptor_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, audio_level_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::audio_level_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.OutgoingRtpPackets)
}
inline PROTOBUF_NDEBUG_INLINE OutgoingRtpPackets::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        marker_deltas_(arena),
        payload_type_deltas_(arena),
        sequence_number_deltas_(arena),
        rtp_timestamp_deltas_(arena),
        ssrc_deltas_(arena),
        payload_size_deltas_(arena),
        header_size_deltas_(arena),
        padding_size_deltas_(arena),
        transport_sequence_number_deltas_(arena),
        transmission_time_offset_deltas_(arena),
        absolute_send_time_deltas_(arena),
        video_rotation_deltas_(arena),
        audio_level_deltas_(arena),
        voice_activity_deltas_(arena) {}

inline void OutgoingRtpPackets::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, dependency_descriptor_),
           0,
           offsetof(Impl_, audio_level_) -
               offsetof(Impl_, dependency_descriptor_) +
               sizeof(Impl_::audio_level_));
}
OutgoingRtpPackets::~OutgoingRtpPackets() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.OutgoingRtpPackets)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void OutgoingRtpPackets::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.marker_deltas_.Destroy();
  _impl_.payload_type_deltas_.Destroy();
  _impl_.sequence_number_deltas_.Destroy();
  _impl_.rtp_timestamp_deltas_.Destroy();
  _impl_.ssrc_deltas_.Destroy();
  _impl_.payload_size_deltas_.Destroy();
  _impl_.header_size_deltas_.Destroy();
  _impl_.padding_size_deltas_.Destroy();
  _impl_.transport_sequence_number_deltas_.Destroy();
  _impl_.transmission_time_offset_deltas_.Destroy();
  _impl_.absolute_send_time_deltas_.Destroy();
  _impl_.video_rotation_deltas_.Destroy();
  _impl_.audio_level_deltas_.Destroy();
  _impl_.voice_activity_deltas_.Destroy();
  delete _impl_.dependency_descriptor_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void OutgoingRtpPackets::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.OutgoingRtpPackets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.marker_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.payload_type_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.sequence_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.rtp_timestamp_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.ssrc_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.payload_size_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.header_size_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _impl_.padding_size_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      _impl_.transport_sequence_number_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000400u) {
      _impl_.transmission_time_offset_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000800u) {
      _impl_.absolute_send_time_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00001000u) {
      _impl_.video_rotation_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00002000u) {
      _impl_.audio_level_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00004000u) {
      _impl_.voice_activity_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00008000u) {
      ABSL_DCHECK(_impl_.dependency_descriptor_ != nullptr);
      _impl_.dependency_descriptor_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.padding_size_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.padding_size_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&_impl_.number_of_deltas_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.audio_level_) -
        reinterpret_cast<char*>(&_impl_.number_of_deltas_)) + sizeof(_impl_.audio_level_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OutgoingRtpPackets::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 32, 1, 0, 9> OutgoingRtpPackets::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_._has_bits_),
    0, // no _extensions_
    120, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4292884544,  // skipmap
    offsetof(decltype(_table_), field_entries),
    32,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_OutgoingRtpPackets_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 16, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.timestamp_ms_)}},
    // optional bool marker = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 25, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.marker_)}},
    // optional uint32 payload_type = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 17, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.payload_type_)}},
    // optional uint32 sequence_number = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 18, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.sequence_number_)}},
    // optional fixed32 rtp_timestamp = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 19, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.rtp_timestamp_)}},
    // optional fixed32 ssrc = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 20, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.ssrc_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 payload_size = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 21, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.payload_size_)}},
    // optional uint32 header_size = 9;
    {::_pbi::TcParser::FastV32S1,
     {72, 22, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.header_size_)}},
    // optional uint32 padding_size = 10;
    {::_pbi::TcParser::FastV32S1,
     {80, 23, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.padding_size_)}},
    // optional uint32 number_of_deltas = 11;
    {::_pbi::TcParser::FastV32S1,
     {88, 24, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.number_of_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 transport_sequence_number = 15;
    {::_pbi::TcParser::FastV32S1,
     {120, 27, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.transport_sequence_number_)}},
    // optional int32 transmission_time_offset = 16;
    {::_pbi::TcParser::FastV32S2,
     {384, 28, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.transmission_time_offset_)}},
    // optional uint32 absolute_send_time = 17;
    {::_pbi::TcParser::FastV32S2,
     {392, 29, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.absolute_send_time_)}},
    // optional uint32 video_rotation = 18;
    {::_pbi::TcParser::FastV32S2,
     {400, 30, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.video_rotation_)}},
    // optional uint32 audio_level = 19;
    {::_pbi::TcParser::FastV32S2,
     {408, 31, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.audio_level_)}},
    // optional bool voice_activity = 20;
    {::_pbi::TcParser::FastV8S2,
     {416, 26, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.voice_activity_)}},
    // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
    {::_pbi::TcParser::FastMtS2,
     {426, 15, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.dependency_descriptor_)}},
    // optional bytes marker_deltas = 102;
    {::_pbi::TcParser::FastBS2,
     {1714, 1, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.marker_deltas_)}},
    // optional bytes payload_type_deltas = 103;
    {::_pbi::TcParser::FastBS2,
     {1722, 2, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.payload_type_deltas_)}},
    // optional bytes sequence_number_deltas = 104;
    {::_pbi::TcParser::FastBS2,
     {1730, 3, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.sequence_number_deltas_)}},
    // optional bytes rtp_timestamp_deltas = 105;
    {::_pbi::TcParser::FastBS2,
     {1738, 4, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.rtp_timestamp_deltas_)}},
    // optional bytes ssrc_deltas = 106;
    {::_pbi::TcParser::FastBS2,
     {1746, 5, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.ssrc_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional bytes payload_size_deltas = 108;
    {::_pbi::TcParser::FastBS2,
     {1762, 6, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.payload_size_deltas_)}},
    // optional bytes header_size_deltas = 109;
    {::_pbi::TcParser::FastBS2,
     {1770, 7, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.header_size_deltas_)}},
    // optional bytes padding_size_deltas = 110;
    {::_pbi::TcParser::FastBS2,
     {1778, 8, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.padding_size_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    101, 0, 2,
    15424, 17, 65520, 28,
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional bool marker = 2;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.marker_), _Internal::kHasBitsOffset + 25, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint32 payload_type = 3;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.payload_type_), _Internal::kHasBitsOffset + 17, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 sequence_number = 4;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.sequence_number_), _Internal::kHasBitsOffset + 18, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional fixed32 rtp_timestamp = 5;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.rtp_timestamp_), _Internal::kHasBitsOffset + 19, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional fixed32 ssrc = 6;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.ssrc_), _Internal::kHasBitsOffset + 20, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional uint32 payload_size = 8;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.payload_size_), _Internal::kHasBitsOffset + 21, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 header_size = 9;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.header_size_), _Internal::kHasBitsOffset + 22, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 padding_size = 10;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.padding_size_), _Internal::kHasBitsOffset + 23, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 number_of_deltas = 11;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 24, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 transport_sequence_number = 15;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.transport_sequence_number_), _Internal::kHasBitsOffset + 27, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional int32 transmission_time_offset = 16;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.transmission_time_offset_), _Internal::kHasBitsOffset + 28, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 absolute_send_time = 17;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.absolute_send_time_), _Internal::kHasBitsOffset + 29, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 video_rotation = 18;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.video_rotation_), _Internal::kHasBitsOffset + 30, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 audio_level = 19;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.audio_level_), _Internal::kHasBitsOffset + 31, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool voice_activity = 20;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.voice_activity_), _Internal::kHasBitsOffset + 26, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.dependency_descriptor_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional bytes timestamp_ms_deltas = 101;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes marker_deltas = 102;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.marker_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes payload_type_deltas = 103;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.payload_type_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes sequence_number_deltas = 104;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.sequence_number_deltas_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes rtp_timestamp_deltas = 105;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.rtp_timestamp_deltas_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes ssrc_deltas = 106;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.ssrc_deltas_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes payload_size_deltas = 108;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.payload_size_deltas_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes header_size_deltas = 109;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.header_size_deltas_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes padding_size_deltas = 110;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.padding_size_deltas_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes transport_sequence_number_deltas = 115;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.transport_sequence_number_deltas_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes transmission_time_offset_deltas = 116;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.transmission_time_offset_deltas_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes absolute_send_time_deltas = 117;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.absolute_send_time_deltas_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes video_rotation_deltas = 118;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.video_rotation_deltas_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes audio_level_deltas = 119;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.audio_level_deltas_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes voice_activity_deltas = 120;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.voice_activity_deltas_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::DependencyDescriptorsWireInfo>()},
  }}, {{
  }},
};

::uint8_t* OutgoingRtpPackets::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.OutgoingRtpPackets)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional bool marker = 2;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_marker(), target);
  }

  // optional uint32 payload_type = 3;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_payload_type(), target);
  }

  // optional uint32 sequence_number = 4;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_sequence_number(), target);
  }

  // optional fixed32 rtp_timestamp = 5;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        5, this->_internal_rtp_timestamp(), target);
  }

  // optional fixed32 ssrc = 6;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        6, this->_internal_ssrc(), target);
  }

  // optional uint32 payload_size = 8;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_payload_size(), target);
  }

  // optional uint32 header_size = 9;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        9, this->_internal_header_size(), target);
  }

  // optional uint32 padding_size = 10;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        10, this->_internal_padding_size(), target);
  }

  // optional uint32 number_of_deltas = 11;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        11, this->_internal_number_of_deltas(), target);
  }

  // optional uint32 transport_sequence_number = 15;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        15, this->_internal_transport_sequence_number(), target);
  }

  // optional int32 transmission_time_offset = 16;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        16, this->_internal_transmission_time_offset(), target);
  }

  // optional uint32 absolute_send_time = 17;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        17, this->_internal_absolute_send_time(), target);
  }

  // optional uint32 video_rotation = 18;
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        18, this->_internal_video_rotation(), target);
  }

  // optional uint32 audio_level = 19;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        19, this->_internal_audio_level(), target);
  }

  // optional bool voice_activity = 20;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        20, this->_internal_voice_activity(), target);
  }

  // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        21, _Internal::dependency_descriptor(this),
        _Internal::dependency_descriptor(this).GetCachedSize(), target, stream);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(101, _s, target);
  }

  // optional bytes marker_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_marker_deltas();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  // optional bytes payload_type_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_payload_type_deltas();
    target = stream->WriteBytesMaybeAliased(103, _s, target);
  }

  // optional bytes sequence_number_deltas = 104;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_sequence_number_deltas();
    target = stream->WriteBytesMaybeAliased(104, _s, target);
  }

  // optional bytes rtp_timestamp_deltas = 105;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_rtp_timestamp_deltas();
    target = stream->WriteBytesMaybeAliased(105, _s, target);
  }

  // optional bytes ssrc_deltas = 106;
  if (cached_has_bits & 0x00000020u) {
    const std::string& _s = this->_internal_ssrc_deltas();
    target = stream->WriteBytesMaybeAliased(106, _s, target);
  }

  // optional bytes payload_size_deltas = 108;
  if (cached_has_bits & 0x00000040u) {
    const std::string& _s = this->_internal_payload_size_deltas();
    target = stream->WriteBytesMaybeAliased(108, _s, target);
  }

  // optional bytes header_size_deltas = 109;
  if (cached_has_bits & 0x00000080u) {
    const std::string& _s = this->_internal_header_size_deltas();
    target = stream->WriteBytesMaybeAliased(109, _s, target);
  }

  // optional bytes padding_size_deltas = 110;
  if (cached_has_bits & 0x00000100u) {
    const std::string& _s = this->_internal_padding_size_deltas();
    target = stream->WriteBytesMaybeAliased(110, _s, target);
  }

  // optional bytes transport_sequence_number_deltas = 115;
  if (cached_has_bits & 0x00000200u) {
    const std::string& _s = this->_internal_transport_sequence_number_deltas();
    target = stream->WriteBytesMaybeAliased(115, _s, target);
  }

  // optional bytes transmission_time_offset_deltas = 116;
  if (cached_has_bits & 0x00000400u) {
    const std::string& _s = this->_internal_transmission_time_offset_deltas();
    target = stream->WriteBytesMaybeAliased(116, _s, target);
  }

  // optional bytes absolute_send_time_deltas = 117;
  if (cached_has_bits & 0x00000800u) {
    const std::string& _s = this->_internal_absolute_send_time_deltas();
    target = stream->WriteBytesMaybeAliased(117, _s, target);
  }

  // optional bytes video_rotation_deltas = 118;
  if (cached_has_bits & 0x00001000u) {
    const std::string& _s = this->_internal_video_rotation_deltas();
    target = stream->WriteBytesMaybeAliased(118, _s, target);
  }

  // optional bytes audio_level_deltas = 119;
  if (cached_has_bits & 0x00002000u) {
    const std::string& _s = this->_internal_audio_level_deltas();
    target = stream->WriteBytesMaybeAliased(119, _s, target);
  }

  // optional bytes voice_activity_deltas = 120;
  if (cached_has_bits & 0x00004000u) {
    const std::string& _s = this->_internal_voice_activity_deltas();
    target = stream->WriteBytesMaybeAliased(120, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.OutgoingRtpPackets)
  return target;
}

::size_t OutgoingRtpPackets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.OutgoingRtpPackets)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes marker_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_marker_deltas());
    }

    // optional bytes payload_type_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_payload_type_deltas());
    }

    // optional bytes sequence_number_deltas = 104;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_sequence_number_deltas());
    }

    // optional bytes rtp_timestamp_deltas = 105;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_rtp_timestamp_deltas());
    }

    // optional bytes ssrc_deltas = 106;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_ssrc_deltas());
    }

    // optional bytes payload_size_deltas = 108;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_payload_size_deltas());
    }

    // optional bytes header_size_deltas = 109;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_header_size_deltas());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bytes padding_size_deltas = 110;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_padding_size_deltas());
    }

    // optional bytes transport_sequence_number_deltas = 115;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_transport_sequence_number_deltas());
    }

    // optional bytes transmission_time_offset_deltas = 116;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_transmission_time_offset_deltas());
    }

    // optional bytes absolute_send_time_deltas = 117;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_absolute_send_time_deltas());
    }

    // optional bytes video_rotation_deltas = 118;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_video_rotation_deltas());
    }

    // optional bytes audio_level_deltas = 119;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_audio_level_deltas());
    }

    // optional bytes voice_activity_deltas = 120;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_voice_activity_deltas());
    }

    // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
    if (cached_has_bits & 0x00008000u) {
      total_size +=
          2 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.dependency_descriptor_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 payload_type = 3;
    if (cached_has_bits & 0x00020000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_payload_type());
    }

    // optional uint32 sequence_number = 4;
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_sequence_number());
    }

    // optional fixed32 rtp_timestamp = 5;
    if (cached_has_bits & 0x00080000u) {
      total_size += 5;
    }

    // optional fixed32 ssrc = 6;
    if (cached_has_bits & 0x00100000u) {
      total_size += 5;
    }

    // optional uint32 payload_size = 8;
    if (cached_has_bits & 0x00200000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_payload_size());
    }

    // optional uint32 header_size = 9;
    if (cached_has_bits & 0x00400000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_header_size());
    }

    // optional uint32 padding_size = 10;
    if (cached_has_bits & 0x00800000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_padding_size());
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional uint32 number_of_deltas = 11;
    if (cached_has_bits & 0x01000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_number_of_deltas());
    }

    // optional bool marker = 2;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2;
    }

    // optional bool voice_activity = 20;
    if (cached_has_bits & 0x04000000u) {
      total_size += 3;
    }

    // optional uint32 transport_sequence_number = 15;
    if (cached_has_bits & 0x08000000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_transport_sequence_number());
    }

    // optional int32 transmission_time_offset = 16;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                      this->_internal_transmission_time_offset());
    }

    // optional uint32 absolute_send_time = 17;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_absolute_send_time());
    }

    // optional uint32 video_rotation = 18;
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_video_rotation());
    }

    // optional uint32 audio_level = 19;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                      this->_internal_audio_level());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void OutgoingRtpPackets::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OutgoingRtpPackets*>(
      &from));
}

void OutgoingRtpPackets::MergeFrom(const OutgoingRtpPackets& from) {
  OutgoingRtpPackets* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.OutgoingRtpPackets)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_marker_deltas(from._internal_marker_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_payload_type_deltas(from._internal_payload_type_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_sequence_number_deltas(from._internal_sequence_number_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_rtp_timestamp_deltas(from._internal_rtp_timestamp_deltas());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_ssrc_deltas(from._internal_ssrc_deltas());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_payload_size_deltas(from._internal_payload_size_deltas());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_header_size_deltas(from._internal_header_size_deltas());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_padding_size_deltas(from._internal_padding_size_deltas());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_set_transport_sequence_number_deltas(from._internal_transport_sequence_number_deltas());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_set_transmission_time_offset_deltas(from._internal_transmission_time_offset_deltas());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_internal_set_absolute_send_time_deltas(from._internal_absolute_send_time_deltas());
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_internal_set_video_rotation_deltas(from._internal_video_rotation_deltas());
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_internal_set_audio_level_deltas(from._internal_audio_level_deltas());
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_internal_set_voice_activity_deltas(from._internal_voice_activity_deltas());
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_internal_mutable_dependency_descriptor()->::webrtc::rtclog2::DependencyDescriptorsWireInfo::MergeFrom(
          from._internal_dependency_descriptor());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.payload_type_ = from._impl_.payload_type_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.sequence_number_ = from._impl_.sequence_number_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.rtp_timestamp_ = from._impl_.rtp_timestamp_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.ssrc_ = from._impl_.ssrc_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.payload_size_ = from._impl_.payload_size_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.header_size_ = from._impl_.header_size_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.padding_size_ = from._impl_.padding_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.marker_ = from._impl_.marker_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.voice_activity_ = from._impl_.voice_activity_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.transport_sequence_number_ = from._impl_.transport_sequence_number_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.transmission_time_offset_ = from._impl_.transmission_time_offset_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.absolute_send_time_ = from._impl_.absolute_send_time_;
    }
    if (cached_has_bits & 0x40000000u) {
      _this->_impl_.video_rotation_ = from._impl_.video_rotation_;
    }
    if (cached_has_bits & 0x80000000u) {
      _this->_impl_.audio_level_ = from._impl_.audio_level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OutgoingRtpPackets::CopyFrom(const OutgoingRtpPackets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.OutgoingRtpPackets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool OutgoingRtpPackets::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* OutgoingRtpPackets::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void OutgoingRtpPackets::InternalSwap(OutgoingRtpPackets* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.marker_deltas_, &other->_impl_.marker_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payload_type_deltas_, &other->_impl_.payload_type_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.sequence_number_deltas_, &other->_impl_.sequence_number_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.rtp_timestamp_deltas_, &other->_impl_.rtp_timestamp_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ssrc_deltas_, &other->_impl_.ssrc_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.payload_size_deltas_, &other->_impl_.payload_size_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.header_size_deltas_, &other->_impl_.header_size_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.padding_size_deltas_, &other->_impl_.padding_size_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.transport_sequence_number_deltas_, &other->_impl_.transport_sequence_number_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.transmission_time_offset_deltas_, &other->_impl_.transmission_time_offset_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.absolute_send_time_deltas_, &other->_impl_.absolute_send_time_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.video_rotation_deltas_, &other->_impl_.video_rotation_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.audio_level_deltas_, &other->_impl_.audio_level_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.voice_activity_deltas_, &other->_impl_.voice_activity_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.audio_level_)
      + sizeof(OutgoingRtpPackets::_impl_.audio_level_)
      - PROTOBUF_FIELD_OFFSET(OutgoingRtpPackets, _impl_.dependency_descriptor_)>(
          reinterpret_cast<char*>(&_impl_.dependency_descriptor_),
          reinterpret_cast<char*>(&other->_impl_.dependency_descriptor_));
}

std::string OutgoingRtpPackets::GetTypeName() const {
  return "webrtc.rtclog2.OutgoingRtpPackets";
}

// ===================================================================

class IncomingRtcpPackets::_Internal {
 public:
  using HasBits = decltype(std::declval<IncomingRtcpPackets>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_raw_packet(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_raw_packet_blobs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IncomingRtcpPackets::IncomingRtcpPackets(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.IncomingRtcpPackets)
}
inline PROTOBUF_NDEBUG_INLINE IncomingRtcpPackets::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        raw_packet_(arena, from.raw_packet_),
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        raw_packet_blobs_(arena, from.raw_packet_blobs_) {}

IncomingRtcpPackets::IncomingRtcpPackets(
    ::google::protobuf::Arena* arena,
    const IncomingRtcpPackets& from)
    : ::google::protobuf::MessageLite(arena) {
  IncomingRtcpPackets* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.IncomingRtcpPackets)
}
inline PROTOBUF_NDEBUG_INLINE IncomingRtcpPackets::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        raw_packet_(arena),
        timestamp_ms_deltas_(arena),
        raw_packet_blobs_(arena) {}

inline void IncomingRtcpPackets::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
IncomingRtcpPackets::~IncomingRtcpPackets() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.IncomingRtcpPackets)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void IncomingRtcpPackets::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.raw_packet_.Destroy();
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.raw_packet_blobs_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void IncomingRtcpPackets::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.IncomingRtcpPackets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.raw_packet_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.raw_packet_blobs_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_deltas_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.number_of_deltas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IncomingRtcpPackets::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 7> IncomingRtcpPackets::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_._has_bits_),
    0, // no _extensions_
    102, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_IncomingRtcpPackets_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.timestamp_ms_)}},
    // optional bytes raw_packet = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.raw_packet_)}},
    // optional uint32 number_of_deltas = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 4, 0, PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.number_of_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional bytes timestamp_ms_deltas = 101;
    {::_pbi::TcParser::FastBS2,
     {1706, 1, 0, PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.timestamp_ms_deltas_)}},
    // optional bytes raw_packet_blobs = 102;
    {::_pbi::TcParser::FastBS2,
     {1714, 2, 0, PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.raw_packet_blobs_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    101, 0, 1,
    65532, 3,
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional bytes raw_packet = 2;
    {PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.raw_packet_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 number_of_deltas = 3;
    {PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 101;
    {PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes raw_packet_blobs = 102;
    {PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.raw_packet_blobs_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* IncomingRtcpPackets::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.IncomingRtcpPackets)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional bytes raw_packet = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_raw_packet();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // optional uint32 number_of_deltas = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(101, _s, target);
  }

  // optional bytes raw_packet_blobs = 102;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_raw_packet_blobs();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.IncomingRtcpPackets)
  return target;
}

::size_t IncomingRtcpPackets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.IncomingRtcpPackets)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes raw_packet = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_raw_packet());
    }

    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes raw_packet_blobs = 102;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_raw_packet_blobs());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 number_of_deltas = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void IncomingRtcpPackets::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IncomingRtcpPackets*>(
      &from));
}

void IncomingRtcpPackets::MergeFrom(const IncomingRtcpPackets& from) {
  IncomingRtcpPackets* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.IncomingRtcpPackets)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_raw_packet(from._internal_raw_packet());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_raw_packet_blobs(from._internal_raw_packet_blobs());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IncomingRtcpPackets::CopyFrom(const IncomingRtcpPackets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.IncomingRtcpPackets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool IncomingRtcpPackets::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* IncomingRtcpPackets::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void IncomingRtcpPackets::InternalSwap(IncomingRtcpPackets* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.raw_packet_, &other->_impl_.raw_packet_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.raw_packet_blobs_, &other->_impl_.raw_packet_blobs_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.number_of_deltas_)
      + sizeof(IncomingRtcpPackets::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(IncomingRtcpPackets, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string IncomingRtcpPackets::GetTypeName() const {
  return "webrtc.rtclog2.IncomingRtcpPackets";
}

// ===================================================================

class OutgoingRtcpPackets::_Internal {
 public:
  using HasBits = decltype(std::declval<OutgoingRtcpPackets>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_raw_packet(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_raw_packet_blobs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

OutgoingRtcpPackets::OutgoingRtcpPackets(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.OutgoingRtcpPackets)
}
inline PROTOBUF_NDEBUG_INLINE OutgoingRtcpPackets::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        raw_packet_(arena, from.raw_packet_),
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        raw_packet_blobs_(arena, from.raw_packet_blobs_) {}

OutgoingRtcpPackets::OutgoingRtcpPackets(
    ::google::protobuf::Arena* arena,
    const OutgoingRtcpPackets& from)
    : ::google::protobuf::MessageLite(arena) {
  OutgoingRtcpPackets* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.OutgoingRtcpPackets)
}
inline PROTOBUF_NDEBUG_INLINE OutgoingRtcpPackets::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        raw_packet_(arena),
        timestamp_ms_deltas_(arena),
        raw_packet_blobs_(arena) {}

inline void OutgoingRtcpPackets::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
OutgoingRtcpPackets::~OutgoingRtcpPackets() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.OutgoingRtcpPackets)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void OutgoingRtcpPackets::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.raw_packet_.Destroy();
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.raw_packet_blobs_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void OutgoingRtcpPackets::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.OutgoingRtcpPackets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.raw_packet_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.raw_packet_blobs_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_deltas_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.number_of_deltas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OutgoingRtcpPackets::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 7> OutgoingRtcpPackets::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_._has_bits_),
    0, // no _extensions_
    102, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_OutgoingRtcpPackets_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.timestamp_ms_)}},
    // optional bytes raw_packet = 2;
    {::_pbi::TcParser::FastBS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.raw_packet_)}},
    // optional uint32 number_of_deltas = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 4, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.number_of_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional bytes timestamp_ms_deltas = 101;
    {::_pbi::TcParser::FastBS2,
     {1706, 1, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.timestamp_ms_deltas_)}},
    // optional bytes raw_packet_blobs = 102;
    {::_pbi::TcParser::FastBS2,
     {1714, 2, 0, PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.raw_packet_blobs_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    101, 0, 1,
    65532, 3,
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional bytes raw_packet = 2;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.raw_packet_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint32 number_of_deltas = 3;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 101;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes raw_packet_blobs = 102;
    {PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.raw_packet_blobs_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* OutgoingRtcpPackets::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.OutgoingRtcpPackets)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional bytes raw_packet = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_raw_packet();
    target = stream->WriteBytesMaybeAliased(2, _s, target);
  }

  // optional uint32 number_of_deltas = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(101, _s, target);
  }

  // optional bytes raw_packet_blobs = 102;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_raw_packet_blobs();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.OutgoingRtcpPackets)
  return target;
}

::size_t OutgoingRtcpPackets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.OutgoingRtcpPackets)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes raw_packet = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_raw_packet());
    }

    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes raw_packet_blobs = 102;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_raw_packet_blobs());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 number_of_deltas = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void OutgoingRtcpPackets::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OutgoingRtcpPackets*>(
      &from));
}

void OutgoingRtcpPackets::MergeFrom(const OutgoingRtcpPackets& from) {
  OutgoingRtcpPackets* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.OutgoingRtcpPackets)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_raw_packet(from._internal_raw_packet());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_raw_packet_blobs(from._internal_raw_packet_blobs());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OutgoingRtcpPackets::CopyFrom(const OutgoingRtcpPackets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.OutgoingRtcpPackets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool OutgoingRtcpPackets::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* OutgoingRtcpPackets::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void OutgoingRtcpPackets::InternalSwap(OutgoingRtcpPackets* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.raw_packet_, &other->_impl_.raw_packet_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.raw_packet_blobs_, &other->_impl_.raw_packet_blobs_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.number_of_deltas_)
      + sizeof(OutgoingRtcpPackets::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(OutgoingRtcpPackets, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string OutgoingRtcpPackets::GetTypeName() const {
  return "webrtc.rtclog2.OutgoingRtcpPackets";
}

// ===================================================================

class AudioPlayoutEvents::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioPlayoutEvents>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_local_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_local_ssrc_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AudioPlayoutEvents::AudioPlayoutEvents(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.AudioPlayoutEvents)
}
inline PROTOBUF_NDEBUG_INLINE AudioPlayoutEvents::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        local_ssrc_deltas_(arena, from.local_ssrc_deltas_) {}

AudioPlayoutEvents::AudioPlayoutEvents(
    ::google::protobuf::Arena* arena,
    const AudioPlayoutEvents& from)
    : ::google::protobuf::MessageLite(arena) {
  AudioPlayoutEvents* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.AudioPlayoutEvents)
}
inline PROTOBUF_NDEBUG_INLINE AudioPlayoutEvents::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        local_ssrc_deltas_(arena) {}

inline void AudioPlayoutEvents::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
AudioPlayoutEvents::~AudioPlayoutEvents() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.AudioPlayoutEvents)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void AudioPlayoutEvents::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.local_ssrc_deltas_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void AudioPlayoutEvents::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.AudioPlayoutEvents)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.local_ssrc_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_deltas_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.number_of_deltas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioPlayoutEvents::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 7> AudioPlayoutEvents::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_._has_bits_),
    0, // no _extensions_
    102, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AudioPlayoutEvents_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.timestamp_ms_)}},
    // optional uint32 local_ssrc = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 3, 0, PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.local_ssrc_)}},
    // optional uint32 number_of_deltas = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 4, 0, PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.number_of_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional bytes timestamp_ms_deltas = 101;
    {::_pbi::TcParser::FastBS2,
     {1706, 0, 0, PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.timestamp_ms_deltas_)}},
    // optional bytes local_ssrc_deltas = 102;
    {::_pbi::TcParser::FastBS2,
     {1714, 1, 0, PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.local_ssrc_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    101, 0, 1,
    65532, 3,
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 local_ssrc = 2;
    {PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.local_ssrc_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 number_of_deltas = 3;
    {PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 101;
    {PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes local_ssrc_deltas = 102;
    {PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.local_ssrc_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AudioPlayoutEvents::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.AudioPlayoutEvents)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 local_ssrc = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_local_ssrc(), target);
  }

  // optional uint32 number_of_deltas = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(101, _s, target);
  }

  // optional bytes local_ssrc_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_local_ssrc_deltas();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.AudioPlayoutEvents)
  return target;
}

::size_t AudioPlayoutEvents::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.AudioPlayoutEvents)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes local_ssrc_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_local_ssrc_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 local_ssrc = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_local_ssrc());
    }

    // optional uint32 number_of_deltas = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void AudioPlayoutEvents::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AudioPlayoutEvents*>(
      &from));
}

void AudioPlayoutEvents::MergeFrom(const AudioPlayoutEvents& from) {
  AudioPlayoutEvents* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.AudioPlayoutEvents)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_local_ssrc_deltas(from._internal_local_ssrc_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.local_ssrc_ = from._impl_.local_ssrc_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioPlayoutEvents::CopyFrom(const AudioPlayoutEvents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.AudioPlayoutEvents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AudioPlayoutEvents::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* AudioPlayoutEvents::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void AudioPlayoutEvents::InternalSwap(AudioPlayoutEvents* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.local_ssrc_deltas_, &other->_impl_.local_ssrc_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.number_of_deltas_)
      + sizeof(AudioPlayoutEvents::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(AudioPlayoutEvents, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string AudioPlayoutEvents::GetTypeName() const {
  return "webrtc.rtclog2.AudioPlayoutEvents";
}

// ===================================================================

class NetEqSetMinimumDelay::_Internal {
 public:
  using HasBits = decltype(std::declval<NetEqSetMinimumDelay>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_remote_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_minimum_delay_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_remote_ssrc_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_minimum_delay_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

NetEqSetMinimumDelay::NetEqSetMinimumDelay(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.NetEqSetMinimumDelay)
}
inline PROTOBUF_NDEBUG_INLINE NetEqSetMinimumDelay::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        remote_ssrc_deltas_(arena, from.remote_ssrc_deltas_),
        minimum_delay_ms_deltas_(arena, from.minimum_delay_ms_deltas_) {}

NetEqSetMinimumDelay::NetEqSetMinimumDelay(
    ::google::protobuf::Arena* arena,
    const NetEqSetMinimumDelay& from)
    : ::google::protobuf::MessageLite(arena) {
  NetEqSetMinimumDelay* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.NetEqSetMinimumDelay)
}
inline PROTOBUF_NDEBUG_INLINE NetEqSetMinimumDelay::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        remote_ssrc_deltas_(arena),
        minimum_delay_ms_deltas_(arena) {}

inline void NetEqSetMinimumDelay::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
NetEqSetMinimumDelay::~NetEqSetMinimumDelay() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.NetEqSetMinimumDelay)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void NetEqSetMinimumDelay::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.remote_ssrc_deltas_.Destroy();
  _impl_.minimum_delay_ms_deltas_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void NetEqSetMinimumDelay::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.NetEqSetMinimumDelay)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.remote_ssrc_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.minimum_delay_ms_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_deltas_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.number_of_deltas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NetEqSetMinimumDelay::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 0, 7> NetEqSetMinimumDelay::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_._has_bits_),
    0, // no _extensions_
    103, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_NetEqSetMinimumDelay_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.timestamp_ms_)}},
    // optional fixed32 remote_ssrc = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 4, 0, PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.remote_ssrc_)}},
    // optional int32 minimum_delay_ms = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 5, 0, PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.minimum_delay_ms_)}},
    // optional uint32 number_of_deltas = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 6, 0, PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.number_of_deltas_)}},
    // optional bytes timestamp_ms_deltas = 101;
    {::_pbi::TcParser::FastBS2,
     {1706, 0, 0, PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.timestamp_ms_deltas_)}},
    // optional bytes remote_ssrc_deltas = 102;
    {::_pbi::TcParser::FastBS2,
     {1714, 1, 0, PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.remote_ssrc_deltas_)}},
    // optional bytes minimum_delay_ms_deltas = 103;
    {::_pbi::TcParser::FastBS2,
     {1722, 2, 0, PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.minimum_delay_ms_deltas_)}},
  }}, {{
    101, 0, 1,
    65528, 4,
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional fixed32 remote_ssrc = 2;
    {PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.remote_ssrc_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional int32 minimum_delay_ms = 3;
    {PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.minimum_delay_ms_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 number_of_deltas = 4;
    {PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 101;
    {PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes remote_ssrc_deltas = 102;
    {PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.remote_ssrc_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes minimum_delay_ms_deltas = 103;
    {PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.minimum_delay_ms_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* NetEqSetMinimumDelay::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.NetEqSetMinimumDelay)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional fixed32 remote_ssrc = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        2, this->_internal_remote_ssrc(), target);
  }

  // optional int32 minimum_delay_ms = 3;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_minimum_delay_ms(), target);
  }

  // optional uint32 number_of_deltas = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(101, _s, target);
  }

  // optional bytes remote_ssrc_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_remote_ssrc_deltas();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  // optional bytes minimum_delay_ms_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_minimum_delay_ms_deltas();
    target = stream->WriteBytesMaybeAliased(103, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.NetEqSetMinimumDelay)
  return target;
}

::size_t NetEqSetMinimumDelay::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.NetEqSetMinimumDelay)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes remote_ssrc_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_remote_ssrc_deltas());
    }

    // optional bytes minimum_delay_ms_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_minimum_delay_ms_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional fixed32 remote_ssrc = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 5;
    }

    // optional int32 minimum_delay_ms = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_minimum_delay_ms());
    }

    // optional uint32 number_of_deltas = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void NetEqSetMinimumDelay::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NetEqSetMinimumDelay*>(
      &from));
}

void NetEqSetMinimumDelay::MergeFrom(const NetEqSetMinimumDelay& from) {
  NetEqSetMinimumDelay* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.NetEqSetMinimumDelay)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_remote_ssrc_deltas(from._internal_remote_ssrc_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_minimum_delay_ms_deltas(from._internal_minimum_delay_ms_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.remote_ssrc_ = from._impl_.remote_ssrc_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.minimum_delay_ms_ = from._impl_.minimum_delay_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetEqSetMinimumDelay::CopyFrom(const NetEqSetMinimumDelay& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.NetEqSetMinimumDelay)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool NetEqSetMinimumDelay::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* NetEqSetMinimumDelay::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void NetEqSetMinimumDelay::InternalSwap(NetEqSetMinimumDelay* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.remote_ssrc_deltas_, &other->_impl_.remote_ssrc_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.minimum_delay_ms_deltas_, &other->_impl_.minimum_delay_ms_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.number_of_deltas_)
      + sizeof(NetEqSetMinimumDelay::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(NetEqSetMinimumDelay, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string NetEqSetMinimumDelay::GetTypeName() const {
  return "webrtc.rtclog2.NetEqSetMinimumDelay";
}

// ===================================================================

class FrameDecodedEvents::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameDecodedEvents>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_render_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_qp(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ssrc_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_render_time_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_width_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_height_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_codec_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_qp_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

FrameDecodedEvents::FrameDecodedEvents(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.FrameDecodedEvents)
}
inline PROTOBUF_NDEBUG_INLINE FrameDecodedEvents::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        ssrc_deltas_(arena, from.ssrc_deltas_),
        render_time_ms_deltas_(arena, from.render_time_ms_deltas_),
        width_deltas_(arena, from.width_deltas_),
        height_deltas_(arena, from.height_deltas_),
        codec_deltas_(arena, from.codec_deltas_),
        qp_deltas_(arena, from.qp_deltas_) {}

FrameDecodedEvents::FrameDecodedEvents(
    ::google::protobuf::Arena* arena,
    const FrameDecodedEvents& from)
    : ::google::protobuf::MessageLite(arena) {
  FrameDecodedEvents* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.FrameDecodedEvents)
}
inline PROTOBUF_NDEBUG_INLINE FrameDecodedEvents::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        ssrc_deltas_(arena),
        render_time_ms_deltas_(arena),
        width_deltas_(arena),
        height_deltas_(arena),
        codec_deltas_(arena),
        qp_deltas_(arena) {}

inline void FrameDecodedEvents::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
FrameDecodedEvents::~FrameDecodedEvents() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.FrameDecodedEvents)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void FrameDecodedEvents::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.ssrc_deltas_.Destroy();
  _impl_.render_time_ms_deltas_.Destroy();
  _impl_.width_deltas_.Destroy();
  _impl_.height_deltas_.Destroy();
  _impl_.codec_deltas_.Destroy();
  _impl_.qp_deltas_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void FrameDecodedEvents::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.FrameDecodedEvents)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.ssrc_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.render_time_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.width_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.height_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.codec_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.qp_deltas_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.timestamp_ms_ = ::int64_t{0};
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.render_time_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_deltas_) -
        reinterpret_cast<char*>(&_impl_.render_time_ms_)) + sizeof(_impl_.number_of_deltas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FrameDecodedEvents::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 15, 1, 0, 7> FrameDecodedEvents::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_._has_bits_),
    0, // no _extensions_
    107, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950784,  // skipmap
    offsetof(decltype(_table_), field_entries),
    15,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_FrameDecodedEvents_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 7, 0, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.timestamp_ms_)}},
    // optional fixed32 ssrc = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 9, 0, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.ssrc_)}},
    // optional int64 render_time_ms = 3;
    {::_pbi::TcParser::FastV64S1,
     {24, 8, 0, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.render_time_ms_)}},
    // optional int32 width = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 10, 0, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.width_)}},
    // optional int32 height = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 11, 0, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.height_)}},
    // optional .webrtc.rtclog2.FrameDecodedEvents.Codec codec = 6;
    {::_pbi::TcParser::FastEr0S1,
     {48, 12, 5, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.codec_)}},
    // optional uint32 qp = 7;
    {::_pbi::TcParser::FastV32S1,
     {56, 13, 0, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.qp_)}},
    // optional bytes width_deltas = 104;
    {::_pbi::TcParser::FastBS2,
     {1730, 3, 0, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.width_deltas_)}},
    // optional bytes height_deltas = 105;
    {::_pbi::TcParser::FastBS2,
     {1738, 4, 0, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.height_deltas_)}},
    // optional bytes codec_deltas = 106;
    {::_pbi::TcParser::FastBS2,
     {1746, 5, 0, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.codec_deltas_)}},
    // optional bytes qp_deltas = 107;
    {::_pbi::TcParser::FastBS2,
     {1754, 6, 0, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.qp_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 number_of_deltas = 15;
    {::_pbi::TcParser::FastV32S1,
     {120, 14, 0, PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.number_of_deltas_)}},
  }}, {{
    101, 0, 1,
    65408, 8,
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional fixed32 ssrc = 2;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.ssrc_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // optional int64 render_time_ms = 3;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.render_time_ms_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int32 width = 4;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.width_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 height = 5;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.height_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional .webrtc.rtclog2.FrameDecodedEvents.Codec codec = 6;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.codec_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional uint32 qp = 7;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.qp_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 number_of_deltas = 15;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 101;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes ssrc_deltas = 102;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.ssrc_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes render_time_ms_deltas = 103;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.render_time_ms_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes width_deltas = 104;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.width_deltas_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes height_deltas = 105;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.height_deltas_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes codec_deltas = 106;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.codec_deltas_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes qp_deltas = 107;
    {PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.qp_deltas_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 6},
  }}, {{
  }},
};

::uint8_t* FrameDecodedEvents::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.FrameDecodedEvents)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional fixed32 ssrc = 2;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        2, this->_internal_ssrc(), target);
  }

  // optional int64 render_time_ms = 3;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<3>(
            stream, this->_internal_render_time_ms(), target);
  }

  // optional int32 width = 4;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_width(), target);
  }

  // optional int32 height = 5;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<5>(
            stream, this->_internal_height(), target);
  }

  // optional .webrtc.rtclog2.FrameDecodedEvents.Codec codec = 6;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_codec(), target);
  }

  // optional uint32 qp = 7;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_qp(), target);
  }

  // optional uint32 number_of_deltas = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        15, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(101, _s, target);
  }

  // optional bytes ssrc_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_ssrc_deltas();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  // optional bytes render_time_ms_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_render_time_ms_deltas();
    target = stream->WriteBytesMaybeAliased(103, _s, target);
  }

  // optional bytes width_deltas = 104;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_width_deltas();
    target = stream->WriteBytesMaybeAliased(104, _s, target);
  }

  // optional bytes height_deltas = 105;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_height_deltas();
    target = stream->WriteBytesMaybeAliased(105, _s, target);
  }

  // optional bytes codec_deltas = 106;
  if (cached_has_bits & 0x00000020u) {
    const std::string& _s = this->_internal_codec_deltas();
    target = stream->WriteBytesMaybeAliased(106, _s, target);
  }

  // optional bytes qp_deltas = 107;
  if (cached_has_bits & 0x00000040u) {
    const std::string& _s = this->_internal_qp_deltas();
    target = stream->WriteBytesMaybeAliased(107, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.FrameDecodedEvents)
  return target;
}

::size_t FrameDecodedEvents::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.FrameDecodedEvents)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes ssrc_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_ssrc_deltas());
    }

    // optional bytes render_time_ms_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_render_time_ms_deltas());
    }

    // optional bytes width_deltas = 104;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_width_deltas());
    }

    // optional bytes height_deltas = 105;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_height_deltas());
    }

    // optional bytes codec_deltas = 106;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_codec_deltas());
    }

    // optional bytes qp_deltas = 107;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_qp_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional int64 render_time_ms = 3;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_render_time_ms());
    }

    // optional fixed32 ssrc = 2;
    if (cached_has_bits & 0x00000200u) {
      total_size += 5;
    }

    // optional int32 width = 4;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_width());
    }

    // optional int32 height = 5;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_height());
    }

    // optional .webrtc.rtclog2.FrameDecodedEvents.Codec codec = 6;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_codec());
    }

    // optional uint32 qp = 7;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_qp());
    }

    // optional uint32 number_of_deltas = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void FrameDecodedEvents::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FrameDecodedEvents*>(
      &from));
}

void FrameDecodedEvents::MergeFrom(const FrameDecodedEvents& from) {
  FrameDecodedEvents* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.FrameDecodedEvents)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_ssrc_deltas(from._internal_ssrc_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_render_time_ms_deltas(from._internal_render_time_ms_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_width_deltas(from._internal_width_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_height_deltas(from._internal_height_deltas());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_codec_deltas(from._internal_codec_deltas());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_qp_deltas(from._internal_qp_deltas());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.render_time_ms_ = from._impl_.render_time_ms_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.ssrc_ = from._impl_.ssrc_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.codec_ = from._impl_.codec_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.qp_ = from._impl_.qp_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FrameDecodedEvents::CopyFrom(const FrameDecodedEvents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.FrameDecodedEvents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool FrameDecodedEvents::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* FrameDecodedEvents::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void FrameDecodedEvents::InternalSwap(FrameDecodedEvents* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.ssrc_deltas_, &other->_impl_.ssrc_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.render_time_ms_deltas_, &other->_impl_.render_time_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.width_deltas_, &other->_impl_.width_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.height_deltas_, &other->_impl_.height_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.codec_deltas_, &other->_impl_.codec_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.qp_deltas_, &other->_impl_.qp_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.number_of_deltas_)
      + sizeof(FrameDecodedEvents::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(FrameDecodedEvents, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string FrameDecodedEvents::GetTypeName() const {
  return "webrtc.rtclog2.FrameDecodedEvents";
}

// ===================================================================

class BeginLogEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<BeginLogEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BeginLogEvent, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_utc_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BeginLogEvent::BeginLogEvent(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.BeginLogEvent)
}
BeginLogEvent::BeginLogEvent(
    ::google::protobuf::Arena* arena, const BeginLogEvent& from)
    : BeginLogEvent(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE BeginLogEvent::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void BeginLogEvent::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, version_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::version_));
}
BeginLogEvent::~BeginLogEvent() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.BeginLogEvent)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void BeginLogEvent::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void BeginLogEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.BeginLogEvent)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.version_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BeginLogEvent::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> BeginLogEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BeginLogEvent, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_BeginLogEvent_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(BeginLogEvent, _impl_.timestamp_ms_)}},
    // optional uint32 version = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(BeginLogEvent, _impl_.version_)}},
    // optional int64 utc_time_ms = 3;
    {::_pbi::TcParser::FastV64S1,
     {24, 1, 0, PROTOBUF_FIELD_OFFSET(BeginLogEvent, _impl_.utc_time_ms_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(BeginLogEvent, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 version = 2;
    {PROTOBUF_FIELD_OFFSET(BeginLogEvent, _impl_.version_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional int64 utc_time_ms = 3;
    {PROTOBUF_FIELD_OFFSET(BeginLogEvent, _impl_.utc_time_ms_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* BeginLogEvent::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.BeginLogEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 version = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_version(), target);
  }

  // optional int64 utc_time_ms = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<3>(
            stream, this->_internal_utc_time_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.BeginLogEvent)
  return target;
}

::size_t BeginLogEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.BeginLogEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional int64 utc_time_ms = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_utc_time_ms());
    }

    // optional uint32 version = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BeginLogEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BeginLogEvent*>(
      &from));
}

void BeginLogEvent::MergeFrom(const BeginLogEvent& from) {
  BeginLogEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.BeginLogEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.utc_time_ms_ = from._impl_.utc_time_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BeginLogEvent::CopyFrom(const BeginLogEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.BeginLogEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BeginLogEvent::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* BeginLogEvent::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void BeginLogEvent::InternalSwap(BeginLogEvent* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BeginLogEvent, _impl_.version_)
      + sizeof(BeginLogEvent::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(BeginLogEvent, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string BeginLogEvent::GetTypeName() const {
  return "webrtc.rtclog2.BeginLogEvent";
}

// ===================================================================

class EndLogEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<EndLogEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EndLogEvent, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EndLogEvent::EndLogEvent(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.EndLogEvent)
}
EndLogEvent::EndLogEvent(
    ::google::protobuf::Arena* arena, const EndLogEvent& from)
    : EndLogEvent(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE EndLogEvent::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void EndLogEvent::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.timestamp_ms_ = {};
}
EndLogEvent::~EndLogEvent() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.EndLogEvent)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void EndLogEvent::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void EndLogEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.EndLogEvent)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EndLogEvent::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> EndLogEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EndLogEvent, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_EndLogEvent_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(EndLogEvent, _impl_.timestamp_ms_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(EndLogEvent, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* EndLogEvent::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.EndLogEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.EndLogEvent)
  return target;
}

::size_t EndLogEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.EndLogEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 timestamp_ms = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_timestamp_ms());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void EndLogEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EndLogEvent*>(
      &from));
}

void EndLogEvent::MergeFrom(const EndLogEvent& from) {
  EndLogEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.EndLogEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_timestamp_ms(from._internal_timestamp_ms());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EndLogEvent::CopyFrom(const EndLogEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.EndLogEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool EndLogEvent::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* EndLogEvent::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void EndLogEvent::InternalSwap(EndLogEvent* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
        swap(_impl_.timestamp_ms_, other->_impl_.timestamp_ms_);
}

std::string EndLogEvent::GetTypeName() const {
  return "webrtc.rtclog2.EndLogEvent";
}

// ===================================================================

class LossBasedBweUpdates::_Internal {
 public:
  using HasBits = decltype(std::declval<LossBasedBweUpdates>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_fraction_loss(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_total_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bitrate_bps_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fraction_loss_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_total_packets_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

LossBasedBweUpdates::LossBasedBweUpdates(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.LossBasedBweUpdates)
}
inline PROTOBUF_NDEBUG_INLINE LossBasedBweUpdates::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        bitrate_bps_deltas_(arena, from.bitrate_bps_deltas_),
        fraction_loss_deltas_(arena, from.fraction_loss_deltas_),
        total_packets_deltas_(arena, from.total_packets_deltas_) {}

LossBasedBweUpdates::LossBasedBweUpdates(
    ::google::protobuf::Arena* arena,
    const LossBasedBweUpdates& from)
    : ::google::protobuf::MessageLite(arena) {
  LossBasedBweUpdates* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.LossBasedBweUpdates)
}
inline PROTOBUF_NDEBUG_INLINE LossBasedBweUpdates::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        bitrate_bps_deltas_(arena),
        fraction_loss_deltas_(arena),
        total_packets_deltas_(arena) {}

inline void LossBasedBweUpdates::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
LossBasedBweUpdates::~LossBasedBweUpdates() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.LossBasedBweUpdates)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void LossBasedBweUpdates::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.bitrate_bps_deltas_.Destroy();
  _impl_.fraction_loss_deltas_.Destroy();
  _impl_.total_packets_deltas_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void LossBasedBweUpdates::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.LossBasedBweUpdates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.bitrate_bps_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.fraction_loss_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.total_packets_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.total_packets_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.total_packets_));
  }
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LossBasedBweUpdates::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 9, 0, 0, 7> LossBasedBweUpdates::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_._has_bits_),
    0, // no _extensions_
    104, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_LossBasedBweUpdates_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional bytes total_packets_deltas = 104;
    {::_pbi::TcParser::FastBS2,
     {1730, 3, 0, PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.total_packets_deltas_)}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 4, 0, PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.timestamp_ms_)}},
    // optional uint32 bitrate_bps = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 5, 0, PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.bitrate_bps_)}},
    // optional uint32 fraction_loss = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 6, 0, PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.fraction_loss_)}},
    // optional uint32 total_packets = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 7, 0, PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.total_packets_)}},
    // optional uint32 number_of_deltas = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 8, 0, PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.number_of_deltas_)}},
    // optional bytes bitrate_bps_deltas = 102;
    {::_pbi::TcParser::FastBS2,
     {1714, 1, 0, PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.bitrate_bps_deltas_)}},
    // optional bytes fraction_loss_deltas = 103;
    {::_pbi::TcParser::FastBS2,
     {1722, 2, 0, PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.fraction_loss_deltas_)}},
  }}, {{
    101, 0, 1,
    65520, 5,
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 bitrate_bps = 2;
    {PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.bitrate_bps_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 fraction_loss = 3;
    {PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.fraction_loss_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 total_packets = 4;
    {PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.total_packets_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 number_of_deltas = 5;
    {PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 101;
    {PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes bitrate_bps_deltas = 102;
    {PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.bitrate_bps_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes fraction_loss_deltas = 103;
    {PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.fraction_loss_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes total_packets_deltas = 104;
    {PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.total_packets_deltas_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* LossBasedBweUpdates::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.LossBasedBweUpdates)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 bitrate_bps = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_bitrate_bps(), target);
  }

  // optional uint32 fraction_loss = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_fraction_loss(), target);
  }

  // optional uint32 total_packets = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_total_packets(), target);
  }

  // optional uint32 number_of_deltas = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(101, _s, target);
  }

  // optional bytes bitrate_bps_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_bitrate_bps_deltas();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  // optional bytes fraction_loss_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_fraction_loss_deltas();
    target = stream->WriteBytesMaybeAliased(103, _s, target);
  }

  // optional bytes total_packets_deltas = 104;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_total_packets_deltas();
    target = stream->WriteBytesMaybeAliased(104, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.LossBasedBweUpdates)
  return target;
}

::size_t LossBasedBweUpdates::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.LossBasedBweUpdates)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes bitrate_bps_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_bitrate_bps_deltas());
    }

    // optional bytes fraction_loss_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_fraction_loss_deltas());
    }

    // optional bytes total_packets_deltas = 104;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_total_packets_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 bitrate_bps = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_bitrate_bps());
    }

    // optional uint32 fraction_loss = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_fraction_loss());
    }

    // optional uint32 total_packets = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_total_packets());
    }

  }
  // optional uint32 number_of_deltas = 5;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_number_of_deltas());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void LossBasedBweUpdates::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const LossBasedBweUpdates*>(
      &from));
}

void LossBasedBweUpdates::MergeFrom(const LossBasedBweUpdates& from) {
  LossBasedBweUpdates* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.LossBasedBweUpdates)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_bitrate_bps_deltas(from._internal_bitrate_bps_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_fraction_loss_deltas(from._internal_fraction_loss_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_total_packets_deltas(from._internal_total_packets_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.bitrate_bps_ = from._impl_.bitrate_bps_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.fraction_loss_ = from._impl_.fraction_loss_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.total_packets_ = from._impl_.total_packets_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_number_of_deltas(from._internal_number_of_deltas());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LossBasedBweUpdates::CopyFrom(const LossBasedBweUpdates& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.LossBasedBweUpdates)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool LossBasedBweUpdates::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* LossBasedBweUpdates::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void LossBasedBweUpdates::InternalSwap(LossBasedBweUpdates* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.bitrate_bps_deltas_, &other->_impl_.bitrate_bps_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.fraction_loss_deltas_, &other->_impl_.fraction_loss_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.total_packets_deltas_, &other->_impl_.total_packets_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.number_of_deltas_)
      + sizeof(LossBasedBweUpdates::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(LossBasedBweUpdates, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string LossBasedBweUpdates::GetTypeName() const {
  return "webrtc.rtclog2.LossBasedBweUpdates";
}

// ===================================================================

class DelayBasedBweUpdates::_Internal {
 public:
  using HasBits = decltype(std::declval<DelayBasedBweUpdates>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_detector_state(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bitrate_bps_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_detector_state_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

DelayBasedBweUpdates::DelayBasedBweUpdates(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.DelayBasedBweUpdates)
}
inline PROTOBUF_NDEBUG_INLINE DelayBasedBweUpdates::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        bitrate_bps_deltas_(arena, from.bitrate_bps_deltas_),
        detector_state_deltas_(arena, from.detector_state_deltas_) {}

DelayBasedBweUpdates::DelayBasedBweUpdates(
    ::google::protobuf::Arena* arena,
    const DelayBasedBweUpdates& from)
    : ::google::protobuf::MessageLite(arena) {
  DelayBasedBweUpdates* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.DelayBasedBweUpdates)
}
inline PROTOBUF_NDEBUG_INLINE DelayBasedBweUpdates::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        bitrate_bps_deltas_(arena),
        detector_state_deltas_(arena) {}

inline void DelayBasedBweUpdates::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
DelayBasedBweUpdates::~DelayBasedBweUpdates() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.DelayBasedBweUpdates)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void DelayBasedBweUpdates::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.bitrate_bps_deltas_.Destroy();
  _impl_.detector_state_deltas_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void DelayBasedBweUpdates::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.DelayBasedBweUpdates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.bitrate_bps_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.detector_state_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_deltas_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.number_of_deltas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DelayBasedBweUpdates::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 1, 0, 7> DelayBasedBweUpdates::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_._has_bits_),
    0, // no _extensions_
    103, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_DelayBasedBweUpdates_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.timestamp_ms_)}},
    // optional uint32 bitrate_bps = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 4, 0, PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.bitrate_bps_)}},
    // optional .webrtc.rtclog2.DelayBasedBweUpdates.DetectorState detector_state = 3;
    {::_pbi::TcParser::FastEr0S1,
     {24, 5, 3, PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.detector_state_)}},
    // optional uint32 number_of_deltas = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 6, 0, PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.number_of_deltas_)}},
    // optional bytes timestamp_ms_deltas = 101;
    {::_pbi::TcParser::FastBS2,
     {1706, 0, 0, PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.timestamp_ms_deltas_)}},
    // optional bytes bitrate_bps_deltas = 102;
    {::_pbi::TcParser::FastBS2,
     {1714, 1, 0, PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.bitrate_bps_deltas_)}},
    // optional bytes detector_state_deltas = 103;
    {::_pbi::TcParser::FastBS2,
     {1722, 2, 0, PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.detector_state_deltas_)}},
  }}, {{
    101, 0, 1,
    65528, 4,
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 bitrate_bps = 2;
    {PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.bitrate_bps_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .webrtc.rtclog2.DelayBasedBweUpdates.DetectorState detector_state = 3;
    {PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.detector_state_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional uint32 number_of_deltas = 4;
    {PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 101;
    {PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes bitrate_bps_deltas = 102;
    {PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.bitrate_bps_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes detector_state_deltas = 103;
    {PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.detector_state_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }}, {{
    {0, 4},
  }}, {{
  }},
};

::uint8_t* DelayBasedBweUpdates::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.DelayBasedBweUpdates)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 bitrate_bps = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_bitrate_bps(), target);
  }

  // optional .webrtc.rtclog2.DelayBasedBweUpdates.DetectorState detector_state = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_detector_state(), target);
  }

  // optional uint32 number_of_deltas = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(101, _s, target);
  }

  // optional bytes bitrate_bps_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_bitrate_bps_deltas();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  // optional bytes detector_state_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_detector_state_deltas();
    target = stream->WriteBytesMaybeAliased(103, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.DelayBasedBweUpdates)
  return target;
}

::size_t DelayBasedBweUpdates::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.DelayBasedBweUpdates)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes bitrate_bps_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_bitrate_bps_deltas());
    }

    // optional bytes detector_state_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_detector_state_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 bitrate_bps = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_bitrate_bps());
    }

    // optional .webrtc.rtclog2.DelayBasedBweUpdates.DetectorState detector_state = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_detector_state());
    }

    // optional uint32 number_of_deltas = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void DelayBasedBweUpdates::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DelayBasedBweUpdates*>(
      &from));
}

void DelayBasedBweUpdates::MergeFrom(const DelayBasedBweUpdates& from) {
  DelayBasedBweUpdates* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.DelayBasedBweUpdates)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_bitrate_bps_deltas(from._internal_bitrate_bps_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_detector_state_deltas(from._internal_detector_state_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.bitrate_bps_ = from._impl_.bitrate_bps_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.detector_state_ = from._impl_.detector_state_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DelayBasedBweUpdates::CopyFrom(const DelayBasedBweUpdates& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.DelayBasedBweUpdates)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DelayBasedBweUpdates::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* DelayBasedBweUpdates::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void DelayBasedBweUpdates::InternalSwap(DelayBasedBweUpdates* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.bitrate_bps_deltas_, &other->_impl_.bitrate_bps_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.detector_state_deltas_, &other->_impl_.detector_state_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.number_of_deltas_)
      + sizeof(DelayBasedBweUpdates::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(DelayBasedBweUpdates, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string DelayBasedBweUpdates::GetTypeName() const {
  return "webrtc.rtclog2.DelayBasedBweUpdates";
}

// ===================================================================

class RtpHeaderExtensionConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<RtpHeaderExtensionConfig>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_._has_bits_);
  static void set_has_transmission_time_offset_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_absolute_send_time_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_transport_sequence_number_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_video_rotation_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_audio_level_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dependency_descriptor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

RtpHeaderExtensionConfig::RtpHeaderExtensionConfig(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.RtpHeaderExtensionConfig)
}
RtpHeaderExtensionConfig::RtpHeaderExtensionConfig(
    ::google::protobuf::Arena* arena, const RtpHeaderExtensionConfig& from)
    : RtpHeaderExtensionConfig(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE RtpHeaderExtensionConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void RtpHeaderExtensionConfig::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, transmission_time_offset_id_),
           0,
           offsetof(Impl_, dependency_descriptor_id_) -
               offsetof(Impl_, transmission_time_offset_id_) +
               sizeof(Impl_::dependency_descriptor_id_));
}
RtpHeaderExtensionConfig::~RtpHeaderExtensionConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.RtpHeaderExtensionConfig)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void RtpHeaderExtensionConfig::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void RtpHeaderExtensionConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.RtpHeaderExtensionConfig)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.transmission_time_offset_id_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.dependency_descriptor_id_) -
        reinterpret_cast<char*>(&_impl_.transmission_time_offset_id_)) + sizeof(_impl_.dependency_descriptor_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RtpHeaderExtensionConfig::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 0, 0, 2> RtpHeaderExtensionConfig::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_RtpHeaderExtensionConfig_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int32 transmission_time_offset_id = 1;
    {::_pbi::TcParser::FastV32S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.transmission_time_offset_id_)}},
    // optional int32 absolute_send_time_id = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.absolute_send_time_id_)}},
    // optional int32 transport_sequence_number_id = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.transport_sequence_number_id_)}},
    // optional int32 video_rotation_id = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.video_rotation_id_)}},
    // optional int32 audio_level_id = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.audio_level_id_)}},
    // optional int32 dependency_descriptor_id = 6;
    {::_pbi::TcParser::FastV32S1,
     {48, 5, 0, PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.dependency_descriptor_id_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 transmission_time_offset_id = 1;
    {PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.transmission_time_offset_id_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 absolute_send_time_id = 2;
    {PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.absolute_send_time_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 transport_sequence_number_id = 3;
    {PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.transport_sequence_number_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 video_rotation_id = 4;
    {PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.video_rotation_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 audio_level_id = 5;
    {PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.audio_level_id_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 dependency_descriptor_id = 6;
    {PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.dependency_descriptor_id_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* RtpHeaderExtensionConfig::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.RtpHeaderExtensionConfig)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 transmission_time_offset_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_transmission_time_offset_id(), target);
  }

  // optional int32 absolute_send_time_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_absolute_send_time_id(), target);
  }

  // optional int32 transport_sequence_number_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_transport_sequence_number_id(), target);
  }

  // optional int32 video_rotation_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_video_rotation_id(), target);
  }

  // optional int32 audio_level_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<5>(
            stream, this->_internal_audio_level_id(), target);
  }

  // optional int32 dependency_descriptor_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<6>(
            stream, this->_internal_dependency_descriptor_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.RtpHeaderExtensionConfig)
  return target;
}

::size_t RtpHeaderExtensionConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.RtpHeaderExtensionConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int32 transmission_time_offset_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_transmission_time_offset_id());
    }

    // optional int32 absolute_send_time_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_absolute_send_time_id());
    }

    // optional int32 transport_sequence_number_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_transport_sequence_number_id());
    }

    // optional int32 video_rotation_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_video_rotation_id());
    }

    // optional int32 audio_level_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_audio_level_id());
    }

    // optional int32 dependency_descriptor_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_dependency_descriptor_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void RtpHeaderExtensionConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RtpHeaderExtensionConfig*>(
      &from));
}

void RtpHeaderExtensionConfig::MergeFrom(const RtpHeaderExtensionConfig& from) {
  RtpHeaderExtensionConfig* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.RtpHeaderExtensionConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.transmission_time_offset_id_ = from._impl_.transmission_time_offset_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.absolute_send_time_id_ = from._impl_.absolute_send_time_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.transport_sequence_number_id_ = from._impl_.transport_sequence_number_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.video_rotation_id_ = from._impl_.video_rotation_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.audio_level_id_ = from._impl_.audio_level_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.dependency_descriptor_id_ = from._impl_.dependency_descriptor_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RtpHeaderExtensionConfig::CopyFrom(const RtpHeaderExtensionConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.RtpHeaderExtensionConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RtpHeaderExtensionConfig::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RtpHeaderExtensionConfig::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RtpHeaderExtensionConfig::InternalSwap(RtpHeaderExtensionConfig* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.dependency_descriptor_id_)
      + sizeof(RtpHeaderExtensionConfig::_impl_.dependency_descriptor_id_)
      - PROTOBUF_FIELD_OFFSET(RtpHeaderExtensionConfig, _impl_.transmission_time_offset_id_)>(
          reinterpret_cast<char*>(&_impl_.transmission_time_offset_id_),
          reinterpret_cast<char*>(&other->_impl_.transmission_time_offset_id_));
}

std::string RtpHeaderExtensionConfig::GetTypeName() const {
  return "webrtc.rtclog2.RtpHeaderExtensionConfig";
}

// ===================================================================

class VideoRecvStreamConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoRecvStreamConfig>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_remote_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_local_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rtx_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions(const VideoRecvStreamConfig* msg);
  static void set_has_header_extensions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::webrtc::rtclog2::RtpHeaderExtensionConfig& VideoRecvStreamConfig::_Internal::header_extensions(const VideoRecvStreamConfig* msg) {
  return *msg->_impl_.header_extensions_;
}
VideoRecvStreamConfig::VideoRecvStreamConfig(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.VideoRecvStreamConfig)
}
inline PROTOBUF_NDEBUG_INLINE VideoRecvStreamConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

VideoRecvStreamConfig::VideoRecvStreamConfig(
    ::google::protobuf::Arena* arena,
    const VideoRecvStreamConfig& from)
    : ::google::protobuf::MessageLite(arena) {
  VideoRecvStreamConfig* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.header_extensions_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::webrtc::rtclog2::RtpHeaderExtensionConfig>(arena, *from._impl_.header_extensions_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, rtx_ssrc_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::rtx_ssrc_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.VideoRecvStreamConfig)
}
inline PROTOBUF_NDEBUG_INLINE VideoRecvStreamConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void VideoRecvStreamConfig::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, header_extensions_),
           0,
           offsetof(Impl_, rtx_ssrc_) -
               offsetof(Impl_, header_extensions_) +
               sizeof(Impl_::rtx_ssrc_));
}
VideoRecvStreamConfig::~VideoRecvStreamConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.VideoRecvStreamConfig)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void VideoRecvStreamConfig::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.header_extensions_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void VideoRecvStreamConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.VideoRecvStreamConfig)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_extensions_ != nullptr);
    _impl_.header_extensions_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.rtx_ssrc_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.rtx_ssrc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VideoRecvStreamConfig::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 0, 2> VideoRecvStreamConfig::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_VideoRecvStreamConfig_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.timestamp_ms_)}},
    // optional uint32 remote_ssrc = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.remote_ssrc_)}},
    // optional uint32 local_ssrc = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.local_ssrc_)}},
    // optional uint32 rtx_ssrc = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 4, 0, PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.rtx_ssrc_)}},
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.header_extensions_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 remote_ssrc = 2;
    {PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.remote_ssrc_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 local_ssrc = 3;
    {PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.local_ssrc_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 rtx_ssrc = 4;
    {PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.rtx_ssrc_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
    {PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.header_extensions_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::RtpHeaderExtensionConfig>()},
  }}, {{
  }},
};

::uint8_t* VideoRecvStreamConfig::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.VideoRecvStreamConfig)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 remote_ssrc = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_remote_ssrc(), target);
  }

  // optional uint32 local_ssrc = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_local_ssrc(), target);
  }

  // optional uint32 rtx_ssrc = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_rtx_ssrc(), target);
  }

  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, _Internal::header_extensions(this),
        _Internal::header_extensions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.VideoRecvStreamConfig)
  return target;
}

::size_t VideoRecvStreamConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.VideoRecvStreamConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.header_extensions_);
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 remote_ssrc = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_remote_ssrc());
    }

    // optional uint32 local_ssrc = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_local_ssrc());
    }

    // optional uint32 rtx_ssrc = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_rtx_ssrc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void VideoRecvStreamConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VideoRecvStreamConfig*>(
      &from));
}

void VideoRecvStreamConfig::MergeFrom(const VideoRecvStreamConfig& from) {
  VideoRecvStreamConfig* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.VideoRecvStreamConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header_extensions()->::webrtc::rtclog2::RtpHeaderExtensionConfig::MergeFrom(
          from._internal_header_extensions());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.remote_ssrc_ = from._impl_.remote_ssrc_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.local_ssrc_ = from._impl_.local_ssrc_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rtx_ssrc_ = from._impl_.rtx_ssrc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VideoRecvStreamConfig::CopyFrom(const VideoRecvStreamConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.VideoRecvStreamConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VideoRecvStreamConfig::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* VideoRecvStreamConfig::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void VideoRecvStreamConfig::InternalSwap(VideoRecvStreamConfig* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.rtx_ssrc_)
      + sizeof(VideoRecvStreamConfig::_impl_.rtx_ssrc_)
      - PROTOBUF_FIELD_OFFSET(VideoRecvStreamConfig, _impl_.header_extensions_)>(
          reinterpret_cast<char*>(&_impl_.header_extensions_),
          reinterpret_cast<char*>(&other->_impl_.header_extensions_));
}

std::string VideoRecvStreamConfig::GetTypeName() const {
  return "webrtc.rtclog2.VideoRecvStreamConfig";
}

// ===================================================================

class VideoSendStreamConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoSendStreamConfig>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rtx_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions(const VideoSendStreamConfig* msg);
  static void set_has_header_extensions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::webrtc::rtclog2::RtpHeaderExtensionConfig& VideoSendStreamConfig::_Internal::header_extensions(const VideoSendStreamConfig* msg) {
  return *msg->_impl_.header_extensions_;
}
VideoSendStreamConfig::VideoSendStreamConfig(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.VideoSendStreamConfig)
}
inline PROTOBUF_NDEBUG_INLINE VideoSendStreamConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

VideoSendStreamConfig::VideoSendStreamConfig(
    ::google::protobuf::Arena* arena,
    const VideoSendStreamConfig& from)
    : ::google::protobuf::MessageLite(arena) {
  VideoSendStreamConfig* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.header_extensions_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::webrtc::rtclog2::RtpHeaderExtensionConfig>(arena, *from._impl_.header_extensions_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, rtx_ssrc_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::rtx_ssrc_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.VideoSendStreamConfig)
}
inline PROTOBUF_NDEBUG_INLINE VideoSendStreamConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void VideoSendStreamConfig::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, header_extensions_),
           0,
           offsetof(Impl_, rtx_ssrc_) -
               offsetof(Impl_, header_extensions_) +
               sizeof(Impl_::rtx_ssrc_));
}
VideoSendStreamConfig::~VideoSendStreamConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.VideoSendStreamConfig)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void VideoSendStreamConfig::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.header_extensions_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void VideoSendStreamConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.VideoSendStreamConfig)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_extensions_ != nullptr);
    _impl_.header_extensions_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.rtx_ssrc_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.rtx_ssrc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VideoSendStreamConfig::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> VideoSendStreamConfig::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_VideoSendStreamConfig_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_.header_extensions_)}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_.timestamp_ms_)}},
    // optional uint32 ssrc = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_.ssrc_)}},
    // optional uint32 rtx_ssrc = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_.rtx_ssrc_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 ssrc = 2;
    {PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_.ssrc_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 rtx_ssrc = 3;
    {PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_.rtx_ssrc_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
    {PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_.header_extensions_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::RtpHeaderExtensionConfig>()},
  }}, {{
  }},
};

::uint8_t* VideoSendStreamConfig::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.VideoSendStreamConfig)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 ssrc = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_ssrc(), target);
  }

  // optional uint32 rtx_ssrc = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_rtx_ssrc(), target);
  }

  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::header_extensions(this),
        _Internal::header_extensions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.VideoSendStreamConfig)
  return target;
}

::size_t VideoSendStreamConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.VideoSendStreamConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.header_extensions_);
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 ssrc = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_ssrc());
    }

    // optional uint32 rtx_ssrc = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_rtx_ssrc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void VideoSendStreamConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VideoSendStreamConfig*>(
      &from));
}

void VideoSendStreamConfig::MergeFrom(const VideoSendStreamConfig& from) {
  VideoSendStreamConfig* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.VideoSendStreamConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header_extensions()->::webrtc::rtclog2::RtpHeaderExtensionConfig::MergeFrom(
          from._internal_header_extensions());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ssrc_ = from._impl_.ssrc_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.rtx_ssrc_ = from._impl_.rtx_ssrc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VideoSendStreamConfig::CopyFrom(const VideoSendStreamConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.VideoSendStreamConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VideoSendStreamConfig::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* VideoSendStreamConfig::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void VideoSendStreamConfig::InternalSwap(VideoSendStreamConfig* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_.rtx_ssrc_)
      + sizeof(VideoSendStreamConfig::_impl_.rtx_ssrc_)
      - PROTOBUF_FIELD_OFFSET(VideoSendStreamConfig, _impl_.header_extensions_)>(
          reinterpret_cast<char*>(&_impl_.header_extensions_),
          reinterpret_cast<char*>(&other->_impl_.header_extensions_));
}

std::string VideoSendStreamConfig::GetTypeName() const {
  return "webrtc.rtclog2.VideoSendStreamConfig";
}

// ===================================================================

class AudioRecvStreamConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioRecvStreamConfig>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_remote_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_local_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions(const AudioRecvStreamConfig* msg);
  static void set_has_header_extensions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::webrtc::rtclog2::RtpHeaderExtensionConfig& AudioRecvStreamConfig::_Internal::header_extensions(const AudioRecvStreamConfig* msg) {
  return *msg->_impl_.header_extensions_;
}
AudioRecvStreamConfig::AudioRecvStreamConfig(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.AudioRecvStreamConfig)
}
inline PROTOBUF_NDEBUG_INLINE AudioRecvStreamConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

AudioRecvStreamConfig::AudioRecvStreamConfig(
    ::google::protobuf::Arena* arena,
    const AudioRecvStreamConfig& from)
    : ::google::protobuf::MessageLite(arena) {
  AudioRecvStreamConfig* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.header_extensions_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::webrtc::rtclog2::RtpHeaderExtensionConfig>(arena, *from._impl_.header_extensions_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, local_ssrc_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::local_ssrc_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.AudioRecvStreamConfig)
}
inline PROTOBUF_NDEBUG_INLINE AudioRecvStreamConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AudioRecvStreamConfig::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, header_extensions_),
           0,
           offsetof(Impl_, local_ssrc_) -
               offsetof(Impl_, header_extensions_) +
               sizeof(Impl_::local_ssrc_));
}
AudioRecvStreamConfig::~AudioRecvStreamConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.AudioRecvStreamConfig)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void AudioRecvStreamConfig::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.header_extensions_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void AudioRecvStreamConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.AudioRecvStreamConfig)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_extensions_ != nullptr);
    _impl_.header_extensions_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.local_ssrc_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.local_ssrc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioRecvStreamConfig::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 1, 0, 2> AudioRecvStreamConfig::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_AudioRecvStreamConfig_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_.timestamp_ms_)}},
    // optional uint32 remote_ssrc = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_.remote_ssrc_)}},
    // optional uint32 local_ssrc = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_.local_ssrc_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_.header_extensions_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 remote_ssrc = 2;
    {PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_.remote_ssrc_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 local_ssrc = 3;
    {PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_.local_ssrc_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
    {PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_.header_extensions_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::RtpHeaderExtensionConfig>()},
  }}, {{
  }},
};

::uint8_t* AudioRecvStreamConfig::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.AudioRecvStreamConfig)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 remote_ssrc = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_remote_ssrc(), target);
  }

  // optional uint32 local_ssrc = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_local_ssrc(), target);
  }

  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, _Internal::header_extensions(this),
        _Internal::header_extensions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.AudioRecvStreamConfig)
  return target;
}

::size_t AudioRecvStreamConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.AudioRecvStreamConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.header_extensions_);
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 remote_ssrc = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_remote_ssrc());
    }

    // optional uint32 local_ssrc = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_local_ssrc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void AudioRecvStreamConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AudioRecvStreamConfig*>(
      &from));
}

void AudioRecvStreamConfig::MergeFrom(const AudioRecvStreamConfig& from) {
  AudioRecvStreamConfig* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.AudioRecvStreamConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header_extensions()->::webrtc::rtclog2::RtpHeaderExtensionConfig::MergeFrom(
          from._internal_header_extensions());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.remote_ssrc_ = from._impl_.remote_ssrc_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.local_ssrc_ = from._impl_.local_ssrc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioRecvStreamConfig::CopyFrom(const AudioRecvStreamConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.AudioRecvStreamConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AudioRecvStreamConfig::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* AudioRecvStreamConfig::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void AudioRecvStreamConfig::InternalSwap(AudioRecvStreamConfig* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_.local_ssrc_)
      + sizeof(AudioRecvStreamConfig::_impl_.local_ssrc_)
      - PROTOBUF_FIELD_OFFSET(AudioRecvStreamConfig, _impl_.header_extensions_)>(
          reinterpret_cast<char*>(&_impl_.header_extensions_),
          reinterpret_cast<char*>(&other->_impl_.header_extensions_));
}

std::string AudioRecvStreamConfig::GetTypeName() const {
  return "webrtc.rtclog2.AudioRecvStreamConfig";
}

// ===================================================================

class AudioSendStreamConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioSendStreamConfig>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ssrc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions(const AudioSendStreamConfig* msg);
  static void set_has_header_extensions(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::webrtc::rtclog2::RtpHeaderExtensionConfig& AudioSendStreamConfig::_Internal::header_extensions(const AudioSendStreamConfig* msg) {
  return *msg->_impl_.header_extensions_;
}
AudioSendStreamConfig::AudioSendStreamConfig(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.AudioSendStreamConfig)
}
inline PROTOBUF_NDEBUG_INLINE AudioSendStreamConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

AudioSendStreamConfig::AudioSendStreamConfig(
    ::google::protobuf::Arena* arena,
    const AudioSendStreamConfig& from)
    : ::google::protobuf::MessageLite(arena) {
  AudioSendStreamConfig* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.header_extensions_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::webrtc::rtclog2::RtpHeaderExtensionConfig>(arena, *from._impl_.header_extensions_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, ssrc_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::ssrc_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.AudioSendStreamConfig)
}
inline PROTOBUF_NDEBUG_INLINE AudioSendStreamConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AudioSendStreamConfig::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, header_extensions_),
           0,
           offsetof(Impl_, ssrc_) -
               offsetof(Impl_, header_extensions_) +
               sizeof(Impl_::ssrc_));
}
AudioSendStreamConfig::~AudioSendStreamConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.AudioSendStreamConfig)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void AudioSendStreamConfig::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.header_extensions_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void AudioSendStreamConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.AudioSendStreamConfig)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_extensions_ != nullptr);
    _impl_.header_extensions_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ssrc_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.ssrc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioSendStreamConfig::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> AudioSendStreamConfig::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967284,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_AudioSendStreamConfig_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, _impl_.header_extensions_)}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, _impl_.timestamp_ms_)}},
    // optional uint32 ssrc = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, _impl_.ssrc_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 ssrc = 2;
    {PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, _impl_.ssrc_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
    {PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, _impl_.header_extensions_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::webrtc::rtclog2::RtpHeaderExtensionConfig>()},
  }}, {{
  }},
};

::uint8_t* AudioSendStreamConfig::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.AudioSendStreamConfig)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 ssrc = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_ssrc(), target);
  }

  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::header_extensions(this),
        _Internal::header_extensions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.AudioSendStreamConfig)
  return target;
}

::size_t AudioSendStreamConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.AudioSendStreamConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.header_extensions_);
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 ssrc = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_ssrc());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void AudioSendStreamConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AudioSendStreamConfig*>(
      &from));
}

void AudioSendStreamConfig::MergeFrom(const AudioSendStreamConfig& from) {
  AudioSendStreamConfig* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.AudioSendStreamConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_header_extensions()->::webrtc::rtclog2::RtpHeaderExtensionConfig::MergeFrom(
          from._internal_header_extensions());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ssrc_ = from._impl_.ssrc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioSendStreamConfig::CopyFrom(const AudioSendStreamConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.AudioSendStreamConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AudioSendStreamConfig::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* AudioSendStreamConfig::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void AudioSendStreamConfig::InternalSwap(AudioSendStreamConfig* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, _impl_.ssrc_)
      + sizeof(AudioSendStreamConfig::_impl_.ssrc_)
      - PROTOBUF_FIELD_OFFSET(AudioSendStreamConfig, _impl_.header_extensions_)>(
          reinterpret_cast<char*>(&_impl_.header_extensions_),
          reinterpret_cast<char*>(&other->_impl_.header_extensions_));
}

std::string AudioSendStreamConfig::GetTypeName() const {
  return "webrtc.rtclog2.AudioSendStreamConfig";
}

// ===================================================================

class AudioNetworkAdaptations::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioNetworkAdaptations>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_frame_length_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_uplink_packet_loss_fraction(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_enable_fec(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_enable_dtx(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_num_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bitrate_bps_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_frame_length_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_uplink_packet_loss_fraction_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_enable_fec_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_enable_dtx_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_channels_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

AudioNetworkAdaptations::AudioNetworkAdaptations(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.AudioNetworkAdaptations)
}
inline PROTOBUF_NDEBUG_INLINE AudioNetworkAdaptations::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        bitrate_bps_deltas_(arena, from.bitrate_bps_deltas_),
        frame_length_ms_deltas_(arena, from.frame_length_ms_deltas_),
        uplink_packet_loss_fraction_deltas_(arena, from.uplink_packet_loss_fraction_deltas_),
        enable_fec_deltas_(arena, from.enable_fec_deltas_),
        enable_dtx_deltas_(arena, from.enable_dtx_deltas_),
        num_channels_deltas_(arena, from.num_channels_deltas_) {}

AudioNetworkAdaptations::AudioNetworkAdaptations(
    ::google::protobuf::Arena* arena,
    const AudioNetworkAdaptations& from)
    : ::google::protobuf::MessageLite(arena) {
  AudioNetworkAdaptations* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.AudioNetworkAdaptations)
}
inline PROTOBUF_NDEBUG_INLINE AudioNetworkAdaptations::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        bitrate_bps_deltas_(arena),
        frame_length_ms_deltas_(arena),
        uplink_packet_loss_fraction_deltas_(arena),
        enable_fec_deltas_(arena),
        enable_dtx_deltas_(arena),
        num_channels_deltas_(arena) {}

inline void AudioNetworkAdaptations::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
AudioNetworkAdaptations::~AudioNetworkAdaptations() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.AudioNetworkAdaptations)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void AudioNetworkAdaptations::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.bitrate_bps_deltas_.Destroy();
  _impl_.frame_length_ms_deltas_.Destroy();
  _impl_.uplink_packet_loss_fraction_deltas_.Destroy();
  _impl_.enable_fec_deltas_.Destroy();
  _impl_.enable_dtx_deltas_.Destroy();
  _impl_.num_channels_deltas_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void AudioNetworkAdaptations::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.AudioNetworkAdaptations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.bitrate_bps_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.frame_length_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.uplink_packet_loss_fraction_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.enable_fec_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.enable_dtx_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.num_channels_deltas_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.timestamp_ms_ = ::int64_t{0};
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.bitrate_bps_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_deltas_) -
        reinterpret_cast<char*>(&_impl_.bitrate_bps_)) + sizeof(_impl_.number_of_deltas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioNetworkAdaptations::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 15, 0, 0, 7> AudioNetworkAdaptations::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_._has_bits_),
    0, // no _extensions_
    107, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    15,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AudioNetworkAdaptations_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 7, 0, PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.timestamp_ms_)}},
    // optional int32 bitrate_bps = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 8, 0, PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.bitrate_bps_)}},
    // optional int32 frame_length_ms = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 9, 0, PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.frame_length_ms_)}},
    // optional uint32 uplink_packet_loss_fraction = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 10, 0, PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.uplink_packet_loss_fraction_)}},
    // optional bool enable_fec = 5;
    {::_pbi::TcParser::FastV8S1,
     {40, 11, 0, PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.enable_fec_)}},
    // optional bool enable_dtx = 6;
    {::_pbi::TcParser::FastV8S1,
     {48, 12, 0, PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.enable_dtx_)}},
    // optional uint32 num_channels = 7;
    {::_pbi::TcParser::FastV32S1,
     {56, 13, 0, PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.num_channels_)}},
    // optional uint32 number_of_deltas = 8;
    {::_pbi::TcParser::FastV32S1,
     {64, 14, 0, PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.number_of_deltas_)}},
    // optional bytes enable_fec_deltas = 105;
    {::_pbi::TcParser::FastBS2,
     {1738, 4, 0, PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.enable_fec_deltas_)}},
    // optional bytes enable_dtx_deltas = 106;
    {::_pbi::TcParser::FastBS2,
     {1746, 5, 0, PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.enable_dtx_deltas_)}},
    // optional bytes num_channels_deltas = 107;
    {::_pbi::TcParser::FastBS2,
     {1754, 6, 0, PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.num_channels_deltas_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    101, 0, 1,
    65408, 8,
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional int32 bitrate_bps = 2;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.bitrate_bps_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional int32 frame_length_ms = 3;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.frame_length_ms_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional uint32 uplink_packet_loss_fraction = 4;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.uplink_packet_loss_fraction_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bool enable_fec = 5;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.enable_fec_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional bool enable_dtx = 6;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.enable_dtx_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint32 num_channels = 7;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.num_channels_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 number_of_deltas = 8;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 101;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes bitrate_bps_deltas = 102;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.bitrate_bps_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes frame_length_ms_deltas = 103;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.frame_length_ms_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes uplink_packet_loss_fraction_deltas = 104;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.uplink_packet_loss_fraction_deltas_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes enable_fec_deltas = 105;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.enable_fec_deltas_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes enable_dtx_deltas = 106;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.enable_dtx_deltas_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes num_channels_deltas = 107;
    {PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.num_channels_deltas_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AudioNetworkAdaptations::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.AudioNetworkAdaptations)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional int32 bitrate_bps = 2;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_bitrate_bps(), target);
  }

  // optional int32 frame_length_ms = 3;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_frame_length_ms(), target);
  }

  // optional uint32 uplink_packet_loss_fraction = 4;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_uplink_packet_loss_fraction(), target);
  }

  // optional bool enable_fec = 5;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_enable_fec(), target);
  }

  // optional bool enable_dtx = 6;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_enable_dtx(), target);
  }

  // optional uint32 num_channels = 7;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        7, this->_internal_num_channels(), target);
  }

  // optional uint32 number_of_deltas = 8;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        8, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(101, _s, target);
  }

  // optional bytes bitrate_bps_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_bitrate_bps_deltas();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  // optional bytes frame_length_ms_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_frame_length_ms_deltas();
    target = stream->WriteBytesMaybeAliased(103, _s, target);
  }

  // optional bytes uplink_packet_loss_fraction_deltas = 104;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_uplink_packet_loss_fraction_deltas();
    target = stream->WriteBytesMaybeAliased(104, _s, target);
  }

  // optional bytes enable_fec_deltas = 105;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_enable_fec_deltas();
    target = stream->WriteBytesMaybeAliased(105, _s, target);
  }

  // optional bytes enable_dtx_deltas = 106;
  if (cached_has_bits & 0x00000020u) {
    const std::string& _s = this->_internal_enable_dtx_deltas();
    target = stream->WriteBytesMaybeAliased(106, _s, target);
  }

  // optional bytes num_channels_deltas = 107;
  if (cached_has_bits & 0x00000040u) {
    const std::string& _s = this->_internal_num_channels_deltas();
    target = stream->WriteBytesMaybeAliased(107, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.AudioNetworkAdaptations)
  return target;
}

::size_t AudioNetworkAdaptations::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.AudioNetworkAdaptations)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes bitrate_bps_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_bitrate_bps_deltas());
    }

    // optional bytes frame_length_ms_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_frame_length_ms_deltas());
    }

    // optional bytes uplink_packet_loss_fraction_deltas = 104;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_uplink_packet_loss_fraction_deltas());
    }

    // optional bytes enable_fec_deltas = 105;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_enable_fec_deltas());
    }

    // optional bytes enable_dtx_deltas = 106;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_enable_dtx_deltas());
    }

    // optional bytes num_channels_deltas = 107;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_num_channels_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional int32 bitrate_bps = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_bitrate_bps());
    }

    // optional int32 frame_length_ms = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_frame_length_ms());
    }

    // optional uint32 uplink_packet_loss_fraction = 4;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_uplink_packet_loss_fraction());
    }

    // optional bool enable_fec = 5;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2;
    }

    // optional bool enable_dtx = 6;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2;
    }

    // optional uint32 num_channels = 7;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_num_channels());
    }

    // optional uint32 number_of_deltas = 8;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void AudioNetworkAdaptations::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AudioNetworkAdaptations*>(
      &from));
}

void AudioNetworkAdaptations::MergeFrom(const AudioNetworkAdaptations& from) {
  AudioNetworkAdaptations* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.AudioNetworkAdaptations)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_bitrate_bps_deltas(from._internal_bitrate_bps_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_frame_length_ms_deltas(from._internal_frame_length_ms_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_uplink_packet_loss_fraction_deltas(from._internal_uplink_packet_loss_fraction_deltas());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_enable_fec_deltas(from._internal_enable_fec_deltas());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_enable_dtx_deltas(from._internal_enable_dtx_deltas());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_num_channels_deltas(from._internal_num_channels_deltas());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.bitrate_bps_ = from._impl_.bitrate_bps_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.frame_length_ms_ = from._impl_.frame_length_ms_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.uplink_packet_loss_fraction_ = from._impl_.uplink_packet_loss_fraction_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.enable_fec_ = from._impl_.enable_fec_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.enable_dtx_ = from._impl_.enable_dtx_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.num_channels_ = from._impl_.num_channels_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioNetworkAdaptations::CopyFrom(const AudioNetworkAdaptations& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.AudioNetworkAdaptations)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AudioNetworkAdaptations::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* AudioNetworkAdaptations::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void AudioNetworkAdaptations::InternalSwap(AudioNetworkAdaptations* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.bitrate_bps_deltas_, &other->_impl_.bitrate_bps_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.frame_length_ms_deltas_, &other->_impl_.frame_length_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.uplink_packet_loss_fraction_deltas_, &other->_impl_.uplink_packet_loss_fraction_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.enable_fec_deltas_, &other->_impl_.enable_fec_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.enable_dtx_deltas_, &other->_impl_.enable_dtx_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.num_channels_deltas_, &other->_impl_.num_channels_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.number_of_deltas_)
      + sizeof(AudioNetworkAdaptations::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(AudioNetworkAdaptations, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string AudioNetworkAdaptations::GetTypeName() const {
  return "webrtc.rtclog2.AudioNetworkAdaptations";
}

// ===================================================================

class BweProbeCluster::_Internal {
 public:
  using HasBits = decltype(std::declval<BweProbeCluster>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_min_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_min_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

BweProbeCluster::BweProbeCluster(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.BweProbeCluster)
}
BweProbeCluster::BweProbeCluster(
    ::google::protobuf::Arena* arena, const BweProbeCluster& from)
    : BweProbeCluster(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE BweProbeCluster::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void BweProbeCluster::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, min_bytes_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::min_bytes_));
}
BweProbeCluster::~BweProbeCluster() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.BweProbeCluster)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void BweProbeCluster::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void BweProbeCluster::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.BweProbeCluster)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.min_bytes_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.min_bytes_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BweProbeCluster::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> BweProbeCluster::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_BweProbeCluster_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.timestamp_ms_)}},
    // optional uint32 id = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.id_)}},
    // optional uint32 bitrate_bps = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.bitrate_bps_)}},
    // optional uint32 min_packets = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.min_packets_)}},
    // optional uint32 min_bytes = 5;
    {::_pbi::TcParser::FastV32S1,
     {40, 4, 0, PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.min_bytes_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 id = 2;
    {PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 bitrate_bps = 3;
    {PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.bitrate_bps_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 min_packets = 4;
    {PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.min_packets_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 min_bytes = 5;
    {PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.min_bytes_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* BweProbeCluster::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.BweProbeCluster)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_id(), target);
  }

  // optional uint32 bitrate_bps = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_bitrate_bps(), target);
  }

  // optional uint32 min_packets = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_min_packets(), target);
  }

  // optional uint32 min_bytes = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_min_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.BweProbeCluster)
  return target;
}

::size_t BweProbeCluster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.BweProbeCluster)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_id());
    }

    // optional uint32 bitrate_bps = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_bitrate_bps());
    }

    // optional uint32 min_packets = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_min_packets());
    }

    // optional uint32 min_bytes = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_min_bytes());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BweProbeCluster::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BweProbeCluster*>(
      &from));
}

void BweProbeCluster::MergeFrom(const BweProbeCluster& from) {
  BweProbeCluster* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.BweProbeCluster)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bitrate_bps_ = from._impl_.bitrate_bps_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.min_packets_ = from._impl_.min_packets_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.min_bytes_ = from._impl_.min_bytes_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BweProbeCluster::CopyFrom(const BweProbeCluster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.BweProbeCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BweProbeCluster::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* BweProbeCluster::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void BweProbeCluster::InternalSwap(BweProbeCluster* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.min_bytes_)
      + sizeof(BweProbeCluster::_impl_.min_bytes_)
      - PROTOBUF_FIELD_OFFSET(BweProbeCluster, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string BweProbeCluster::GetTypeName() const {
  return "webrtc.rtclog2.BweProbeCluster";
}

// ===================================================================

class BweProbeResultSuccess::_Internal {
 public:
  using HasBits = decltype(std::declval<BweProbeResultSuccess>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bitrate_bps(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

BweProbeResultSuccess::BweProbeResultSuccess(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.BweProbeResultSuccess)
}
BweProbeResultSuccess::BweProbeResultSuccess(
    ::google::protobuf::Arena* arena, const BweProbeResultSuccess& from)
    : BweProbeResultSuccess(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE BweProbeResultSuccess::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void BweProbeResultSuccess::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, bitrate_bps_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::bitrate_bps_));
}
BweProbeResultSuccess::~BweProbeResultSuccess() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.BweProbeResultSuccess)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void BweProbeResultSuccess::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void BweProbeResultSuccess::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.BweProbeResultSuccess)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.bitrate_bps_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.bitrate_bps_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BweProbeResultSuccess::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> BweProbeResultSuccess::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_BweProbeResultSuccess_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, _impl_.timestamp_ms_)}},
    // optional uint32 id = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, _impl_.id_)}},
    // optional uint32 bitrate_bps = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, _impl_.bitrate_bps_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 id = 2;
    {PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, _impl_.id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 bitrate_bps = 3;
    {PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, _impl_.bitrate_bps_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* BweProbeResultSuccess::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.BweProbeResultSuccess)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_id(), target);
  }

  // optional uint32 bitrate_bps = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_bitrate_bps(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.BweProbeResultSuccess)
  return target;
}

::size_t BweProbeResultSuccess::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.BweProbeResultSuccess)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_id());
    }

    // optional uint32 bitrate_bps = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_bitrate_bps());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BweProbeResultSuccess::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BweProbeResultSuccess*>(
      &from));
}

void BweProbeResultSuccess::MergeFrom(const BweProbeResultSuccess& from) {
  BweProbeResultSuccess* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.BweProbeResultSuccess)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bitrate_bps_ = from._impl_.bitrate_bps_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BweProbeResultSuccess::CopyFrom(const BweProbeResultSuccess& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.BweProbeResultSuccess)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BweProbeResultSuccess::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* BweProbeResultSuccess::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void BweProbeResultSuccess::InternalSwap(BweProbeResultSuccess* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, _impl_.bitrate_bps_)
      + sizeof(BweProbeResultSuccess::_impl_.bitrate_bps_)
      - PROTOBUF_FIELD_OFFSET(BweProbeResultSuccess, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string BweProbeResultSuccess::GetTypeName() const {
  return "webrtc.rtclog2.BweProbeResultSuccess";
}

// ===================================================================

class BweProbeResultFailure::_Internal {
 public:
  using HasBits = decltype(std::declval<BweProbeResultFailure>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_failure(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

BweProbeResultFailure::BweProbeResultFailure(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.BweProbeResultFailure)
}
BweProbeResultFailure::BweProbeResultFailure(
    ::google::protobuf::Arena* arena, const BweProbeResultFailure& from)
    : BweProbeResultFailure(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE BweProbeResultFailure::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void BweProbeResultFailure::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, failure_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::failure_));
}
BweProbeResultFailure::~BweProbeResultFailure() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.BweProbeResultFailure)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void BweProbeResultFailure::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void BweProbeResultFailure::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.BweProbeResultFailure)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.failure_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.failure_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BweProbeResultFailure::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> BweProbeResultFailure::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_BweProbeResultFailure_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, _impl_.timestamp_ms_)}},
    // optional uint32 id = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, _impl_.id_)}},
    // optional .webrtc.rtclog2.BweProbeResultFailure.FailureReason failure = 3;
    {::_pbi::TcParser::FastEr0S1,
     {24, 2, 3, PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, _impl_.failure_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 id = 2;
    {PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, _impl_.id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .webrtc.rtclog2.BweProbeResultFailure.FailureReason failure = 3;
    {PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, _impl_.failure_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }}, {{
    {0, 4},
  }}, {{
  }},
};

::uint8_t* BweProbeResultFailure::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.BweProbeResultFailure)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_id(), target);
  }

  // optional .webrtc.rtclog2.BweProbeResultFailure.FailureReason failure = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_failure(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.BweProbeResultFailure)
  return target;
}

::size_t BweProbeResultFailure::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.BweProbeResultFailure)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_id());
    }

    // optional .webrtc.rtclog2.BweProbeResultFailure.FailureReason failure = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_failure());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void BweProbeResultFailure::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BweProbeResultFailure*>(
      &from));
}

void BweProbeResultFailure::MergeFrom(const BweProbeResultFailure& from) {
  BweProbeResultFailure* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.BweProbeResultFailure)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.failure_ = from._impl_.failure_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BweProbeResultFailure::CopyFrom(const BweProbeResultFailure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.BweProbeResultFailure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BweProbeResultFailure::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* BweProbeResultFailure::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void BweProbeResultFailure::InternalSwap(BweProbeResultFailure* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, _impl_.failure_)
      + sizeof(BweProbeResultFailure::_impl_.failure_)
      - PROTOBUF_FIELD_OFFSET(BweProbeResultFailure, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string BweProbeResultFailure::GetTypeName() const {
  return "webrtc.rtclog2.BweProbeResultFailure";
}

// ===================================================================

class AlrState::_Internal {
 public:
  using HasBits = decltype(std::declval<AlrState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AlrState, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_in_alr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AlrState::AlrState(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.AlrState)
}
AlrState::AlrState(
    ::google::protobuf::Arena* arena, const AlrState& from)
    : AlrState(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE AlrState::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AlrState::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, in_alr_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::in_alr_));
}
AlrState::~AlrState() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.AlrState)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void AlrState::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void AlrState::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.AlrState)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.in_alr_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.in_alr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AlrState::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> AlrState::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AlrState, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AlrState_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional bool in_alr = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(AlrState, _impl_.in_alr_)}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(AlrState, _impl_.timestamp_ms_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(AlrState, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional bool in_alr = 2;
    {PROTOBUF_FIELD_OFFSET(AlrState, _impl_.in_alr_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AlrState::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.AlrState)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional bool in_alr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_in_alr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.AlrState)
  return target;
}

::size_t AlrState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.AlrState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional bool in_alr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void AlrState::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AlrState*>(
      &from));
}

void AlrState::MergeFrom(const AlrState& from) {
  AlrState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.AlrState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.in_alr_ = from._impl_.in_alr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AlrState::CopyFrom(const AlrState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.AlrState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AlrState::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* AlrState::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void AlrState::InternalSwap(AlrState* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AlrState, _impl_.in_alr_)
      + sizeof(AlrState::_impl_.in_alr_)
      - PROTOBUF_FIELD_OFFSET(AlrState, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string AlrState::GetTypeName() const {
  return "webrtc.rtclog2.AlrState";
}

// ===================================================================

class IceCandidatePairConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<IceCandidatePairConfig>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_config_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_candidate_pair_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_local_candidate_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_local_relay_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_local_network_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_local_address_family(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_remote_candidate_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_remote_address_family(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_candidate_pair_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

IceCandidatePairConfig::IceCandidatePairConfig(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.IceCandidatePairConfig)
}
IceCandidatePairConfig::IceCandidatePairConfig(
    ::google::protobuf::Arena* arena, const IceCandidatePairConfig& from)
    : IceCandidatePairConfig(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE IceCandidatePairConfig::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void IceCandidatePairConfig::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, candidate_pair_protocol_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::candidate_pair_protocol_));
}
IceCandidatePairConfig::~IceCandidatePairConfig() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.IceCandidatePairConfig)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void IceCandidatePairConfig::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void IceCandidatePairConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.IceCandidatePairConfig)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.remote_candidate_type_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.remote_candidate_type_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.remote_address_family_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.candidate_pair_protocol_) -
        reinterpret_cast<char*>(&_impl_.remote_address_family_)) + sizeof(_impl_.candidate_pair_protocol_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IceCandidatePairConfig::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 8, 0, 2> IceCandidatePairConfig::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_._has_bits_),
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    8,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_IceCandidatePairConfig_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.timestamp_ms_)}},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidatePairConfigType config_type = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 1, 4, PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.config_type_)}},
    // optional uint32 candidate_pair_id = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.candidate_pair_id_)}},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType local_candidate_type = 4;
    {::_pbi::TcParser::FastEr0S1,
     {32, 3, 4, PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.local_candidate_type_)}},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol local_relay_protocol = 5;
    {::_pbi::TcParser::FastEr0S1,
     {40, 4, 4, PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.local_relay_protocol_)}},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.NetworkType local_network_type = 6;
    {::_pbi::TcParser::FastEr0S1,
     {48, 5, 5, PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.local_network_type_)}},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily local_address_family = 7;
    {::_pbi::TcParser::FastEr0S1,
     {56, 6, 2, PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.local_address_family_)}},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType remote_candidate_type = 8;
    {::_pbi::TcParser::FastEr0S1,
     {64, 7, 4, PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.remote_candidate_type_)}},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily remote_address_family = 9;
    {::_pbi::TcParser::FastEr0S1,
     {72, 8, 2, PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.remote_address_family_)}},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol candidate_pair_protocol = 10;
    {::_pbi::TcParser::FastEr0S1,
     {80, 9, 4, PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.candidate_pair_protocol_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidatePairConfigType config_type = 2;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.config_type_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional uint32 candidate_pair_id = 3;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.candidate_pair_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType local_candidate_type = 4;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.local_candidate_type_), _Internal::kHasBitsOffset + 3, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol local_relay_protocol = 5;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.local_relay_protocol_), _Internal::kHasBitsOffset + 4, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.NetworkType local_network_type = 6;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.local_network_type_), _Internal::kHasBitsOffset + 5, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily local_address_family = 7;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.local_address_family_), _Internal::kHasBitsOffset + 6, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType remote_candidate_type = 8;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.remote_candidate_type_), _Internal::kHasBitsOffset + 7, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily remote_address_family = 9;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.remote_address_family_), _Internal::kHasBitsOffset + 8, 6,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol candidate_pair_protocol = 10;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.candidate_pair_protocol_), _Internal::kHasBitsOffset + 9, 7,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }}, {{
    {0, 5},
    {0, 5},
    {0, 5},
    {0, 6},
    {0, 3},
    {0, 5},
    {0, 3},
    {0, 5},
  }}, {{
  }},
};

::uint8_t* IceCandidatePairConfig::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.IceCandidatePairConfig)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidatePairConfigType config_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_config_type(), target);
  }

  // optional uint32 candidate_pair_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_candidate_pair_id(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType local_candidate_type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_local_candidate_type(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol local_relay_protocol = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_local_relay_protocol(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.NetworkType local_network_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_local_network_type(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily local_address_family = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_local_address_family(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType remote_candidate_type = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        8, this->_internal_remote_candidate_type(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily remote_address_family = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        9, this->_internal_remote_address_family(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol candidate_pair_protocol = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        10, this->_internal_candidate_pair_protocol(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.IceCandidatePairConfig)
  return target;
}

::size_t IceCandidatePairConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.IceCandidatePairConfig)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidatePairConfigType config_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_config_type());
    }

    // optional uint32 candidate_pair_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_candidate_pair_id());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType local_candidate_type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_local_candidate_type());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol local_relay_protocol = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_local_relay_protocol());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.NetworkType local_network_type = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_local_network_type());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily local_address_family = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_local_address_family());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType remote_candidate_type = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_remote_candidate_type());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily remote_address_family = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_remote_address_family());
    }

    // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol candidate_pair_protocol = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_candidate_pair_protocol());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void IceCandidatePairConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IceCandidatePairConfig*>(
      &from));
}

void IceCandidatePairConfig::MergeFrom(const IceCandidatePairConfig& from) {
  IceCandidatePairConfig* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.IceCandidatePairConfig)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.config_type_ = from._impl_.config_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.candidate_pair_id_ = from._impl_.candidate_pair_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.local_candidate_type_ = from._impl_.local_candidate_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.local_relay_protocol_ = from._impl_.local_relay_protocol_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.local_network_type_ = from._impl_.local_network_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.local_address_family_ = from._impl_.local_address_family_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.remote_candidate_type_ = from._impl_.remote_candidate_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.remote_address_family_ = from._impl_.remote_address_family_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.candidate_pair_protocol_ = from._impl_.candidate_pair_protocol_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IceCandidatePairConfig::CopyFrom(const IceCandidatePairConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.IceCandidatePairConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool IceCandidatePairConfig::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* IceCandidatePairConfig::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void IceCandidatePairConfig::InternalSwap(IceCandidatePairConfig* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.candidate_pair_protocol_)
      + sizeof(IceCandidatePairConfig::_impl_.candidate_pair_protocol_)
      - PROTOBUF_FIELD_OFFSET(IceCandidatePairConfig, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string IceCandidatePairConfig::GetTypeName() const {
  return "webrtc.rtclog2.IceCandidatePairConfig";
}

// ===================================================================

class IceCandidatePairEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<IceCandidatePairEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_candidate_pair_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_transaction_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

IceCandidatePairEvent::IceCandidatePairEvent(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.IceCandidatePairEvent)
}
IceCandidatePairEvent::IceCandidatePairEvent(
    ::google::protobuf::Arena* arena, const IceCandidatePairEvent& from)
    : IceCandidatePairEvent(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE IceCandidatePairEvent::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void IceCandidatePairEvent::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, transaction_id_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::transaction_id_));
}
IceCandidatePairEvent::~IceCandidatePairEvent() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.IceCandidatePairEvent)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void IceCandidatePairEvent::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void IceCandidatePairEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.IceCandidatePairEvent)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.transaction_id_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.transaction_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IceCandidatePairEvent::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> IceCandidatePairEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_IceCandidatePairEvent_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional uint32 transaction_id = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_.transaction_id_)}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_.timestamp_ms_)}},
    // optional .webrtc.rtclog2.IceCandidatePairEvent.IceCandidatePairEventType event_type = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 1, 4, PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_.event_type_)}},
    // optional uint32 candidate_pair_id = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_.candidate_pair_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional .webrtc.rtclog2.IceCandidatePairEvent.IceCandidatePairEventType event_type = 2;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_.event_type_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
    // optional uint32 candidate_pair_id = 3;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_.candidate_pair_id_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 transaction_id = 4;
    {PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_.transaction_id_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }}, {{
    {0, 5},
  }}, {{
  }},
};

::uint8_t* IceCandidatePairEvent::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.IceCandidatePairEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional .webrtc.rtclog2.IceCandidatePairEvent.IceCandidatePairEventType event_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_event_type(), target);
  }

  // optional uint32 candidate_pair_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_candidate_pair_id(), target);
  }

  // optional uint32 transaction_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_transaction_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.IceCandidatePairEvent)
  return target;
}

::size_t IceCandidatePairEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.IceCandidatePairEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional .webrtc.rtclog2.IceCandidatePairEvent.IceCandidatePairEventType event_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_event_type());
    }

    // optional uint32 candidate_pair_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_candidate_pair_id());
    }

    // optional uint32 transaction_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_transaction_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void IceCandidatePairEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IceCandidatePairEvent*>(
      &from));
}

void IceCandidatePairEvent::MergeFrom(const IceCandidatePairEvent& from) {
  IceCandidatePairEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.IceCandidatePairEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.event_type_ = from._impl_.event_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.candidate_pair_id_ = from._impl_.candidate_pair_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.transaction_id_ = from._impl_.transaction_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IceCandidatePairEvent::CopyFrom(const IceCandidatePairEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.IceCandidatePairEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool IceCandidatePairEvent::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* IceCandidatePairEvent::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void IceCandidatePairEvent::InternalSwap(IceCandidatePairEvent* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_.transaction_id_)
      + sizeof(IceCandidatePairEvent::_impl_.transaction_id_)
      - PROTOBUF_FIELD_OFFSET(IceCandidatePairEvent, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string IceCandidatePairEvent::GetTypeName() const {
  return "webrtc.rtclog2.IceCandidatePairEvent";
}

// ===================================================================

class DtlsTransportStateEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<DtlsTransportStateEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DtlsTransportStateEvent, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dtls_transport_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DtlsTransportStateEvent::DtlsTransportStateEvent(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.DtlsTransportStateEvent)
}
DtlsTransportStateEvent::DtlsTransportStateEvent(
    ::google::protobuf::Arena* arena, const DtlsTransportStateEvent& from)
    : DtlsTransportStateEvent(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE DtlsTransportStateEvent::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void DtlsTransportStateEvent::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, dtls_transport_state_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::dtls_transport_state_));
}
DtlsTransportStateEvent::~DtlsTransportStateEvent() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.DtlsTransportStateEvent)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void DtlsTransportStateEvent::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void DtlsTransportStateEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.DtlsTransportStateEvent)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.dtls_transport_state_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.dtls_transport_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DtlsTransportStateEvent::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> DtlsTransportStateEvent::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DtlsTransportStateEvent, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_DtlsTransportStateEvent_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional .webrtc.rtclog2.DtlsTransportStateEvent.DtlsTransportState dtls_transport_state = 2;
    {::_pbi::TcParser::FastEr0S1,
     {16, 1, 5, PROTOBUF_FIELD_OFFSET(DtlsTransportStateEvent, _impl_.dtls_transport_state_)}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(DtlsTransportStateEvent, _impl_.timestamp_ms_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(DtlsTransportStateEvent, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional .webrtc.rtclog2.DtlsTransportStateEvent.DtlsTransportState dtls_transport_state = 2;
    {PROTOBUF_FIELD_OFFSET(DtlsTransportStateEvent, _impl_.dtls_transport_state_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kEnumRange)},
  }}, {{
    {0, 6},
  }}, {{
  }},
};

::uint8_t* DtlsTransportStateEvent::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.DtlsTransportStateEvent)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional .webrtc.rtclog2.DtlsTransportStateEvent.DtlsTransportState dtls_transport_state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_dtls_transport_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.DtlsTransportStateEvent)
  return target;
}

::size_t DtlsTransportStateEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.DtlsTransportStateEvent)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional .webrtc.rtclog2.DtlsTransportStateEvent.DtlsTransportState dtls_transport_state = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_dtls_transport_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void DtlsTransportStateEvent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DtlsTransportStateEvent*>(
      &from));
}

void DtlsTransportStateEvent::MergeFrom(const DtlsTransportStateEvent& from) {
  DtlsTransportStateEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.DtlsTransportStateEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dtls_transport_state_ = from._impl_.dtls_transport_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DtlsTransportStateEvent::CopyFrom(const DtlsTransportStateEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.DtlsTransportStateEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DtlsTransportStateEvent::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* DtlsTransportStateEvent::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void DtlsTransportStateEvent::InternalSwap(DtlsTransportStateEvent* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DtlsTransportStateEvent, _impl_.dtls_transport_state_)
      + sizeof(DtlsTransportStateEvent::_impl_.dtls_transport_state_)
      - PROTOBUF_FIELD_OFFSET(DtlsTransportStateEvent, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string DtlsTransportStateEvent::GetTypeName() const {
  return "webrtc.rtclog2.DtlsTransportStateEvent";
}

// ===================================================================

class DtlsWritableState::_Internal {
 public:
  using HasBits = decltype(std::declval<DtlsWritableState>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DtlsWritableState, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_writable(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DtlsWritableState::DtlsWritableState(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.DtlsWritableState)
}
DtlsWritableState::DtlsWritableState(
    ::google::protobuf::Arena* arena, const DtlsWritableState& from)
    : DtlsWritableState(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE DtlsWritableState::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void DtlsWritableState::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, writable_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::writable_));
}
DtlsWritableState::~DtlsWritableState() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.DtlsWritableState)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void DtlsWritableState::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void DtlsWritableState::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.DtlsWritableState)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.writable_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.writable_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DtlsWritableState::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> DtlsWritableState::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DtlsWritableState, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_DtlsWritableState_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    // optional bool writable = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(DtlsWritableState, _impl_.writable_)}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(DtlsWritableState, _impl_.timestamp_ms_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(DtlsWritableState, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional bool writable = 2;
    {PROTOBUF_FIELD_OFFSET(DtlsWritableState, _impl_.writable_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* DtlsWritableState::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.DtlsWritableState)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional bool writable = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_writable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.DtlsWritableState)
  return target;
}

::size_t DtlsWritableState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.DtlsWritableState)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional bool writable = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void DtlsWritableState::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DtlsWritableState*>(
      &from));
}

void DtlsWritableState::MergeFrom(const DtlsWritableState& from) {
  DtlsWritableState* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.DtlsWritableState)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.writable_ = from._impl_.writable_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DtlsWritableState::CopyFrom(const DtlsWritableState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.DtlsWritableState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DtlsWritableState::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* DtlsWritableState::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void DtlsWritableState::InternalSwap(DtlsWritableState* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DtlsWritableState, _impl_.writable_)
      + sizeof(DtlsWritableState::_impl_.writable_)
      - PROTOBUF_FIELD_OFFSET(DtlsWritableState, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string DtlsWritableState::GetTypeName() const {
  return "webrtc.rtclog2.DtlsWritableState";
}

// ===================================================================

class RouteChange::_Internal {
 public:
  using HasBits = decltype(std::declval<RouteChange>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RouteChange, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_overhead(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

RouteChange::RouteChange(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.RouteChange)
}
RouteChange::RouteChange(
    ::google::protobuf::Arena* arena, const RouteChange& from)
    : RouteChange(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE RouteChange::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void RouteChange::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, overhead_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::overhead_));
}
RouteChange::~RouteChange() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.RouteChange)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void RouteChange::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void RouteChange::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.RouteChange)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.overhead_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.overhead_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RouteChange::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> RouteChange::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RouteChange, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_RouteChange_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(RouteChange, _impl_.timestamp_ms_)}},
    // optional bool connected = 2;
    {::_pbi::TcParser::FastV8S1,
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(RouteChange, _impl_.connected_)}},
    // optional uint32 overhead = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 2, 0, PROTOBUF_FIELD_OFFSET(RouteChange, _impl_.overhead_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(RouteChange, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional bool connected = 2;
    {PROTOBUF_FIELD_OFFSET(RouteChange, _impl_.connected_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint32 overhead = 3;
    {PROTOBUF_FIELD_OFFSET(RouteChange, _impl_.overhead_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* RouteChange::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.RouteChange)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional bool connected = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_connected(), target);
  }

  // optional uint32 overhead = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_overhead(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.RouteChange)
  return target;
}

::size_t RouteChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.RouteChange)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional bool connected = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

    // optional uint32 overhead = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_overhead());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void RouteChange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RouteChange*>(
      &from));
}

void RouteChange::MergeFrom(const RouteChange& from) {
  RouteChange* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.RouteChange)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.connected_ = from._impl_.connected_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.overhead_ = from._impl_.overhead_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RouteChange::CopyFrom(const RouteChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.RouteChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RouteChange::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RouteChange::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RouteChange::InternalSwap(RouteChange* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RouteChange, _impl_.overhead_)
      + sizeof(RouteChange::_impl_.overhead_)
      - PROTOBUF_FIELD_OFFSET(RouteChange, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string RouteChange::GetTypeName() const {
  return "webrtc.rtclog2.RouteChange";
}

// ===================================================================

class RemoteEstimates::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoteEstimates>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_._has_bits_);
  static void set_has_timestamp_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_link_capacity_lower_kbps(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_link_capacity_upper_kbps(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_number_of_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_timestamp_ms_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_link_capacity_lower_kbps_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_link_capacity_upper_kbps_deltas(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

RemoteEstimates::RemoteEstimates(::google::protobuf::Arena* arena)
    : ::google::protobuf::MessageLite(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:webrtc.rtclog2.RemoteEstimates)
}
inline PROTOBUF_NDEBUG_INLINE RemoteEstimates::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        timestamp_ms_deltas_(arena, from.timestamp_ms_deltas_),
        link_capacity_lower_kbps_deltas_(arena, from.link_capacity_lower_kbps_deltas_),
        link_capacity_upper_kbps_deltas_(arena, from.link_capacity_upper_kbps_deltas_) {}

RemoteEstimates::RemoteEstimates(
    ::google::protobuf::Arena* arena,
    const RemoteEstimates& from)
    : ::google::protobuf::MessageLite(arena) {
  RemoteEstimates* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<std::string>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, timestamp_ms_),
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));

  // @@protoc_insertion_point(copy_constructor:webrtc.rtclog2.RemoteEstimates)
}
inline PROTOBUF_NDEBUG_INLINE RemoteEstimates::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        timestamp_ms_deltas_(arena),
        link_capacity_lower_kbps_deltas_(arena),
        link_capacity_upper_kbps_deltas_(arena) {}

inline void RemoteEstimates::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_ms_),
           0,
           offsetof(Impl_, number_of_deltas_) -
               offsetof(Impl_, timestamp_ms_) +
               sizeof(Impl_::number_of_deltas_));
}
RemoteEstimates::~RemoteEstimates() {
  // @@protoc_insertion_point(destructor:webrtc.rtclog2.RemoteEstimates)
  _internal_metadata_.Delete<std::string>();
  SharedDtor();
}
inline void RemoteEstimates::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.timestamp_ms_deltas_.Destroy();
  _impl_.link_capacity_lower_kbps_deltas_.Destroy();
  _impl_.link_capacity_upper_kbps_deltas_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void RemoteEstimates::Clear() {
// @@protoc_insertion_point(message_clear_start:webrtc.rtclog2.RemoteEstimates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.timestamp_ms_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.link_capacity_lower_kbps_deltas_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.link_capacity_upper_kbps_deltas_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&_impl_.timestamp_ms_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.number_of_deltas_) -
        reinterpret_cast<char*>(&_impl_.timestamp_ms_)) + sizeof(_impl_.number_of_deltas_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RemoteEstimates::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 0, 7> RemoteEstimates::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_._has_bits_),
    0, // no _extensions_
    103, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_RemoteEstimates_default_instance_._instance,
    ::_pbi::TcParser::GenericFallbackLite,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 timestamp_ms = 1;
    {::_pbi::TcParser::FastV64S1,
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.timestamp_ms_)}},
    // optional uint32 link_capacity_lower_kbps = 2;
    {::_pbi::TcParser::FastV32S1,
     {16, 4, 0, PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.link_capacity_lower_kbps_)}},
    // optional uint32 link_capacity_upper_kbps = 3;
    {::_pbi::TcParser::FastV32S1,
     {24, 5, 0, PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.link_capacity_upper_kbps_)}},
    // optional uint32 number_of_deltas = 4;
    {::_pbi::TcParser::FastV32S1,
     {32, 6, 0, PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.number_of_deltas_)}},
    // optional bytes timestamp_ms_deltas = 101;
    {::_pbi::TcParser::FastBS2,
     {1706, 0, 0, PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.timestamp_ms_deltas_)}},
    // optional bytes link_capacity_lower_kbps_deltas = 102;
    {::_pbi::TcParser::FastBS2,
     {1714, 1, 0, PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.link_capacity_lower_kbps_deltas_)}},
    // optional bytes link_capacity_upper_kbps_deltas = 103;
    {::_pbi::TcParser::FastBS2,
     {1722, 2, 0, PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.link_capacity_upper_kbps_deltas_)}},
  }}, {{
    101, 0, 1,
    65528, 4,
    65535, 65535
  }}, {{
    // optional int64 timestamp_ms = 1;
    {PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.timestamp_ms_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // optional uint32 link_capacity_lower_kbps = 2;
    {PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.link_capacity_lower_kbps_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 link_capacity_upper_kbps = 3;
    {PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.link_capacity_upper_kbps_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional uint32 number_of_deltas = 4;
    {PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.number_of_deltas_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // optional bytes timestamp_ms_deltas = 101;
    {PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.timestamp_ms_deltas_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes link_capacity_lower_kbps_deltas = 102;
    {PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.link_capacity_lower_kbps_deltas_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes link_capacity_upper_kbps_deltas = 103;
    {PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.link_capacity_upper_kbps_deltas_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* RemoteEstimates::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:webrtc.rtclog2.RemoteEstimates)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 timestamp_ms = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_timestamp_ms(), target);
  }

  // optional uint32 link_capacity_lower_kbps = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_link_capacity_lower_kbps(), target);
  }

  // optional uint32 link_capacity_upper_kbps = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_link_capacity_upper_kbps(), target);
  }

  // optional uint32 number_of_deltas = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_number_of_deltas(), target);
  }

  // optional bytes timestamp_ms_deltas = 101;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_timestamp_ms_deltas();
    target = stream->WriteBytesMaybeAliased(101, _s, target);
  }

  // optional bytes link_capacity_lower_kbps_deltas = 102;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_link_capacity_lower_kbps_deltas();
    target = stream->WriteBytesMaybeAliased(102, _s, target);
  }

  // optional bytes link_capacity_upper_kbps_deltas = 103;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_link_capacity_upper_kbps_deltas();
    target = stream->WriteBytesMaybeAliased(103, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(
        _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:webrtc.rtclog2.RemoteEstimates)
  return target;
}

::size_t RemoteEstimates::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:webrtc.rtclog2.RemoteEstimates)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes timestamp_ms_deltas = 101;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_timestamp_ms_deltas());
    }

    // optional bytes link_capacity_lower_kbps_deltas = 102;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_link_capacity_lower_kbps_deltas());
    }

    // optional bytes link_capacity_upper_kbps_deltas = 103;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_link_capacity_upper_kbps_deltas());
    }

    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_timestamp_ms());
    }

    // optional uint32 link_capacity_lower_kbps = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_link_capacity_lower_kbps());
    }

    // optional uint32 link_capacity_upper_kbps = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_link_capacity_upper_kbps());
    }

    // optional uint32 number_of_deltas = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_number_of_deltas());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString).size();
  }
  _impl_._cached_size_.Set(::_pbi::ToCachedSize(total_size));
  return total_size;
}

void RemoteEstimates::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RemoteEstimates*>(
      &from));
}

void RemoteEstimates::MergeFrom(const RemoteEstimates& from) {
  RemoteEstimates* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:webrtc.rtclog2.RemoteEstimates)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_timestamp_ms_deltas(from._internal_timestamp_ms_deltas());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_link_capacity_lower_kbps_deltas(from._internal_link_capacity_lower_kbps_deltas());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_link_capacity_upper_kbps_deltas(from._internal_link_capacity_upper_kbps_deltas());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.link_capacity_lower_kbps_ = from._impl_.link_capacity_lower_kbps_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.link_capacity_upper_kbps_ = from._impl_.link_capacity_upper_kbps_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.number_of_deltas_ = from._impl_.number_of_deltas_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RemoteEstimates::CopyFrom(const RemoteEstimates& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:webrtc.rtclog2.RemoteEstimates)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RemoteEstimates::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* RemoteEstimates::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void RemoteEstimates::InternalSwap(RemoteEstimates* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.timestamp_ms_deltas_, &other->_impl_.timestamp_ms_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.link_capacity_lower_kbps_deltas_, &other->_impl_.link_capacity_lower_kbps_deltas_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.link_capacity_upper_kbps_deltas_, &other->_impl_.link_capacity_upper_kbps_deltas_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.number_of_deltas_)
      + sizeof(RemoteEstimates::_impl_.number_of_deltas_)
      - PROTOBUF_FIELD_OFFSET(RemoteEstimates, _impl_.timestamp_ms_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_ms_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_ms_));
}

std::string RemoteEstimates::GetTypeName() const {
  return "webrtc.rtclog2.RemoteEstimates";
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace rtclog2
}  // namespace webrtc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
