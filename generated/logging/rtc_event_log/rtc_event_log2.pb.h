// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rtc_event_log2.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_rtc_5fevent_5flog2_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_rtc_5fevent_5flog2_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_rtc_5fevent_5flog2_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_rtc_5fevent_5flog2_2eproto {
  static const ::uint32_t offsets[];
};
namespace webrtc {
namespace rtclog2 {
class AlrState;
struct AlrStateDefaultTypeInternal;
extern AlrStateDefaultTypeInternal _AlrState_default_instance_;
class AudioNetworkAdaptations;
struct AudioNetworkAdaptationsDefaultTypeInternal;
extern AudioNetworkAdaptationsDefaultTypeInternal _AudioNetworkAdaptations_default_instance_;
class AudioPlayoutEvents;
struct AudioPlayoutEventsDefaultTypeInternal;
extern AudioPlayoutEventsDefaultTypeInternal _AudioPlayoutEvents_default_instance_;
class AudioRecvStreamConfig;
struct AudioRecvStreamConfigDefaultTypeInternal;
extern AudioRecvStreamConfigDefaultTypeInternal _AudioRecvStreamConfig_default_instance_;
class AudioSendStreamConfig;
struct AudioSendStreamConfigDefaultTypeInternal;
extern AudioSendStreamConfigDefaultTypeInternal _AudioSendStreamConfig_default_instance_;
class BeginLogEvent;
struct BeginLogEventDefaultTypeInternal;
extern BeginLogEventDefaultTypeInternal _BeginLogEvent_default_instance_;
class BweProbeCluster;
struct BweProbeClusterDefaultTypeInternal;
extern BweProbeClusterDefaultTypeInternal _BweProbeCluster_default_instance_;
class BweProbeResultFailure;
struct BweProbeResultFailureDefaultTypeInternal;
extern BweProbeResultFailureDefaultTypeInternal _BweProbeResultFailure_default_instance_;
class BweProbeResultSuccess;
struct BweProbeResultSuccessDefaultTypeInternal;
extern BweProbeResultSuccessDefaultTypeInternal _BweProbeResultSuccess_default_instance_;
class DelayBasedBweUpdates;
struct DelayBasedBweUpdatesDefaultTypeInternal;
extern DelayBasedBweUpdatesDefaultTypeInternal _DelayBasedBweUpdates_default_instance_;
class DependencyDescriptorsWireInfo;
struct DependencyDescriptorsWireInfoDefaultTypeInternal;
extern DependencyDescriptorsWireInfoDefaultTypeInternal _DependencyDescriptorsWireInfo_default_instance_;
class DtlsTransportStateEvent;
struct DtlsTransportStateEventDefaultTypeInternal;
extern DtlsTransportStateEventDefaultTypeInternal _DtlsTransportStateEvent_default_instance_;
class DtlsWritableState;
struct DtlsWritableStateDefaultTypeInternal;
extern DtlsWritableStateDefaultTypeInternal _DtlsWritableState_default_instance_;
class EndLogEvent;
struct EndLogEventDefaultTypeInternal;
extern EndLogEventDefaultTypeInternal _EndLogEvent_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class EventStream;
struct EventStreamDefaultTypeInternal;
extern EventStreamDefaultTypeInternal _EventStream_default_instance_;
class FrameDecodedEvents;
struct FrameDecodedEventsDefaultTypeInternal;
extern FrameDecodedEventsDefaultTypeInternal _FrameDecodedEvents_default_instance_;
class GenericAckReceived;
struct GenericAckReceivedDefaultTypeInternal;
extern GenericAckReceivedDefaultTypeInternal _GenericAckReceived_default_instance_;
class GenericPacketReceived;
struct GenericPacketReceivedDefaultTypeInternal;
extern GenericPacketReceivedDefaultTypeInternal _GenericPacketReceived_default_instance_;
class GenericPacketSent;
struct GenericPacketSentDefaultTypeInternal;
extern GenericPacketSentDefaultTypeInternal _GenericPacketSent_default_instance_;
class IceCandidatePairConfig;
struct IceCandidatePairConfigDefaultTypeInternal;
extern IceCandidatePairConfigDefaultTypeInternal _IceCandidatePairConfig_default_instance_;
class IceCandidatePairEvent;
struct IceCandidatePairEventDefaultTypeInternal;
extern IceCandidatePairEventDefaultTypeInternal _IceCandidatePairEvent_default_instance_;
class IncomingRtcpPackets;
struct IncomingRtcpPacketsDefaultTypeInternal;
extern IncomingRtcpPacketsDefaultTypeInternal _IncomingRtcpPackets_default_instance_;
class IncomingRtpPackets;
struct IncomingRtpPacketsDefaultTypeInternal;
extern IncomingRtpPacketsDefaultTypeInternal _IncomingRtpPackets_default_instance_;
class LossBasedBweUpdates;
struct LossBasedBweUpdatesDefaultTypeInternal;
extern LossBasedBweUpdatesDefaultTypeInternal _LossBasedBweUpdates_default_instance_;
class NetEqSetMinimumDelay;
struct NetEqSetMinimumDelayDefaultTypeInternal;
extern NetEqSetMinimumDelayDefaultTypeInternal _NetEqSetMinimumDelay_default_instance_;
class OutgoingRtcpPackets;
struct OutgoingRtcpPacketsDefaultTypeInternal;
extern OutgoingRtcpPacketsDefaultTypeInternal _OutgoingRtcpPackets_default_instance_;
class OutgoingRtpPackets;
struct OutgoingRtpPacketsDefaultTypeInternal;
extern OutgoingRtpPacketsDefaultTypeInternal _OutgoingRtpPackets_default_instance_;
class RemoteEstimates;
struct RemoteEstimatesDefaultTypeInternal;
extern RemoteEstimatesDefaultTypeInternal _RemoteEstimates_default_instance_;
class RouteChange;
struct RouteChangeDefaultTypeInternal;
extern RouteChangeDefaultTypeInternal _RouteChange_default_instance_;
class RtpHeaderExtensionConfig;
struct RtpHeaderExtensionConfigDefaultTypeInternal;
extern RtpHeaderExtensionConfigDefaultTypeInternal _RtpHeaderExtensionConfig_default_instance_;
class VideoRecvStreamConfig;
struct VideoRecvStreamConfigDefaultTypeInternal;
extern VideoRecvStreamConfigDefaultTypeInternal _VideoRecvStreamConfig_default_instance_;
class VideoSendStreamConfig;
struct VideoSendStreamConfigDefaultTypeInternal;
extern VideoSendStreamConfigDefaultTypeInternal _VideoSendStreamConfig_default_instance_;
}  // namespace rtclog2
}  // namespace webrtc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace webrtc {
namespace rtclog2 {
enum FrameDecodedEvents_Codec : int {
  FrameDecodedEvents_Codec_CODEC_UNKNOWN = 0,
  FrameDecodedEvents_Codec_CODEC_GENERIC = 1,
  FrameDecodedEvents_Codec_CODEC_VP8 = 2,
  FrameDecodedEvents_Codec_CODEC_VP9 = 3,
  FrameDecodedEvents_Codec_CODEC_AV1 = 4,
  FrameDecodedEvents_Codec_CODEC_H264 = 5,
};

bool FrameDecodedEvents_Codec_IsValid(int value);
extern const uint32_t FrameDecodedEvents_Codec_internal_data_[];
constexpr FrameDecodedEvents_Codec FrameDecodedEvents_Codec_Codec_MIN = static_cast<FrameDecodedEvents_Codec>(0);
constexpr FrameDecodedEvents_Codec FrameDecodedEvents_Codec_Codec_MAX = static_cast<FrameDecodedEvents_Codec>(5);
constexpr int FrameDecodedEvents_Codec_Codec_ARRAYSIZE = 5 + 1;
const std::string& FrameDecodedEvents_Codec_Name(FrameDecodedEvents_Codec value);
template <typename T>
const std::string& FrameDecodedEvents_Codec_Name(T value) {
  static_assert(std::is_same<T, FrameDecodedEvents_Codec>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Codec_Name().");
  return FrameDecodedEvents_Codec_Name(static_cast<FrameDecodedEvents_Codec>(value));
}
const std::string& FrameDecodedEvents_Codec_Name(FrameDecodedEvents_Codec value);
bool FrameDecodedEvents_Codec_Parse(absl::string_view name, FrameDecodedEvents_Codec* value);
enum DelayBasedBweUpdates_DetectorState : int {
  DelayBasedBweUpdates_DetectorState_BWE_UNKNOWN_STATE = 0,
  DelayBasedBweUpdates_DetectorState_BWE_NORMAL = 1,
  DelayBasedBweUpdates_DetectorState_BWE_UNDERUSING = 2,
  DelayBasedBweUpdates_DetectorState_BWE_OVERUSING = 3,
};

bool DelayBasedBweUpdates_DetectorState_IsValid(int value);
extern const uint32_t DelayBasedBweUpdates_DetectorState_internal_data_[];
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates_DetectorState_DetectorState_MIN = static_cast<DelayBasedBweUpdates_DetectorState>(0);
constexpr DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates_DetectorState_DetectorState_MAX = static_cast<DelayBasedBweUpdates_DetectorState>(3);
constexpr int DelayBasedBweUpdates_DetectorState_DetectorState_ARRAYSIZE = 3 + 1;
const std::string& DelayBasedBweUpdates_DetectorState_Name(DelayBasedBweUpdates_DetectorState value);
template <typename T>
const std::string& DelayBasedBweUpdates_DetectorState_Name(T value) {
  static_assert(std::is_same<T, DelayBasedBweUpdates_DetectorState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DetectorState_Name().");
  return DelayBasedBweUpdates_DetectorState_Name(static_cast<DelayBasedBweUpdates_DetectorState>(value));
}
const std::string& DelayBasedBweUpdates_DetectorState_Name(DelayBasedBweUpdates_DetectorState value);
bool DelayBasedBweUpdates_DetectorState_Parse(absl::string_view name, DelayBasedBweUpdates_DetectorState* value);
enum BweProbeResultFailure_FailureReason : int {
  BweProbeResultFailure_FailureReason_UNKNOWN = 0,
  BweProbeResultFailure_FailureReason_INVALID_SEND_RECEIVE_INTERVAL = 1,
  BweProbeResultFailure_FailureReason_INVALID_SEND_RECEIVE_RATIO = 2,
  BweProbeResultFailure_FailureReason_TIMEOUT = 3,
};

bool BweProbeResultFailure_FailureReason_IsValid(int value);
extern const uint32_t BweProbeResultFailure_FailureReason_internal_data_[];
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure_FailureReason_FailureReason_MIN = static_cast<BweProbeResultFailure_FailureReason>(0);
constexpr BweProbeResultFailure_FailureReason BweProbeResultFailure_FailureReason_FailureReason_MAX = static_cast<BweProbeResultFailure_FailureReason>(3);
constexpr int BweProbeResultFailure_FailureReason_FailureReason_ARRAYSIZE = 3 + 1;
const std::string& BweProbeResultFailure_FailureReason_Name(BweProbeResultFailure_FailureReason value);
template <typename T>
const std::string& BweProbeResultFailure_FailureReason_Name(T value) {
  static_assert(std::is_same<T, BweProbeResultFailure_FailureReason>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FailureReason_Name().");
  return BweProbeResultFailure_FailureReason_Name(static_cast<BweProbeResultFailure_FailureReason>(value));
}
const std::string& BweProbeResultFailure_FailureReason_Name(BweProbeResultFailure_FailureReason value);
bool BweProbeResultFailure_FailureReason_Parse(absl::string_view name, BweProbeResultFailure_FailureReason* value);
enum IceCandidatePairConfig_IceCandidatePairConfigType : int {
  IceCandidatePairConfig_IceCandidatePairConfigType_UNKNOWN_CONFIG_TYPE = 0,
  IceCandidatePairConfig_IceCandidatePairConfigType_ADDED = 1,
  IceCandidatePairConfig_IceCandidatePairConfigType_UPDATED = 2,
  IceCandidatePairConfig_IceCandidatePairConfigType_DESTROYED = 3,
  IceCandidatePairConfig_IceCandidatePairConfigType_SELECTED = 4,
};

bool IceCandidatePairConfig_IceCandidatePairConfigType_IsValid(int value);
extern const uint32_t IceCandidatePairConfig_IceCandidatePairConfigType_internal_data_[];
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig_IceCandidatePairConfigType_IceCandidatePairConfigType_MIN = static_cast<IceCandidatePairConfig_IceCandidatePairConfigType>(0);
constexpr IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig_IceCandidatePairConfigType_IceCandidatePairConfigType_MAX = static_cast<IceCandidatePairConfig_IceCandidatePairConfigType>(4);
constexpr int IceCandidatePairConfig_IceCandidatePairConfigType_IceCandidatePairConfigType_ARRAYSIZE = 4 + 1;
const std::string& IceCandidatePairConfig_IceCandidatePairConfigType_Name(IceCandidatePairConfig_IceCandidatePairConfigType value);
template <typename T>
const std::string& IceCandidatePairConfig_IceCandidatePairConfigType_Name(T value) {
  static_assert(std::is_same<T, IceCandidatePairConfig_IceCandidatePairConfigType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IceCandidatePairConfigType_Name().");
  return IceCandidatePairConfig_IceCandidatePairConfigType_Name(static_cast<IceCandidatePairConfig_IceCandidatePairConfigType>(value));
}
const std::string& IceCandidatePairConfig_IceCandidatePairConfigType_Name(IceCandidatePairConfig_IceCandidatePairConfigType value);
bool IceCandidatePairConfig_IceCandidatePairConfigType_Parse(absl::string_view name, IceCandidatePairConfig_IceCandidatePairConfigType* value);
enum IceCandidatePairConfig_IceCandidateType : int {
  IceCandidatePairConfig_IceCandidateType_UNKNOWN_CANDIDATE_TYPE = 0,
  IceCandidatePairConfig_IceCandidateType_LOCAL = 1,
  IceCandidatePairConfig_IceCandidateType_STUN = 2,
  IceCandidatePairConfig_IceCandidateType_PRFLX = 3,
  IceCandidatePairConfig_IceCandidateType_RELAY = 4,
};

bool IceCandidatePairConfig_IceCandidateType_IsValid(int value);
extern const uint32_t IceCandidatePairConfig_IceCandidateType_internal_data_[];
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig_IceCandidateType_IceCandidateType_MIN = static_cast<IceCandidatePairConfig_IceCandidateType>(0);
constexpr IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig_IceCandidateType_IceCandidateType_MAX = static_cast<IceCandidatePairConfig_IceCandidateType>(4);
constexpr int IceCandidatePairConfig_IceCandidateType_IceCandidateType_ARRAYSIZE = 4 + 1;
const std::string& IceCandidatePairConfig_IceCandidateType_Name(IceCandidatePairConfig_IceCandidateType value);
template <typename T>
const std::string& IceCandidatePairConfig_IceCandidateType_Name(T value) {
  static_assert(std::is_same<T, IceCandidatePairConfig_IceCandidateType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IceCandidateType_Name().");
  return IceCandidatePairConfig_IceCandidateType_Name(static_cast<IceCandidatePairConfig_IceCandidateType>(value));
}
const std::string& IceCandidatePairConfig_IceCandidateType_Name(IceCandidatePairConfig_IceCandidateType value);
bool IceCandidatePairConfig_IceCandidateType_Parse(absl::string_view name, IceCandidatePairConfig_IceCandidateType* value);
enum IceCandidatePairConfig_Protocol : int {
  IceCandidatePairConfig_Protocol_UNKNOWN_PROTOCOL = 0,
  IceCandidatePairConfig_Protocol_UDP = 1,
  IceCandidatePairConfig_Protocol_TCP = 2,
  IceCandidatePairConfig_Protocol_SSLTCP = 3,
  IceCandidatePairConfig_Protocol_TLS = 4,
};

bool IceCandidatePairConfig_Protocol_IsValid(int value);
extern const uint32_t IceCandidatePairConfig_Protocol_internal_data_[];
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig_Protocol_Protocol_MIN = static_cast<IceCandidatePairConfig_Protocol>(0);
constexpr IceCandidatePairConfig_Protocol IceCandidatePairConfig_Protocol_Protocol_MAX = static_cast<IceCandidatePairConfig_Protocol>(4);
constexpr int IceCandidatePairConfig_Protocol_Protocol_ARRAYSIZE = 4 + 1;
const std::string& IceCandidatePairConfig_Protocol_Name(IceCandidatePairConfig_Protocol value);
template <typename T>
const std::string& IceCandidatePairConfig_Protocol_Name(T value) {
  static_assert(std::is_same<T, IceCandidatePairConfig_Protocol>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Protocol_Name().");
  return IceCandidatePairConfig_Protocol_Name(static_cast<IceCandidatePairConfig_Protocol>(value));
}
const std::string& IceCandidatePairConfig_Protocol_Name(IceCandidatePairConfig_Protocol value);
bool IceCandidatePairConfig_Protocol_Parse(absl::string_view name, IceCandidatePairConfig_Protocol* value);
enum IceCandidatePairConfig_AddressFamily : int {
  IceCandidatePairConfig_AddressFamily_UNKNOWN_ADDRESS_FAMILY = 0,
  IceCandidatePairConfig_AddressFamily_IPV4 = 1,
  IceCandidatePairConfig_AddressFamily_IPV6 = 2,
};

bool IceCandidatePairConfig_AddressFamily_IsValid(int value);
extern const uint32_t IceCandidatePairConfig_AddressFamily_internal_data_[];
constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig_AddressFamily_AddressFamily_MIN = static_cast<IceCandidatePairConfig_AddressFamily>(0);
constexpr IceCandidatePairConfig_AddressFamily IceCandidatePairConfig_AddressFamily_AddressFamily_MAX = static_cast<IceCandidatePairConfig_AddressFamily>(2);
constexpr int IceCandidatePairConfig_AddressFamily_AddressFamily_ARRAYSIZE = 2 + 1;
const std::string& IceCandidatePairConfig_AddressFamily_Name(IceCandidatePairConfig_AddressFamily value);
template <typename T>
const std::string& IceCandidatePairConfig_AddressFamily_Name(T value) {
  static_assert(std::is_same<T, IceCandidatePairConfig_AddressFamily>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AddressFamily_Name().");
  return IceCandidatePairConfig_AddressFamily_Name(static_cast<IceCandidatePairConfig_AddressFamily>(value));
}
const std::string& IceCandidatePairConfig_AddressFamily_Name(IceCandidatePairConfig_AddressFamily value);
bool IceCandidatePairConfig_AddressFamily_Parse(absl::string_view name, IceCandidatePairConfig_AddressFamily* value);
enum IceCandidatePairConfig_NetworkType : int {
  IceCandidatePairConfig_NetworkType_UNKNOWN_NETWORK_TYPE = 0,
  IceCandidatePairConfig_NetworkType_ETHERNET = 1,
  IceCandidatePairConfig_NetworkType_WIFI = 2,
  IceCandidatePairConfig_NetworkType_CELLULAR = 3,
  IceCandidatePairConfig_NetworkType_VPN = 4,
  IceCandidatePairConfig_NetworkType_LOOPBACK = 5,
};

bool IceCandidatePairConfig_NetworkType_IsValid(int value);
extern const uint32_t IceCandidatePairConfig_NetworkType_internal_data_[];
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig_NetworkType_NetworkType_MIN = static_cast<IceCandidatePairConfig_NetworkType>(0);
constexpr IceCandidatePairConfig_NetworkType IceCandidatePairConfig_NetworkType_NetworkType_MAX = static_cast<IceCandidatePairConfig_NetworkType>(5);
constexpr int IceCandidatePairConfig_NetworkType_NetworkType_ARRAYSIZE = 5 + 1;
const std::string& IceCandidatePairConfig_NetworkType_Name(IceCandidatePairConfig_NetworkType value);
template <typename T>
const std::string& IceCandidatePairConfig_NetworkType_Name(T value) {
  static_assert(std::is_same<T, IceCandidatePairConfig_NetworkType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NetworkType_Name().");
  return IceCandidatePairConfig_NetworkType_Name(static_cast<IceCandidatePairConfig_NetworkType>(value));
}
const std::string& IceCandidatePairConfig_NetworkType_Name(IceCandidatePairConfig_NetworkType value);
bool IceCandidatePairConfig_NetworkType_Parse(absl::string_view name, IceCandidatePairConfig_NetworkType* value);
enum IceCandidatePairEvent_IceCandidatePairEventType : int {
  IceCandidatePairEvent_IceCandidatePairEventType_UNKNOWN_CHECK_TYPE = 0,
  IceCandidatePairEvent_IceCandidatePairEventType_CHECK_SENT = 1,
  IceCandidatePairEvent_IceCandidatePairEventType_CHECK_RECEIVED = 2,
  IceCandidatePairEvent_IceCandidatePairEventType_CHECK_RESPONSE_SENT = 3,
  IceCandidatePairEvent_IceCandidatePairEventType_CHECK_RESPONSE_RECEIVED = 4,
};

bool IceCandidatePairEvent_IceCandidatePairEventType_IsValid(int value);
extern const uint32_t IceCandidatePairEvent_IceCandidatePairEventType_internal_data_[];
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent_IceCandidatePairEventType_IceCandidatePairEventType_MIN = static_cast<IceCandidatePairEvent_IceCandidatePairEventType>(0);
constexpr IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent_IceCandidatePairEventType_IceCandidatePairEventType_MAX = static_cast<IceCandidatePairEvent_IceCandidatePairEventType>(4);
constexpr int IceCandidatePairEvent_IceCandidatePairEventType_IceCandidatePairEventType_ARRAYSIZE = 4 + 1;
const std::string& IceCandidatePairEvent_IceCandidatePairEventType_Name(IceCandidatePairEvent_IceCandidatePairEventType value);
template <typename T>
const std::string& IceCandidatePairEvent_IceCandidatePairEventType_Name(T value) {
  static_assert(std::is_same<T, IceCandidatePairEvent_IceCandidatePairEventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IceCandidatePairEventType_Name().");
  return IceCandidatePairEvent_IceCandidatePairEventType_Name(static_cast<IceCandidatePairEvent_IceCandidatePairEventType>(value));
}
const std::string& IceCandidatePairEvent_IceCandidatePairEventType_Name(IceCandidatePairEvent_IceCandidatePairEventType value);
bool IceCandidatePairEvent_IceCandidatePairEventType_Parse(absl::string_view name, IceCandidatePairEvent_IceCandidatePairEventType* value);
enum DtlsTransportStateEvent_DtlsTransportState : int {
  DtlsTransportStateEvent_DtlsTransportState_UNKNOWN_DTLS_TRANSPORT_STATE = 0,
  DtlsTransportStateEvent_DtlsTransportState_DTLS_TRANSPORT_NEW = 1,
  DtlsTransportStateEvent_DtlsTransportState_DTLS_TRANSPORT_CONNECTING = 2,
  DtlsTransportStateEvent_DtlsTransportState_DTLS_TRANSPORT_CONNECTED = 3,
  DtlsTransportStateEvent_DtlsTransportState_DTLS_TRANSPORT_CLOSED = 4,
  DtlsTransportStateEvent_DtlsTransportState_DTLS_TRANSPORT_FAILED = 5,
};

bool DtlsTransportStateEvent_DtlsTransportState_IsValid(int value);
extern const uint32_t DtlsTransportStateEvent_DtlsTransportState_internal_data_[];
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent_DtlsTransportState_DtlsTransportState_MIN = static_cast<DtlsTransportStateEvent_DtlsTransportState>(0);
constexpr DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent_DtlsTransportState_DtlsTransportState_MAX = static_cast<DtlsTransportStateEvent_DtlsTransportState>(5);
constexpr int DtlsTransportStateEvent_DtlsTransportState_DtlsTransportState_ARRAYSIZE = 5 + 1;
const std::string& DtlsTransportStateEvent_DtlsTransportState_Name(DtlsTransportStateEvent_DtlsTransportState value);
template <typename T>
const std::string& DtlsTransportStateEvent_DtlsTransportState_Name(T value) {
  static_assert(std::is_same<T, DtlsTransportStateEvent_DtlsTransportState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DtlsTransportState_Name().");
  return DtlsTransportStateEvent_DtlsTransportState_Name(static_cast<DtlsTransportStateEvent_DtlsTransportState>(value));
}
const std::string& DtlsTransportStateEvent_DtlsTransportState_Name(DtlsTransportStateEvent_DtlsTransportState value);
bool DtlsTransportStateEvent_DtlsTransportState_Parse(absl::string_view name, DtlsTransportStateEvent_DtlsTransportState* value);

// ===================================================================


// -------------------------------------------------------------------

class RtpHeaderExtensionConfig final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.RtpHeaderExtensionConfig) */ {
 public:
  inline RtpHeaderExtensionConfig() : RtpHeaderExtensionConfig(nullptr) {}
  ~RtpHeaderExtensionConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RtpHeaderExtensionConfig(::google::protobuf::internal::ConstantInitialized);

  inline RtpHeaderExtensionConfig(const RtpHeaderExtensionConfig& from)
      : RtpHeaderExtensionConfig(nullptr, from) {}
  RtpHeaderExtensionConfig(RtpHeaderExtensionConfig&& from) noexcept
    : RtpHeaderExtensionConfig() {
    *this = ::std::move(from);
  }

  inline RtpHeaderExtensionConfig& operator=(const RtpHeaderExtensionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtpHeaderExtensionConfig& operator=(RtpHeaderExtensionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RtpHeaderExtensionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtpHeaderExtensionConfig* internal_default_instance() {
    return reinterpret_cast<const RtpHeaderExtensionConfig*>(
               &_RtpHeaderExtensionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RtpHeaderExtensionConfig& a, RtpHeaderExtensionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RtpHeaderExtensionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtpHeaderExtensionConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RtpHeaderExtensionConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RtpHeaderExtensionConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const RtpHeaderExtensionConfig& from);
  void MergeFrom(const RtpHeaderExtensionConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RtpHeaderExtensionConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.RtpHeaderExtensionConfig";
  }
  protected:
  explicit RtpHeaderExtensionConfig(::google::protobuf::Arena* arena);
  RtpHeaderExtensionConfig(::google::protobuf::Arena* arena, const RtpHeaderExtensionConfig& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransmissionTimeOffsetIdFieldNumber = 1,
    kAbsoluteSendTimeIdFieldNumber = 2,
    kTransportSequenceNumberIdFieldNumber = 3,
    kVideoRotationIdFieldNumber = 4,
    kAudioLevelIdFieldNumber = 5,
    kDependencyDescriptorIdFieldNumber = 6,
  };
  // optional int32 transmission_time_offset_id = 1;
  bool has_transmission_time_offset_id() const;
  void clear_transmission_time_offset_id() ;
  ::int32_t transmission_time_offset_id() const;
  void set_transmission_time_offset_id(::int32_t value);

  private:
  ::int32_t _internal_transmission_time_offset_id() const;
  void _internal_set_transmission_time_offset_id(::int32_t value);

  public:
  // optional int32 absolute_send_time_id = 2;
  bool has_absolute_send_time_id() const;
  void clear_absolute_send_time_id() ;
  ::int32_t absolute_send_time_id() const;
  void set_absolute_send_time_id(::int32_t value);

  private:
  ::int32_t _internal_absolute_send_time_id() const;
  void _internal_set_absolute_send_time_id(::int32_t value);

  public:
  // optional int32 transport_sequence_number_id = 3;
  bool has_transport_sequence_number_id() const;
  void clear_transport_sequence_number_id() ;
  ::int32_t transport_sequence_number_id() const;
  void set_transport_sequence_number_id(::int32_t value);

  private:
  ::int32_t _internal_transport_sequence_number_id() const;
  void _internal_set_transport_sequence_number_id(::int32_t value);

  public:
  // optional int32 video_rotation_id = 4;
  bool has_video_rotation_id() const;
  void clear_video_rotation_id() ;
  ::int32_t video_rotation_id() const;
  void set_video_rotation_id(::int32_t value);

  private:
  ::int32_t _internal_video_rotation_id() const;
  void _internal_set_video_rotation_id(::int32_t value);

  public:
  // optional int32 audio_level_id = 5;
  bool has_audio_level_id() const;
  void clear_audio_level_id() ;
  ::int32_t audio_level_id() const;
  void set_audio_level_id(::int32_t value);

  private:
  ::int32_t _internal_audio_level_id() const;
  void _internal_set_audio_level_id(::int32_t value);

  public:
  // optional int32 dependency_descriptor_id = 6;
  bool has_dependency_descriptor_id() const;
  void clear_dependency_descriptor_id() ;
  ::int32_t dependency_descriptor_id() const;
  void set_dependency_descriptor_id(::int32_t value);

  private:
  ::int32_t _internal_dependency_descriptor_id() const;
  void _internal_set_dependency_descriptor_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.RtpHeaderExtensionConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t transmission_time_offset_id_;
    ::int32_t absolute_send_time_id_;
    ::int32_t transport_sequence_number_id_;
    ::int32_t video_rotation_id_;
    ::int32_t audio_level_id_;
    ::int32_t dependency_descriptor_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class RouteChange final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.RouteChange) */ {
 public:
  inline RouteChange() : RouteChange(nullptr) {}
  ~RouteChange() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RouteChange(::google::protobuf::internal::ConstantInitialized);

  inline RouteChange(const RouteChange& from)
      : RouteChange(nullptr, from) {}
  RouteChange(RouteChange&& from) noexcept
    : RouteChange() {
    *this = ::std::move(from);
  }

  inline RouteChange& operator=(const RouteChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteChange& operator=(RouteChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RouteChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteChange* internal_default_instance() {
    return reinterpret_cast<const RouteChange*>(
               &_RouteChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RouteChange& a, RouteChange& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteChange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteChange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteChange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const RouteChange& from);
  void MergeFrom(const RouteChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RouteChange* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.RouteChange";
  }
  protected:
  explicit RouteChange(::google::protobuf::Arena* arena);
  RouteChange(::google::protobuf::Arena* arena, const RouteChange& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kConnectedFieldNumber = 2,
    kOverheadFieldNumber = 3,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional bool connected = 2;
  bool has_connected() const;
  void clear_connected() ;
  bool connected() const;
  void set_connected(bool value);

  private:
  bool _internal_connected() const;
  void _internal_set_connected(bool value);

  public:
  // optional uint32 overhead = 3;
  bool has_overhead() const;
  void clear_overhead() ;
  ::uint32_t overhead() const;
  void set_overhead(::uint32_t value);

  private:
  ::uint32_t _internal_overhead() const;
  void _internal_set_overhead(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.RouteChange)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_ms_;
    bool connected_;
    ::uint32_t overhead_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class RemoteEstimates final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.RemoteEstimates) */ {
 public:
  inline RemoteEstimates() : RemoteEstimates(nullptr) {}
  ~RemoteEstimates() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteEstimates(::google::protobuf::internal::ConstantInitialized);

  inline RemoteEstimates(const RemoteEstimates& from)
      : RemoteEstimates(nullptr, from) {}
  RemoteEstimates(RemoteEstimates&& from) noexcept
    : RemoteEstimates() {
    *this = ::std::move(from);
  }

  inline RemoteEstimates& operator=(const RemoteEstimates& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteEstimates& operator=(RemoteEstimates&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RemoteEstimates& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteEstimates* internal_default_instance() {
    return reinterpret_cast<const RemoteEstimates*>(
               &_RemoteEstimates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(RemoteEstimates& a, RemoteEstimates& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteEstimates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteEstimates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteEstimates* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteEstimates>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const RemoteEstimates& from);
  void MergeFrom(const RemoteEstimates& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RemoteEstimates* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.RemoteEstimates";
  }
  protected:
  explicit RemoteEstimates(::google::protobuf::Arena* arena);
  RemoteEstimates(::google::protobuf::Arena* arena, const RemoteEstimates& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 101,
    kLinkCapacityLowerKbpsDeltasFieldNumber = 102,
    kLinkCapacityUpperKbpsDeltasFieldNumber = 103,
    kTimestampMsFieldNumber = 1,
    kLinkCapacityLowerKbpsFieldNumber = 2,
    kLinkCapacityUpperKbpsFieldNumber = 3,
    kNumberOfDeltasFieldNumber = 4,
  };
  // optional bytes timestamp_ms_deltas = 101;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes link_capacity_lower_kbps_deltas = 102;
  bool has_link_capacity_lower_kbps_deltas() const;
  void clear_link_capacity_lower_kbps_deltas() ;
  const std::string& link_capacity_lower_kbps_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_capacity_lower_kbps_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_link_capacity_lower_kbps_deltas();
  PROTOBUF_NODISCARD std::string* release_link_capacity_lower_kbps_deltas();
  void set_allocated_link_capacity_lower_kbps_deltas(std::string* value);

  private:
  const std::string& _internal_link_capacity_lower_kbps_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_capacity_lower_kbps_deltas(
      const std::string& value);
  std::string* _internal_mutable_link_capacity_lower_kbps_deltas();

  public:
  // optional bytes link_capacity_upper_kbps_deltas = 103;
  bool has_link_capacity_upper_kbps_deltas() const;
  void clear_link_capacity_upper_kbps_deltas() ;
  const std::string& link_capacity_upper_kbps_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_link_capacity_upper_kbps_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_link_capacity_upper_kbps_deltas();
  PROTOBUF_NODISCARD std::string* release_link_capacity_upper_kbps_deltas();
  void set_allocated_link_capacity_upper_kbps_deltas(std::string* value);

  private:
  const std::string& _internal_link_capacity_upper_kbps_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_capacity_upper_kbps_deltas(
      const std::string& value);
  std::string* _internal_mutable_link_capacity_upper_kbps_deltas();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 link_capacity_lower_kbps = 2;
  bool has_link_capacity_lower_kbps() const;
  void clear_link_capacity_lower_kbps() ;
  ::uint32_t link_capacity_lower_kbps() const;
  void set_link_capacity_lower_kbps(::uint32_t value);

  private:
  ::uint32_t _internal_link_capacity_lower_kbps() const;
  void _internal_set_link_capacity_lower_kbps(::uint32_t value);

  public:
  // optional uint32 link_capacity_upper_kbps = 3;
  bool has_link_capacity_upper_kbps() const;
  void clear_link_capacity_upper_kbps() ;
  ::uint32_t link_capacity_upper_kbps() const;
  void set_link_capacity_upper_kbps(::uint32_t value);

  private:
  ::uint32_t _internal_link_capacity_upper_kbps() const;
  void _internal_set_link_capacity_upper_kbps(::uint32_t value);

  public:
  // optional uint32 number_of_deltas = 4;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.RemoteEstimates)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr link_capacity_lower_kbps_deltas_;
    ::google::protobuf::internal::ArenaStringPtr link_capacity_upper_kbps_deltas_;
    ::int64_t timestamp_ms_;
    ::uint32_t link_capacity_lower_kbps_;
    ::uint32_t link_capacity_upper_kbps_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class OutgoingRtcpPackets final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.OutgoingRtcpPackets) */ {
 public:
  inline OutgoingRtcpPackets() : OutgoingRtcpPackets(nullptr) {}
  ~OutgoingRtcpPackets() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OutgoingRtcpPackets(::google::protobuf::internal::ConstantInitialized);

  inline OutgoingRtcpPackets(const OutgoingRtcpPackets& from)
      : OutgoingRtcpPackets(nullptr, from) {}
  OutgoingRtcpPackets(OutgoingRtcpPackets&& from) noexcept
    : OutgoingRtcpPackets() {
    *this = ::std::move(from);
  }

  inline OutgoingRtcpPackets& operator=(const OutgoingRtcpPackets& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutgoingRtcpPackets& operator=(OutgoingRtcpPackets&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OutgoingRtcpPackets& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutgoingRtcpPackets* internal_default_instance() {
    return reinterpret_cast<const OutgoingRtcpPackets*>(
               &_OutgoingRtcpPackets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OutgoingRtcpPackets& a, OutgoingRtcpPackets& b) {
    a.Swap(&b);
  }
  inline void Swap(OutgoingRtcpPackets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutgoingRtcpPackets* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutgoingRtcpPackets* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutgoingRtcpPackets>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const OutgoingRtcpPackets& from);
  void MergeFrom(const OutgoingRtcpPackets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OutgoingRtcpPackets* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.OutgoingRtcpPackets";
  }
  protected:
  explicit OutgoingRtcpPackets(::google::protobuf::Arena* arena);
  OutgoingRtcpPackets(::google::protobuf::Arena* arena, const OutgoingRtcpPackets& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawPacketFieldNumber = 2,
    kTimestampMsDeltasFieldNumber = 101,
    kRawPacketBlobsFieldNumber = 102,
    kTimestampMsFieldNumber = 1,
    kNumberOfDeltasFieldNumber = 3,
  };
  // optional bytes raw_packet = 2;
  bool has_raw_packet() const;
  void clear_raw_packet() ;
  const std::string& raw_packet() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_raw_packet(Arg_&& arg, Args_... args);
  std::string* mutable_raw_packet();
  PROTOBUF_NODISCARD std::string* release_raw_packet();
  void set_allocated_raw_packet(std::string* value);

  private:
  const std::string& _internal_raw_packet() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_packet(
      const std::string& value);
  std::string* _internal_mutable_raw_packet();

  public:
  // optional bytes timestamp_ms_deltas = 101;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes raw_packet_blobs = 102;
  bool has_raw_packet_blobs() const;
  void clear_raw_packet_blobs() ;
  const std::string& raw_packet_blobs() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_raw_packet_blobs(Arg_&& arg, Args_... args);
  std::string* mutable_raw_packet_blobs();
  PROTOBUF_NODISCARD std::string* release_raw_packet_blobs();
  void set_allocated_raw_packet_blobs(std::string* value);

  private:
  const std::string& _internal_raw_packet_blobs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_packet_blobs(
      const std::string& value);
  std::string* _internal_mutable_raw_packet_blobs();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 number_of_deltas = 3;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.OutgoingRtcpPackets)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr raw_packet_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr raw_packet_blobs_;
    ::int64_t timestamp_ms_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class NetEqSetMinimumDelay final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.NetEqSetMinimumDelay) */ {
 public:
  inline NetEqSetMinimumDelay() : NetEqSetMinimumDelay(nullptr) {}
  ~NetEqSetMinimumDelay() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NetEqSetMinimumDelay(::google::protobuf::internal::ConstantInitialized);

  inline NetEqSetMinimumDelay(const NetEqSetMinimumDelay& from)
      : NetEqSetMinimumDelay(nullptr, from) {}
  NetEqSetMinimumDelay(NetEqSetMinimumDelay&& from) noexcept
    : NetEqSetMinimumDelay() {
    *this = ::std::move(from);
  }

  inline NetEqSetMinimumDelay& operator=(const NetEqSetMinimumDelay& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetEqSetMinimumDelay& operator=(NetEqSetMinimumDelay&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NetEqSetMinimumDelay& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetEqSetMinimumDelay* internal_default_instance() {
    return reinterpret_cast<const NetEqSetMinimumDelay*>(
               &_NetEqSetMinimumDelay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NetEqSetMinimumDelay& a, NetEqSetMinimumDelay& b) {
    a.Swap(&b);
  }
  inline void Swap(NetEqSetMinimumDelay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetEqSetMinimumDelay* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetEqSetMinimumDelay* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetEqSetMinimumDelay>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const NetEqSetMinimumDelay& from);
  void MergeFrom(const NetEqSetMinimumDelay& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NetEqSetMinimumDelay* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.NetEqSetMinimumDelay";
  }
  protected:
  explicit NetEqSetMinimumDelay(::google::protobuf::Arena* arena);
  NetEqSetMinimumDelay(::google::protobuf::Arena* arena, const NetEqSetMinimumDelay& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 101,
    kRemoteSsrcDeltasFieldNumber = 102,
    kMinimumDelayMsDeltasFieldNumber = 103,
    kTimestampMsFieldNumber = 1,
    kRemoteSsrcFieldNumber = 2,
    kMinimumDelayMsFieldNumber = 3,
    kNumberOfDeltasFieldNumber = 4,
  };
  // optional bytes timestamp_ms_deltas = 101;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes remote_ssrc_deltas = 102;
  bool has_remote_ssrc_deltas() const;
  void clear_remote_ssrc_deltas() ;
  const std::string& remote_ssrc_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_remote_ssrc_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_remote_ssrc_deltas();
  PROTOBUF_NODISCARD std::string* release_remote_ssrc_deltas();
  void set_allocated_remote_ssrc_deltas(std::string* value);

  private:
  const std::string& _internal_remote_ssrc_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_ssrc_deltas(
      const std::string& value);
  std::string* _internal_mutable_remote_ssrc_deltas();

  public:
  // optional bytes minimum_delay_ms_deltas = 103;
  bool has_minimum_delay_ms_deltas() const;
  void clear_minimum_delay_ms_deltas() ;
  const std::string& minimum_delay_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_minimum_delay_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_minimum_delay_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_minimum_delay_ms_deltas();
  void set_allocated_minimum_delay_ms_deltas(std::string* value);

  private:
  const std::string& _internal_minimum_delay_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minimum_delay_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_minimum_delay_ms_deltas();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional fixed32 remote_ssrc = 2;
  bool has_remote_ssrc() const;
  void clear_remote_ssrc() ;
  ::uint32_t remote_ssrc() const;
  void set_remote_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_remote_ssrc() const;
  void _internal_set_remote_ssrc(::uint32_t value);

  public:
  // optional int32 minimum_delay_ms = 3;
  bool has_minimum_delay_ms() const;
  void clear_minimum_delay_ms() ;
  ::int32_t minimum_delay_ms() const;
  void set_minimum_delay_ms(::int32_t value);

  private:
  ::int32_t _internal_minimum_delay_ms() const;
  void _internal_set_minimum_delay_ms(::int32_t value);

  public:
  // optional uint32 number_of_deltas = 4;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.NetEqSetMinimumDelay)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr remote_ssrc_deltas_;
    ::google::protobuf::internal::ArenaStringPtr minimum_delay_ms_deltas_;
    ::int64_t timestamp_ms_;
    ::uint32_t remote_ssrc_;
    ::int32_t minimum_delay_ms_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class LossBasedBweUpdates final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.LossBasedBweUpdates) */ {
 public:
  inline LossBasedBweUpdates() : LossBasedBweUpdates(nullptr) {}
  ~LossBasedBweUpdates() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LossBasedBweUpdates(::google::protobuf::internal::ConstantInitialized);

  inline LossBasedBweUpdates(const LossBasedBweUpdates& from)
      : LossBasedBweUpdates(nullptr, from) {}
  LossBasedBweUpdates(LossBasedBweUpdates&& from) noexcept
    : LossBasedBweUpdates() {
    *this = ::std::move(from);
  }

  inline LossBasedBweUpdates& operator=(const LossBasedBweUpdates& from) {
    CopyFrom(from);
    return *this;
  }
  inline LossBasedBweUpdates& operator=(LossBasedBweUpdates&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const LossBasedBweUpdates& default_instance() {
    return *internal_default_instance();
  }
  static inline const LossBasedBweUpdates* internal_default_instance() {
    return reinterpret_cast<const LossBasedBweUpdates*>(
               &_LossBasedBweUpdates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LossBasedBweUpdates& a, LossBasedBweUpdates& b) {
    a.Swap(&b);
  }
  inline void Swap(LossBasedBweUpdates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LossBasedBweUpdates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LossBasedBweUpdates* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LossBasedBweUpdates>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const LossBasedBweUpdates& from);
  void MergeFrom(const LossBasedBweUpdates& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LossBasedBweUpdates* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.LossBasedBweUpdates";
  }
  protected:
  explicit LossBasedBweUpdates(::google::protobuf::Arena* arena);
  LossBasedBweUpdates(::google::protobuf::Arena* arena, const LossBasedBweUpdates& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 101,
    kBitrateBpsDeltasFieldNumber = 102,
    kFractionLossDeltasFieldNumber = 103,
    kTotalPacketsDeltasFieldNumber = 104,
    kTimestampMsFieldNumber = 1,
    kBitrateBpsFieldNumber = 2,
    kFractionLossFieldNumber = 3,
    kTotalPacketsFieldNumber = 4,
    kNumberOfDeltasFieldNumber = 5,
  };
  // optional bytes timestamp_ms_deltas = 101;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes bitrate_bps_deltas = 102;
  bool has_bitrate_bps_deltas() const;
  void clear_bitrate_bps_deltas() ;
  const std::string& bitrate_bps_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bitrate_bps_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_bitrate_bps_deltas();
  PROTOBUF_NODISCARD std::string* release_bitrate_bps_deltas();
  void set_allocated_bitrate_bps_deltas(std::string* value);

  private:
  const std::string& _internal_bitrate_bps_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bitrate_bps_deltas(
      const std::string& value);
  std::string* _internal_mutable_bitrate_bps_deltas();

  public:
  // optional bytes fraction_loss_deltas = 103;
  bool has_fraction_loss_deltas() const;
  void clear_fraction_loss_deltas() ;
  const std::string& fraction_loss_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fraction_loss_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_fraction_loss_deltas();
  PROTOBUF_NODISCARD std::string* release_fraction_loss_deltas();
  void set_allocated_fraction_loss_deltas(std::string* value);

  private:
  const std::string& _internal_fraction_loss_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fraction_loss_deltas(
      const std::string& value);
  std::string* _internal_mutable_fraction_loss_deltas();

  public:
  // optional bytes total_packets_deltas = 104;
  bool has_total_packets_deltas() const;
  void clear_total_packets_deltas() ;
  const std::string& total_packets_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_total_packets_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_total_packets_deltas();
  PROTOBUF_NODISCARD std::string* release_total_packets_deltas();
  void set_allocated_total_packets_deltas(std::string* value);

  private:
  const std::string& _internal_total_packets_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_packets_deltas(
      const std::string& value);
  std::string* _internal_mutable_total_packets_deltas();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 bitrate_bps = 2;
  bool has_bitrate_bps() const;
  void clear_bitrate_bps() ;
  ::uint32_t bitrate_bps() const;
  void set_bitrate_bps(::uint32_t value);

  private:
  ::uint32_t _internal_bitrate_bps() const;
  void _internal_set_bitrate_bps(::uint32_t value);

  public:
  // optional uint32 fraction_loss = 3;
  bool has_fraction_loss() const;
  void clear_fraction_loss() ;
  ::uint32_t fraction_loss() const;
  void set_fraction_loss(::uint32_t value);

  private:
  ::uint32_t _internal_fraction_loss() const;
  void _internal_set_fraction_loss(::uint32_t value);

  public:
  // optional uint32 total_packets = 4;
  bool has_total_packets() const;
  void clear_total_packets() ;
  ::uint32_t total_packets() const;
  void set_total_packets(::uint32_t value);

  private:
  ::uint32_t _internal_total_packets() const;
  void _internal_set_total_packets(::uint32_t value);

  public:
  // optional uint32 number_of_deltas = 5;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.LossBasedBweUpdates)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 9, 0,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr bitrate_bps_deltas_;
    ::google::protobuf::internal::ArenaStringPtr fraction_loss_deltas_;
    ::google::protobuf::internal::ArenaStringPtr total_packets_deltas_;
    ::int64_t timestamp_ms_;
    ::uint32_t bitrate_bps_;
    ::uint32_t fraction_loss_;
    ::uint32_t total_packets_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class IncomingRtcpPackets final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.IncomingRtcpPackets) */ {
 public:
  inline IncomingRtcpPackets() : IncomingRtcpPackets(nullptr) {}
  ~IncomingRtcpPackets() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IncomingRtcpPackets(::google::protobuf::internal::ConstantInitialized);

  inline IncomingRtcpPackets(const IncomingRtcpPackets& from)
      : IncomingRtcpPackets(nullptr, from) {}
  IncomingRtcpPackets(IncomingRtcpPackets&& from) noexcept
    : IncomingRtcpPackets() {
    *this = ::std::move(from);
  }

  inline IncomingRtcpPackets& operator=(const IncomingRtcpPackets& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncomingRtcpPackets& operator=(IncomingRtcpPackets&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IncomingRtcpPackets& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncomingRtcpPackets* internal_default_instance() {
    return reinterpret_cast<const IncomingRtcpPackets*>(
               &_IncomingRtcpPackets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(IncomingRtcpPackets& a, IncomingRtcpPackets& b) {
    a.Swap(&b);
  }
  inline void Swap(IncomingRtcpPackets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncomingRtcpPackets* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncomingRtcpPackets* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncomingRtcpPackets>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const IncomingRtcpPackets& from);
  void MergeFrom(const IncomingRtcpPackets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IncomingRtcpPackets* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.IncomingRtcpPackets";
  }
  protected:
  explicit IncomingRtcpPackets(::google::protobuf::Arena* arena);
  IncomingRtcpPackets(::google::protobuf::Arena* arena, const IncomingRtcpPackets& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawPacketFieldNumber = 2,
    kTimestampMsDeltasFieldNumber = 101,
    kRawPacketBlobsFieldNumber = 102,
    kTimestampMsFieldNumber = 1,
    kNumberOfDeltasFieldNumber = 3,
  };
  // optional bytes raw_packet = 2;
  bool has_raw_packet() const;
  void clear_raw_packet() ;
  const std::string& raw_packet() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_raw_packet(Arg_&& arg, Args_... args);
  std::string* mutable_raw_packet();
  PROTOBUF_NODISCARD std::string* release_raw_packet();
  void set_allocated_raw_packet(std::string* value);

  private:
  const std::string& _internal_raw_packet() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_packet(
      const std::string& value);
  std::string* _internal_mutable_raw_packet();

  public:
  // optional bytes timestamp_ms_deltas = 101;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes raw_packet_blobs = 102;
  bool has_raw_packet_blobs() const;
  void clear_raw_packet_blobs() ;
  const std::string& raw_packet_blobs() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_raw_packet_blobs(Arg_&& arg, Args_... args);
  std::string* mutable_raw_packet_blobs();
  PROTOBUF_NODISCARD std::string* release_raw_packet_blobs();
  void set_allocated_raw_packet_blobs(std::string* value);

  private:
  const std::string& _internal_raw_packet_blobs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_packet_blobs(
      const std::string& value);
  std::string* _internal_mutable_raw_packet_blobs();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 number_of_deltas = 3;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.IncomingRtcpPackets)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr raw_packet_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr raw_packet_blobs_;
    ::int64_t timestamp_ms_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class IceCandidatePairEvent final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.IceCandidatePairEvent) */ {
 public:
  inline IceCandidatePairEvent() : IceCandidatePairEvent(nullptr) {}
  ~IceCandidatePairEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IceCandidatePairEvent(::google::protobuf::internal::ConstantInitialized);

  inline IceCandidatePairEvent(const IceCandidatePairEvent& from)
      : IceCandidatePairEvent(nullptr, from) {}
  IceCandidatePairEvent(IceCandidatePairEvent&& from) noexcept
    : IceCandidatePairEvent() {
    *this = ::std::move(from);
  }

  inline IceCandidatePairEvent& operator=(const IceCandidatePairEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline IceCandidatePairEvent& operator=(IceCandidatePairEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IceCandidatePairEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const IceCandidatePairEvent* internal_default_instance() {
    return reinterpret_cast<const IceCandidatePairEvent*>(
               &_IceCandidatePairEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(IceCandidatePairEvent& a, IceCandidatePairEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(IceCandidatePairEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IceCandidatePairEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IceCandidatePairEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IceCandidatePairEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const IceCandidatePairEvent& from);
  void MergeFrom(const IceCandidatePairEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IceCandidatePairEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.IceCandidatePairEvent";
  }
  protected:
  explicit IceCandidatePairEvent(::google::protobuf::Arena* arena);
  IceCandidatePairEvent(::google::protobuf::Arena* arena, const IceCandidatePairEvent& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using IceCandidatePairEventType = IceCandidatePairEvent_IceCandidatePairEventType;
  static constexpr IceCandidatePairEventType UNKNOWN_CHECK_TYPE = IceCandidatePairEvent_IceCandidatePairEventType_UNKNOWN_CHECK_TYPE;
  static constexpr IceCandidatePairEventType CHECK_SENT = IceCandidatePairEvent_IceCandidatePairEventType_CHECK_SENT;
  static constexpr IceCandidatePairEventType CHECK_RECEIVED = IceCandidatePairEvent_IceCandidatePairEventType_CHECK_RECEIVED;
  static constexpr IceCandidatePairEventType CHECK_RESPONSE_SENT = IceCandidatePairEvent_IceCandidatePairEventType_CHECK_RESPONSE_SENT;
  static constexpr IceCandidatePairEventType CHECK_RESPONSE_RECEIVED = IceCandidatePairEvent_IceCandidatePairEventType_CHECK_RESPONSE_RECEIVED;
  static inline bool IceCandidatePairEventType_IsValid(int value) {
    return IceCandidatePairEvent_IceCandidatePairEventType_IsValid(value);
  }
  static constexpr IceCandidatePairEventType IceCandidatePairEventType_MIN = IceCandidatePairEvent_IceCandidatePairEventType_IceCandidatePairEventType_MIN;
  static constexpr IceCandidatePairEventType IceCandidatePairEventType_MAX = IceCandidatePairEvent_IceCandidatePairEventType_IceCandidatePairEventType_MAX;
  static constexpr int IceCandidatePairEventType_ARRAYSIZE = IceCandidatePairEvent_IceCandidatePairEventType_IceCandidatePairEventType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& IceCandidatePairEventType_Name(T value) {
    return IceCandidatePairEvent_IceCandidatePairEventType_Name(value);
  }
  static inline bool IceCandidatePairEventType_Parse(absl::string_view name, IceCandidatePairEventType* value) {
    return IceCandidatePairEvent_IceCandidatePairEventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kCandidatePairIdFieldNumber = 3,
    kTransactionIdFieldNumber = 4,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional .webrtc.rtclog2.IceCandidatePairEvent.IceCandidatePairEventType event_type = 2;
  bool has_event_type() const;
  void clear_event_type() ;
  ::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType event_type() const;
  void set_event_type(::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType value);

  private:
  ::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType _internal_event_type() const;
  void _internal_set_event_type(::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType value);

  public:
  // optional uint32 candidate_pair_id = 3;
  bool has_candidate_pair_id() const;
  void clear_candidate_pair_id() ;
  ::uint32_t candidate_pair_id() const;
  void set_candidate_pair_id(::uint32_t value);

  private:
  ::uint32_t _internal_candidate_pair_id() const;
  void _internal_set_candidate_pair_id(::uint32_t value);

  public:
  // optional uint32 transaction_id = 4;
  bool has_transaction_id() const;
  void clear_transaction_id() ;
  ::uint32_t transaction_id() const;
  void set_transaction_id(::uint32_t value);

  private:
  ::uint32_t _internal_transaction_id() const;
  void _internal_set_transaction_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.IceCandidatePairEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_ms_;
    int event_type_;
    ::uint32_t candidate_pair_id_;
    ::uint32_t transaction_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class IceCandidatePairConfig final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.IceCandidatePairConfig) */ {
 public:
  inline IceCandidatePairConfig() : IceCandidatePairConfig(nullptr) {}
  ~IceCandidatePairConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IceCandidatePairConfig(::google::protobuf::internal::ConstantInitialized);

  inline IceCandidatePairConfig(const IceCandidatePairConfig& from)
      : IceCandidatePairConfig(nullptr, from) {}
  IceCandidatePairConfig(IceCandidatePairConfig&& from) noexcept
    : IceCandidatePairConfig() {
    *this = ::std::move(from);
  }

  inline IceCandidatePairConfig& operator=(const IceCandidatePairConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline IceCandidatePairConfig& operator=(IceCandidatePairConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IceCandidatePairConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const IceCandidatePairConfig* internal_default_instance() {
    return reinterpret_cast<const IceCandidatePairConfig*>(
               &_IceCandidatePairConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(IceCandidatePairConfig& a, IceCandidatePairConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(IceCandidatePairConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IceCandidatePairConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IceCandidatePairConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IceCandidatePairConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const IceCandidatePairConfig& from);
  void MergeFrom(const IceCandidatePairConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IceCandidatePairConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.IceCandidatePairConfig";
  }
  protected:
  explicit IceCandidatePairConfig(::google::protobuf::Arena* arena);
  IceCandidatePairConfig(::google::protobuf::Arena* arena, const IceCandidatePairConfig& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using IceCandidatePairConfigType = IceCandidatePairConfig_IceCandidatePairConfigType;
  static constexpr IceCandidatePairConfigType UNKNOWN_CONFIG_TYPE = IceCandidatePairConfig_IceCandidatePairConfigType_UNKNOWN_CONFIG_TYPE;
  static constexpr IceCandidatePairConfigType ADDED = IceCandidatePairConfig_IceCandidatePairConfigType_ADDED;
  static constexpr IceCandidatePairConfigType UPDATED = IceCandidatePairConfig_IceCandidatePairConfigType_UPDATED;
  static constexpr IceCandidatePairConfigType DESTROYED = IceCandidatePairConfig_IceCandidatePairConfigType_DESTROYED;
  static constexpr IceCandidatePairConfigType SELECTED = IceCandidatePairConfig_IceCandidatePairConfigType_SELECTED;
  static inline bool IceCandidatePairConfigType_IsValid(int value) {
    return IceCandidatePairConfig_IceCandidatePairConfigType_IsValid(value);
  }
  static constexpr IceCandidatePairConfigType IceCandidatePairConfigType_MIN = IceCandidatePairConfig_IceCandidatePairConfigType_IceCandidatePairConfigType_MIN;
  static constexpr IceCandidatePairConfigType IceCandidatePairConfigType_MAX = IceCandidatePairConfig_IceCandidatePairConfigType_IceCandidatePairConfigType_MAX;
  static constexpr int IceCandidatePairConfigType_ARRAYSIZE = IceCandidatePairConfig_IceCandidatePairConfigType_IceCandidatePairConfigType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& IceCandidatePairConfigType_Name(T value) {
    return IceCandidatePairConfig_IceCandidatePairConfigType_Name(value);
  }
  static inline bool IceCandidatePairConfigType_Parse(absl::string_view name, IceCandidatePairConfigType* value) {
    return IceCandidatePairConfig_IceCandidatePairConfigType_Parse(name, value);
  }

  using IceCandidateType = IceCandidatePairConfig_IceCandidateType;
  static constexpr IceCandidateType UNKNOWN_CANDIDATE_TYPE = IceCandidatePairConfig_IceCandidateType_UNKNOWN_CANDIDATE_TYPE;
  static constexpr IceCandidateType LOCAL = IceCandidatePairConfig_IceCandidateType_LOCAL;
  static constexpr IceCandidateType STUN = IceCandidatePairConfig_IceCandidateType_STUN;
  static constexpr IceCandidateType PRFLX = IceCandidatePairConfig_IceCandidateType_PRFLX;
  static constexpr IceCandidateType RELAY = IceCandidatePairConfig_IceCandidateType_RELAY;
  static inline bool IceCandidateType_IsValid(int value) {
    return IceCandidatePairConfig_IceCandidateType_IsValid(value);
  }
  static constexpr IceCandidateType IceCandidateType_MIN = IceCandidatePairConfig_IceCandidateType_IceCandidateType_MIN;
  static constexpr IceCandidateType IceCandidateType_MAX = IceCandidatePairConfig_IceCandidateType_IceCandidateType_MAX;
  static constexpr int IceCandidateType_ARRAYSIZE = IceCandidatePairConfig_IceCandidateType_IceCandidateType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& IceCandidateType_Name(T value) {
    return IceCandidatePairConfig_IceCandidateType_Name(value);
  }
  static inline bool IceCandidateType_Parse(absl::string_view name, IceCandidateType* value) {
    return IceCandidatePairConfig_IceCandidateType_Parse(name, value);
  }

  using Protocol = IceCandidatePairConfig_Protocol;
  static constexpr Protocol UNKNOWN_PROTOCOL = IceCandidatePairConfig_Protocol_UNKNOWN_PROTOCOL;
  static constexpr Protocol UDP = IceCandidatePairConfig_Protocol_UDP;
  static constexpr Protocol TCP = IceCandidatePairConfig_Protocol_TCP;
  static constexpr Protocol SSLTCP = IceCandidatePairConfig_Protocol_SSLTCP;
  static constexpr Protocol TLS = IceCandidatePairConfig_Protocol_TLS;
  static inline bool Protocol_IsValid(int value) {
    return IceCandidatePairConfig_Protocol_IsValid(value);
  }
  static constexpr Protocol Protocol_MIN = IceCandidatePairConfig_Protocol_Protocol_MIN;
  static constexpr Protocol Protocol_MAX = IceCandidatePairConfig_Protocol_Protocol_MAX;
  static constexpr int Protocol_ARRAYSIZE = IceCandidatePairConfig_Protocol_Protocol_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Protocol_Name(T value) {
    return IceCandidatePairConfig_Protocol_Name(value);
  }
  static inline bool Protocol_Parse(absl::string_view name, Protocol* value) {
    return IceCandidatePairConfig_Protocol_Parse(name, value);
  }

  using AddressFamily = IceCandidatePairConfig_AddressFamily;
  static constexpr AddressFamily UNKNOWN_ADDRESS_FAMILY = IceCandidatePairConfig_AddressFamily_UNKNOWN_ADDRESS_FAMILY;
  static constexpr AddressFamily IPV4 = IceCandidatePairConfig_AddressFamily_IPV4;
  static constexpr AddressFamily IPV6 = IceCandidatePairConfig_AddressFamily_IPV6;
  static inline bool AddressFamily_IsValid(int value) {
    return IceCandidatePairConfig_AddressFamily_IsValid(value);
  }
  static constexpr AddressFamily AddressFamily_MIN = IceCandidatePairConfig_AddressFamily_AddressFamily_MIN;
  static constexpr AddressFamily AddressFamily_MAX = IceCandidatePairConfig_AddressFamily_AddressFamily_MAX;
  static constexpr int AddressFamily_ARRAYSIZE = IceCandidatePairConfig_AddressFamily_AddressFamily_ARRAYSIZE;
  template <typename T>
  static inline const std::string& AddressFamily_Name(T value) {
    return IceCandidatePairConfig_AddressFamily_Name(value);
  }
  static inline bool AddressFamily_Parse(absl::string_view name, AddressFamily* value) {
    return IceCandidatePairConfig_AddressFamily_Parse(name, value);
  }

  using NetworkType = IceCandidatePairConfig_NetworkType;
  static constexpr NetworkType UNKNOWN_NETWORK_TYPE = IceCandidatePairConfig_NetworkType_UNKNOWN_NETWORK_TYPE;
  static constexpr NetworkType ETHERNET = IceCandidatePairConfig_NetworkType_ETHERNET;
  static constexpr NetworkType WIFI = IceCandidatePairConfig_NetworkType_WIFI;
  static constexpr NetworkType CELLULAR = IceCandidatePairConfig_NetworkType_CELLULAR;
  static constexpr NetworkType VPN = IceCandidatePairConfig_NetworkType_VPN;
  static constexpr NetworkType LOOPBACK = IceCandidatePairConfig_NetworkType_LOOPBACK;
  static inline bool NetworkType_IsValid(int value) {
    return IceCandidatePairConfig_NetworkType_IsValid(value);
  }
  static constexpr NetworkType NetworkType_MIN = IceCandidatePairConfig_NetworkType_NetworkType_MIN;
  static constexpr NetworkType NetworkType_MAX = IceCandidatePairConfig_NetworkType_NetworkType_MAX;
  static constexpr int NetworkType_ARRAYSIZE = IceCandidatePairConfig_NetworkType_NetworkType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& NetworkType_Name(T value) {
    return IceCandidatePairConfig_NetworkType_Name(value);
  }
  static inline bool NetworkType_Parse(absl::string_view name, NetworkType* value) {
    return IceCandidatePairConfig_NetworkType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kConfigTypeFieldNumber = 2,
    kCandidatePairIdFieldNumber = 3,
    kLocalCandidateTypeFieldNumber = 4,
    kLocalRelayProtocolFieldNumber = 5,
    kLocalNetworkTypeFieldNumber = 6,
    kLocalAddressFamilyFieldNumber = 7,
    kRemoteCandidateTypeFieldNumber = 8,
    kRemoteAddressFamilyFieldNumber = 9,
    kCandidatePairProtocolFieldNumber = 10,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidatePairConfigType config_type = 2;
  bool has_config_type() const;
  void clear_config_type() ;
  ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType config_type() const;
  void set_config_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType value);

  private:
  ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType _internal_config_type() const;
  void _internal_set_config_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType value);

  public:
  // optional uint32 candidate_pair_id = 3;
  bool has_candidate_pair_id() const;
  void clear_candidate_pair_id() ;
  ::uint32_t candidate_pair_id() const;
  void set_candidate_pair_id(::uint32_t value);

  private:
  ::uint32_t _internal_candidate_pair_id() const;
  void _internal_set_candidate_pair_id(::uint32_t value);

  public:
  // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType local_candidate_type = 4;
  bool has_local_candidate_type() const;
  void clear_local_candidate_type() ;
  ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType local_candidate_type() const;
  void set_local_candidate_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType value);

  private:
  ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType _internal_local_candidate_type() const;
  void _internal_set_local_candidate_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType value);

  public:
  // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol local_relay_protocol = 5;
  bool has_local_relay_protocol() const;
  void clear_local_relay_protocol() ;
  ::webrtc::rtclog2::IceCandidatePairConfig_Protocol local_relay_protocol() const;
  void set_local_relay_protocol(::webrtc::rtclog2::IceCandidatePairConfig_Protocol value);

  private:
  ::webrtc::rtclog2::IceCandidatePairConfig_Protocol _internal_local_relay_protocol() const;
  void _internal_set_local_relay_protocol(::webrtc::rtclog2::IceCandidatePairConfig_Protocol value);

  public:
  // optional .webrtc.rtclog2.IceCandidatePairConfig.NetworkType local_network_type = 6;
  bool has_local_network_type() const;
  void clear_local_network_type() ;
  ::webrtc::rtclog2::IceCandidatePairConfig_NetworkType local_network_type() const;
  void set_local_network_type(::webrtc::rtclog2::IceCandidatePairConfig_NetworkType value);

  private:
  ::webrtc::rtclog2::IceCandidatePairConfig_NetworkType _internal_local_network_type() const;
  void _internal_set_local_network_type(::webrtc::rtclog2::IceCandidatePairConfig_NetworkType value);

  public:
  // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily local_address_family = 7;
  bool has_local_address_family() const;
  void clear_local_address_family() ;
  ::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily local_address_family() const;
  void set_local_address_family(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily value);

  private:
  ::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily _internal_local_address_family() const;
  void _internal_set_local_address_family(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily value);

  public:
  // optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType remote_candidate_type = 8;
  bool has_remote_candidate_type() const;
  void clear_remote_candidate_type() ;
  ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType remote_candidate_type() const;
  void set_remote_candidate_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType value);

  private:
  ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType _internal_remote_candidate_type() const;
  void _internal_set_remote_candidate_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType value);

  public:
  // optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily remote_address_family = 9;
  bool has_remote_address_family() const;
  void clear_remote_address_family() ;
  ::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily remote_address_family() const;
  void set_remote_address_family(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily value);

  private:
  ::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily _internal_remote_address_family() const;
  void _internal_set_remote_address_family(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily value);

  public:
  // optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol candidate_pair_protocol = 10;
  bool has_candidate_pair_protocol() const;
  void clear_candidate_pair_protocol() ;
  ::webrtc::rtclog2::IceCandidatePairConfig_Protocol candidate_pair_protocol() const;
  void set_candidate_pair_protocol(::webrtc::rtclog2::IceCandidatePairConfig_Protocol value);

  private:
  ::webrtc::rtclog2::IceCandidatePairConfig_Protocol _internal_candidate_pair_protocol() const;
  void _internal_set_candidate_pair_protocol(::webrtc::rtclog2::IceCandidatePairConfig_Protocol value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.IceCandidatePairConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 8,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_ms_;
    int config_type_;
    ::uint32_t candidate_pair_id_;
    int local_candidate_type_;
    int local_relay_protocol_;
    int local_network_type_;
    int local_address_family_;
    int remote_candidate_type_;
    int remote_address_family_;
    int candidate_pair_protocol_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class GenericPacketSent final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.GenericPacketSent) */ {
 public:
  inline GenericPacketSent() : GenericPacketSent(nullptr) {}
  ~GenericPacketSent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenericPacketSent(::google::protobuf::internal::ConstantInitialized);

  inline GenericPacketSent(const GenericPacketSent& from)
      : GenericPacketSent(nullptr, from) {}
  GenericPacketSent(GenericPacketSent&& from) noexcept
    : GenericPacketSent() {
    *this = ::std::move(from);
  }

  inline GenericPacketSent& operator=(const GenericPacketSent& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericPacketSent& operator=(GenericPacketSent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GenericPacketSent& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericPacketSent* internal_default_instance() {
    return reinterpret_cast<const GenericPacketSent*>(
               &_GenericPacketSent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GenericPacketSent& a, GenericPacketSent& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericPacketSent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericPacketSent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericPacketSent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericPacketSent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const GenericPacketSent& from);
  void MergeFrom(const GenericPacketSent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenericPacketSent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.GenericPacketSent";
  }
  protected:
  explicit GenericPacketSent(::google::protobuf::Arena* arena);
  GenericPacketSent(::google::protobuf::Arena* arena, const GenericPacketSent& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 17,
    kPacketNumberDeltasFieldNumber = 18,
    kOverheadLengthDeltasFieldNumber = 19,
    kPayloadLengthDeltasFieldNumber = 20,
    kPaddingLengthDeltasFieldNumber = 21,
    kTimestampMsFieldNumber = 1,
    kPacketNumberFieldNumber = 2,
    kOverheadLengthFieldNumber = 3,
    kPayloadLengthFieldNumber = 4,
    kPaddingLengthFieldNumber = 5,
    kNumberOfDeltasFieldNumber = 16,
  };
  // optional bytes timestamp_ms_deltas = 17;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes packet_number_deltas = 18;
  bool has_packet_number_deltas() const;
  void clear_packet_number_deltas() ;
  const std::string& packet_number_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_packet_number_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_packet_number_deltas();
  PROTOBUF_NODISCARD std::string* release_packet_number_deltas();
  void set_allocated_packet_number_deltas(std::string* value);

  private:
  const std::string& _internal_packet_number_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packet_number_deltas(
      const std::string& value);
  std::string* _internal_mutable_packet_number_deltas();

  public:
  // optional bytes overhead_length_deltas = 19;
  bool has_overhead_length_deltas() const;
  void clear_overhead_length_deltas() ;
  const std::string& overhead_length_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_overhead_length_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_overhead_length_deltas();
  PROTOBUF_NODISCARD std::string* release_overhead_length_deltas();
  void set_allocated_overhead_length_deltas(std::string* value);

  private:
  const std::string& _internal_overhead_length_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_overhead_length_deltas(
      const std::string& value);
  std::string* _internal_mutable_overhead_length_deltas();

  public:
  // optional bytes payload_length_deltas = 20;
  bool has_payload_length_deltas() const;
  void clear_payload_length_deltas() ;
  const std::string& payload_length_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload_length_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_payload_length_deltas();
  PROTOBUF_NODISCARD std::string* release_payload_length_deltas();
  void set_allocated_payload_length_deltas(std::string* value);

  private:
  const std::string& _internal_payload_length_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_length_deltas(
      const std::string& value);
  std::string* _internal_mutable_payload_length_deltas();

  public:
  // optional bytes padding_length_deltas = 21;
  bool has_padding_length_deltas() const;
  void clear_padding_length_deltas() ;
  const std::string& padding_length_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_padding_length_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_padding_length_deltas();
  PROTOBUF_NODISCARD std::string* release_padding_length_deltas();
  void set_allocated_padding_length_deltas(std::string* value);

  private:
  const std::string& _internal_padding_length_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_padding_length_deltas(
      const std::string& value);
  std::string* _internal_mutable_padding_length_deltas();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional int64 packet_number = 2;
  bool has_packet_number() const;
  void clear_packet_number() ;
  ::int64_t packet_number() const;
  void set_packet_number(::int64_t value);

  private:
  ::int64_t _internal_packet_number() const;
  void _internal_set_packet_number(::int64_t value);

  public:
  // optional int32 overhead_length = 3;
  bool has_overhead_length() const;
  void clear_overhead_length() ;
  ::int32_t overhead_length() const;
  void set_overhead_length(::int32_t value);

  private:
  ::int32_t _internal_overhead_length() const;
  void _internal_set_overhead_length(::int32_t value);

  public:
  // optional int32 payload_length = 4;
  bool has_payload_length() const;
  void clear_payload_length() ;
  ::int32_t payload_length() const;
  void set_payload_length(::int32_t value);

  private:
  ::int32_t _internal_payload_length() const;
  void _internal_set_payload_length(::int32_t value);

  public:
  // optional int32 padding_length = 5;
  bool has_padding_length() const;
  void clear_padding_length() ;
  ::int32_t padding_length() const;
  void set_padding_length(::int32_t value);

  private:
  ::int32_t _internal_padding_length() const;
  void _internal_set_padding_length(::int32_t value);

  public:
  // optional uint32 number_of_deltas = 16;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.GenericPacketSent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 11, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr packet_number_deltas_;
    ::google::protobuf::internal::ArenaStringPtr overhead_length_deltas_;
    ::google::protobuf::internal::ArenaStringPtr payload_length_deltas_;
    ::google::protobuf::internal::ArenaStringPtr padding_length_deltas_;
    ::int64_t timestamp_ms_;
    ::int64_t packet_number_;
    ::int32_t overhead_length_;
    ::int32_t payload_length_;
    ::int32_t padding_length_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class GenericPacketReceived final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.GenericPacketReceived) */ {
 public:
  inline GenericPacketReceived() : GenericPacketReceived(nullptr) {}
  ~GenericPacketReceived() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenericPacketReceived(::google::protobuf::internal::ConstantInitialized);

  inline GenericPacketReceived(const GenericPacketReceived& from)
      : GenericPacketReceived(nullptr, from) {}
  GenericPacketReceived(GenericPacketReceived&& from) noexcept
    : GenericPacketReceived() {
    *this = ::std::move(from);
  }

  inline GenericPacketReceived& operator=(const GenericPacketReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericPacketReceived& operator=(GenericPacketReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GenericPacketReceived& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericPacketReceived* internal_default_instance() {
    return reinterpret_cast<const GenericPacketReceived*>(
               &_GenericPacketReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GenericPacketReceived& a, GenericPacketReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericPacketReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericPacketReceived* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericPacketReceived* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericPacketReceived>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const GenericPacketReceived& from);
  void MergeFrom(const GenericPacketReceived& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenericPacketReceived* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.GenericPacketReceived";
  }
  protected:
  explicit GenericPacketReceived(::google::protobuf::Arena* arena);
  GenericPacketReceived(::google::protobuf::Arena* arena, const GenericPacketReceived& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 17,
    kPacketNumberDeltasFieldNumber = 18,
    kPacketLengthDeltasFieldNumber = 19,
    kTimestampMsFieldNumber = 1,
    kPacketNumberFieldNumber = 2,
    kPacketLengthFieldNumber = 3,
    kNumberOfDeltasFieldNumber = 16,
  };
  // optional bytes timestamp_ms_deltas = 17;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes packet_number_deltas = 18;
  bool has_packet_number_deltas() const;
  void clear_packet_number_deltas() ;
  const std::string& packet_number_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_packet_number_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_packet_number_deltas();
  PROTOBUF_NODISCARD std::string* release_packet_number_deltas();
  void set_allocated_packet_number_deltas(std::string* value);

  private:
  const std::string& _internal_packet_number_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packet_number_deltas(
      const std::string& value);
  std::string* _internal_mutable_packet_number_deltas();

  public:
  // optional bytes packet_length_deltas = 19;
  bool has_packet_length_deltas() const;
  void clear_packet_length_deltas() ;
  const std::string& packet_length_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_packet_length_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_packet_length_deltas();
  PROTOBUF_NODISCARD std::string* release_packet_length_deltas();
  void set_allocated_packet_length_deltas(std::string* value);

  private:
  const std::string& _internal_packet_length_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packet_length_deltas(
      const std::string& value);
  std::string* _internal_mutable_packet_length_deltas();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional int64 packet_number = 2;
  bool has_packet_number() const;
  void clear_packet_number() ;
  ::int64_t packet_number() const;
  void set_packet_number(::int64_t value);

  private:
  ::int64_t _internal_packet_number() const;
  void _internal_set_packet_number(::int64_t value);

  public:
  // optional int32 packet_length = 3;
  bool has_packet_length() const;
  void clear_packet_length() ;
  ::int32_t packet_length() const;
  void set_packet_length(::int32_t value);

  private:
  ::int32_t _internal_packet_length() const;
  void _internal_set_packet_length(::int32_t value);

  public:
  // optional uint32 number_of_deltas = 16;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.GenericPacketReceived)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 7, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr packet_number_deltas_;
    ::google::protobuf::internal::ArenaStringPtr packet_length_deltas_;
    ::int64_t timestamp_ms_;
    ::int64_t packet_number_;
    ::int32_t packet_length_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class GenericAckReceived final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.GenericAckReceived) */ {
 public:
  inline GenericAckReceived() : GenericAckReceived(nullptr) {}
  ~GenericAckReceived() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GenericAckReceived(::google::protobuf::internal::ConstantInitialized);

  inline GenericAckReceived(const GenericAckReceived& from)
      : GenericAckReceived(nullptr, from) {}
  GenericAckReceived(GenericAckReceived&& from) noexcept
    : GenericAckReceived() {
    *this = ::std::move(from);
  }

  inline GenericAckReceived& operator=(const GenericAckReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericAckReceived& operator=(GenericAckReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GenericAckReceived& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericAckReceived* internal_default_instance() {
    return reinterpret_cast<const GenericAckReceived*>(
               &_GenericAckReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GenericAckReceived& a, GenericAckReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericAckReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericAckReceived* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericAckReceived* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericAckReceived>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const GenericAckReceived& from);
  void MergeFrom(const GenericAckReceived& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenericAckReceived* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.GenericAckReceived";
  }
  protected:
  explicit GenericAckReceived(::google::protobuf::Arena* arena);
  GenericAckReceived(::google::protobuf::Arena* arena, const GenericAckReceived& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 17,
    kPacketNumberDeltasFieldNumber = 18,
    kAckedPacketNumberDeltasFieldNumber = 19,
    kReceiveAckedPacketTimeMsDeltasFieldNumber = 20,
    kTimestampMsFieldNumber = 1,
    kPacketNumberFieldNumber = 2,
    kAckedPacketNumberFieldNumber = 3,
    kReceiveAckedPacketTimeMsFieldNumber = 4,
    kNumberOfDeltasFieldNumber = 16,
  };
  // optional bytes timestamp_ms_deltas = 17;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes packet_number_deltas = 18;
  bool has_packet_number_deltas() const;
  void clear_packet_number_deltas() ;
  const std::string& packet_number_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_packet_number_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_packet_number_deltas();
  PROTOBUF_NODISCARD std::string* release_packet_number_deltas();
  void set_allocated_packet_number_deltas(std::string* value);

  private:
  const std::string& _internal_packet_number_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packet_number_deltas(
      const std::string& value);
  std::string* _internal_mutable_packet_number_deltas();

  public:
  // optional bytes acked_packet_number_deltas = 19;
  bool has_acked_packet_number_deltas() const;
  void clear_acked_packet_number_deltas() ;
  const std::string& acked_packet_number_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_acked_packet_number_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_acked_packet_number_deltas();
  PROTOBUF_NODISCARD std::string* release_acked_packet_number_deltas();
  void set_allocated_acked_packet_number_deltas(std::string* value);

  private:
  const std::string& _internal_acked_packet_number_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_acked_packet_number_deltas(
      const std::string& value);
  std::string* _internal_mutable_acked_packet_number_deltas();

  public:
  // optional bytes receive_acked_packet_time_ms_deltas = 20;
  bool has_receive_acked_packet_time_ms_deltas() const;
  void clear_receive_acked_packet_time_ms_deltas() ;
  const std::string& receive_acked_packet_time_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_receive_acked_packet_time_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_receive_acked_packet_time_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_receive_acked_packet_time_ms_deltas();
  void set_allocated_receive_acked_packet_time_ms_deltas(std::string* value);

  private:
  const std::string& _internal_receive_acked_packet_time_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receive_acked_packet_time_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_receive_acked_packet_time_ms_deltas();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional int64 packet_number = 2;
  bool has_packet_number() const;
  void clear_packet_number() ;
  ::int64_t packet_number() const;
  void set_packet_number(::int64_t value);

  private:
  ::int64_t _internal_packet_number() const;
  void _internal_set_packet_number(::int64_t value);

  public:
  // optional int64 acked_packet_number = 3;
  bool has_acked_packet_number() const;
  void clear_acked_packet_number() ;
  ::int64_t acked_packet_number() const;
  void set_acked_packet_number(::int64_t value);

  private:
  ::int64_t _internal_acked_packet_number() const;
  void _internal_set_acked_packet_number(::int64_t value);

  public:
  // optional int64 receive_acked_packet_time_ms = 4;
  bool has_receive_acked_packet_time_ms() const;
  void clear_receive_acked_packet_time_ms() ;
  ::int64_t receive_acked_packet_time_ms() const;
  void set_receive_acked_packet_time_ms(::int64_t value);

  private:
  ::int64_t _internal_receive_acked_packet_time_ms() const;
  void _internal_set_receive_acked_packet_time_ms(::int64_t value);

  public:
  // optional uint32 number_of_deltas = 16;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.GenericAckReceived)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 9, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr packet_number_deltas_;
    ::google::protobuf::internal::ArenaStringPtr acked_packet_number_deltas_;
    ::google::protobuf::internal::ArenaStringPtr receive_acked_packet_time_ms_deltas_;
    ::int64_t timestamp_ms_;
    ::int64_t packet_number_;
    ::int64_t acked_packet_number_;
    ::int64_t receive_acked_packet_time_ms_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class FrameDecodedEvents final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.FrameDecodedEvents) */ {
 public:
  inline FrameDecodedEvents() : FrameDecodedEvents(nullptr) {}
  ~FrameDecodedEvents() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FrameDecodedEvents(::google::protobuf::internal::ConstantInitialized);

  inline FrameDecodedEvents(const FrameDecodedEvents& from)
      : FrameDecodedEvents(nullptr, from) {}
  FrameDecodedEvents(FrameDecodedEvents&& from) noexcept
    : FrameDecodedEvents() {
    *this = ::std::move(from);
  }

  inline FrameDecodedEvents& operator=(const FrameDecodedEvents& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameDecodedEvents& operator=(FrameDecodedEvents&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FrameDecodedEvents& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameDecodedEvents* internal_default_instance() {
    return reinterpret_cast<const FrameDecodedEvents*>(
               &_FrameDecodedEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FrameDecodedEvents& a, FrameDecodedEvents& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameDecodedEvents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameDecodedEvents* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameDecodedEvents* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameDecodedEvents>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const FrameDecodedEvents& from);
  void MergeFrom(const FrameDecodedEvents& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FrameDecodedEvents* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.FrameDecodedEvents";
  }
  protected:
  explicit FrameDecodedEvents(::google::protobuf::Arena* arena);
  FrameDecodedEvents(::google::protobuf::Arena* arena, const FrameDecodedEvents& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Codec = FrameDecodedEvents_Codec;
  static constexpr Codec CODEC_UNKNOWN = FrameDecodedEvents_Codec_CODEC_UNKNOWN;
  static constexpr Codec CODEC_GENERIC = FrameDecodedEvents_Codec_CODEC_GENERIC;
  static constexpr Codec CODEC_VP8 = FrameDecodedEvents_Codec_CODEC_VP8;
  static constexpr Codec CODEC_VP9 = FrameDecodedEvents_Codec_CODEC_VP9;
  static constexpr Codec CODEC_AV1 = FrameDecodedEvents_Codec_CODEC_AV1;
  static constexpr Codec CODEC_H264 = FrameDecodedEvents_Codec_CODEC_H264;
  static inline bool Codec_IsValid(int value) {
    return FrameDecodedEvents_Codec_IsValid(value);
  }
  static constexpr Codec Codec_MIN = FrameDecodedEvents_Codec_Codec_MIN;
  static constexpr Codec Codec_MAX = FrameDecodedEvents_Codec_Codec_MAX;
  static constexpr int Codec_ARRAYSIZE = FrameDecodedEvents_Codec_Codec_ARRAYSIZE;
  template <typename T>
  static inline const std::string& Codec_Name(T value) {
    return FrameDecodedEvents_Codec_Name(value);
  }
  static inline bool Codec_Parse(absl::string_view name, Codec* value) {
    return FrameDecodedEvents_Codec_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 101,
    kSsrcDeltasFieldNumber = 102,
    kRenderTimeMsDeltasFieldNumber = 103,
    kWidthDeltasFieldNumber = 104,
    kHeightDeltasFieldNumber = 105,
    kCodecDeltasFieldNumber = 106,
    kQpDeltasFieldNumber = 107,
    kTimestampMsFieldNumber = 1,
    kRenderTimeMsFieldNumber = 3,
    kSsrcFieldNumber = 2,
    kWidthFieldNumber = 4,
    kHeightFieldNumber = 5,
    kCodecFieldNumber = 6,
    kQpFieldNumber = 7,
    kNumberOfDeltasFieldNumber = 15,
  };
  // optional bytes timestamp_ms_deltas = 101;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes ssrc_deltas = 102;
  bool has_ssrc_deltas() const;
  void clear_ssrc_deltas() ;
  const std::string& ssrc_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ssrc_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_ssrc_deltas();
  PROTOBUF_NODISCARD std::string* release_ssrc_deltas();
  void set_allocated_ssrc_deltas(std::string* value);

  private:
  const std::string& _internal_ssrc_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssrc_deltas(
      const std::string& value);
  std::string* _internal_mutable_ssrc_deltas();

  public:
  // optional bytes render_time_ms_deltas = 103;
  bool has_render_time_ms_deltas() const;
  void clear_render_time_ms_deltas() ;
  const std::string& render_time_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_render_time_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_render_time_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_render_time_ms_deltas();
  void set_allocated_render_time_ms_deltas(std::string* value);

  private:
  const std::string& _internal_render_time_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_render_time_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_render_time_ms_deltas();

  public:
  // optional bytes width_deltas = 104;
  bool has_width_deltas() const;
  void clear_width_deltas() ;
  const std::string& width_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_width_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_width_deltas();
  PROTOBUF_NODISCARD std::string* release_width_deltas();
  void set_allocated_width_deltas(std::string* value);

  private:
  const std::string& _internal_width_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_width_deltas(
      const std::string& value);
  std::string* _internal_mutable_width_deltas();

  public:
  // optional bytes height_deltas = 105;
  bool has_height_deltas() const;
  void clear_height_deltas() ;
  const std::string& height_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_height_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_height_deltas();
  PROTOBUF_NODISCARD std::string* release_height_deltas();
  void set_allocated_height_deltas(std::string* value);

  private:
  const std::string& _internal_height_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_height_deltas(
      const std::string& value);
  std::string* _internal_mutable_height_deltas();

  public:
  // optional bytes codec_deltas = 106;
  bool has_codec_deltas() const;
  void clear_codec_deltas() ;
  const std::string& codec_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_codec_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_codec_deltas();
  PROTOBUF_NODISCARD std::string* release_codec_deltas();
  void set_allocated_codec_deltas(std::string* value);

  private:
  const std::string& _internal_codec_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codec_deltas(
      const std::string& value);
  std::string* _internal_mutable_codec_deltas();

  public:
  // optional bytes qp_deltas = 107;
  bool has_qp_deltas() const;
  void clear_qp_deltas() ;
  const std::string& qp_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_qp_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_qp_deltas();
  PROTOBUF_NODISCARD std::string* release_qp_deltas();
  void set_allocated_qp_deltas(std::string* value);

  private:
  const std::string& _internal_qp_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qp_deltas(
      const std::string& value);
  std::string* _internal_mutable_qp_deltas();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional int64 render_time_ms = 3;
  bool has_render_time_ms() const;
  void clear_render_time_ms() ;
  ::int64_t render_time_ms() const;
  void set_render_time_ms(::int64_t value);

  private:
  ::int64_t _internal_render_time_ms() const;
  void _internal_set_render_time_ms(::int64_t value);

  public:
  // optional fixed32 ssrc = 2;
  bool has_ssrc() const;
  void clear_ssrc() ;
  ::uint32_t ssrc() const;
  void set_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_ssrc() const;
  void _internal_set_ssrc(::uint32_t value);

  public:
  // optional int32 width = 4;
  bool has_width() const;
  void clear_width() ;
  ::int32_t width() const;
  void set_width(::int32_t value);

  private:
  ::int32_t _internal_width() const;
  void _internal_set_width(::int32_t value);

  public:
  // optional int32 height = 5;
  bool has_height() const;
  void clear_height() ;
  ::int32_t height() const;
  void set_height(::int32_t value);

  private:
  ::int32_t _internal_height() const;
  void _internal_set_height(::int32_t value);

  public:
  // optional .webrtc.rtclog2.FrameDecodedEvents.Codec codec = 6;
  bool has_codec() const;
  void clear_codec() ;
  ::webrtc::rtclog2::FrameDecodedEvents_Codec codec() const;
  void set_codec(::webrtc::rtclog2::FrameDecodedEvents_Codec value);

  private:
  ::webrtc::rtclog2::FrameDecodedEvents_Codec _internal_codec() const;
  void _internal_set_codec(::webrtc::rtclog2::FrameDecodedEvents_Codec value);

  public:
  // optional uint32 qp = 7;
  bool has_qp() const;
  void clear_qp() ;
  ::uint32_t qp() const;
  void set_qp(::uint32_t value);

  private:
  ::uint32_t _internal_qp() const;
  void _internal_set_qp(::uint32_t value);

  public:
  // optional uint32 number_of_deltas = 15;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.FrameDecodedEvents)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 1,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr ssrc_deltas_;
    ::google::protobuf::internal::ArenaStringPtr render_time_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr width_deltas_;
    ::google::protobuf::internal::ArenaStringPtr height_deltas_;
    ::google::protobuf::internal::ArenaStringPtr codec_deltas_;
    ::google::protobuf::internal::ArenaStringPtr qp_deltas_;
    ::int64_t timestamp_ms_;
    ::int64_t render_time_ms_;
    ::uint32_t ssrc_;
    ::int32_t width_;
    ::int32_t height_;
    int codec_;
    ::uint32_t qp_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class Event final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Event(::google::protobuf::internal::ConstantInitialized);

  inline Event(const Event& from)
      : Event(nullptr, from) {}
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Event* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.Event";
  }
  protected:
  explicit Event(::google::protobuf::Arena* arena);
  Event(::google::protobuf::Arena* arena, const Event& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.Event)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class EndLogEvent final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.EndLogEvent) */ {
 public:
  inline EndLogEvent() : EndLogEvent(nullptr) {}
  ~EndLogEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EndLogEvent(::google::protobuf::internal::ConstantInitialized);

  inline EndLogEvent(const EndLogEvent& from)
      : EndLogEvent(nullptr, from) {}
  EndLogEvent(EndLogEvent&& from) noexcept
    : EndLogEvent() {
    *this = ::std::move(from);
  }

  inline EndLogEvent& operator=(const EndLogEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EndLogEvent& operator=(EndLogEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EndLogEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const EndLogEvent* internal_default_instance() {
    return reinterpret_cast<const EndLogEvent*>(
               &_EndLogEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(EndLogEvent& a, EndLogEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(EndLogEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EndLogEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EndLogEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EndLogEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const EndLogEvent& from);
  void MergeFrom(const EndLogEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EndLogEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.EndLogEvent";
  }
  protected:
  explicit EndLogEvent(::google::protobuf::Arena* arena);
  EndLogEvent(::google::protobuf::Arena* arena, const EndLogEvent& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.EndLogEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class DtlsWritableState final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.DtlsWritableState) */ {
 public:
  inline DtlsWritableState() : DtlsWritableState(nullptr) {}
  ~DtlsWritableState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DtlsWritableState(::google::protobuf::internal::ConstantInitialized);

  inline DtlsWritableState(const DtlsWritableState& from)
      : DtlsWritableState(nullptr, from) {}
  DtlsWritableState(DtlsWritableState&& from) noexcept
    : DtlsWritableState() {
    *this = ::std::move(from);
  }

  inline DtlsWritableState& operator=(const DtlsWritableState& from) {
    CopyFrom(from);
    return *this;
  }
  inline DtlsWritableState& operator=(DtlsWritableState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DtlsWritableState& default_instance() {
    return *internal_default_instance();
  }
  static inline const DtlsWritableState* internal_default_instance() {
    return reinterpret_cast<const DtlsWritableState*>(
               &_DtlsWritableState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DtlsWritableState& a, DtlsWritableState& b) {
    a.Swap(&b);
  }
  inline void Swap(DtlsWritableState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DtlsWritableState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DtlsWritableState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DtlsWritableState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const DtlsWritableState& from);
  void MergeFrom(const DtlsWritableState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DtlsWritableState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.DtlsWritableState";
  }
  protected:
  explicit DtlsWritableState(::google::protobuf::Arena* arena);
  DtlsWritableState(::google::protobuf::Arena* arena, const DtlsWritableState& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kWritableFieldNumber = 2,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional bool writable = 2;
  bool has_writable() const;
  void clear_writable() ;
  bool writable() const;
  void set_writable(bool value);

  private:
  bool _internal_writable() const;
  void _internal_set_writable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.DtlsWritableState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_ms_;
    bool writable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class DtlsTransportStateEvent final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.DtlsTransportStateEvent) */ {
 public:
  inline DtlsTransportStateEvent() : DtlsTransportStateEvent(nullptr) {}
  ~DtlsTransportStateEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DtlsTransportStateEvent(::google::protobuf::internal::ConstantInitialized);

  inline DtlsTransportStateEvent(const DtlsTransportStateEvent& from)
      : DtlsTransportStateEvent(nullptr, from) {}
  DtlsTransportStateEvent(DtlsTransportStateEvent&& from) noexcept
    : DtlsTransportStateEvent() {
    *this = ::std::move(from);
  }

  inline DtlsTransportStateEvent& operator=(const DtlsTransportStateEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DtlsTransportStateEvent& operator=(DtlsTransportStateEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DtlsTransportStateEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DtlsTransportStateEvent* internal_default_instance() {
    return reinterpret_cast<const DtlsTransportStateEvent*>(
               &_DtlsTransportStateEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DtlsTransportStateEvent& a, DtlsTransportStateEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DtlsTransportStateEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DtlsTransportStateEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DtlsTransportStateEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DtlsTransportStateEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const DtlsTransportStateEvent& from);
  void MergeFrom(const DtlsTransportStateEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DtlsTransportStateEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.DtlsTransportStateEvent";
  }
  protected:
  explicit DtlsTransportStateEvent(::google::protobuf::Arena* arena);
  DtlsTransportStateEvent(::google::protobuf::Arena* arena, const DtlsTransportStateEvent& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using DtlsTransportState = DtlsTransportStateEvent_DtlsTransportState;
  static constexpr DtlsTransportState UNKNOWN_DTLS_TRANSPORT_STATE = DtlsTransportStateEvent_DtlsTransportState_UNKNOWN_DTLS_TRANSPORT_STATE;
  static constexpr DtlsTransportState DTLS_TRANSPORT_NEW = DtlsTransportStateEvent_DtlsTransportState_DTLS_TRANSPORT_NEW;
  static constexpr DtlsTransportState DTLS_TRANSPORT_CONNECTING = DtlsTransportStateEvent_DtlsTransportState_DTLS_TRANSPORT_CONNECTING;
  static constexpr DtlsTransportState DTLS_TRANSPORT_CONNECTED = DtlsTransportStateEvent_DtlsTransportState_DTLS_TRANSPORT_CONNECTED;
  static constexpr DtlsTransportState DTLS_TRANSPORT_CLOSED = DtlsTransportStateEvent_DtlsTransportState_DTLS_TRANSPORT_CLOSED;
  static constexpr DtlsTransportState DTLS_TRANSPORT_FAILED = DtlsTransportStateEvent_DtlsTransportState_DTLS_TRANSPORT_FAILED;
  static inline bool DtlsTransportState_IsValid(int value) {
    return DtlsTransportStateEvent_DtlsTransportState_IsValid(value);
  }
  static constexpr DtlsTransportState DtlsTransportState_MIN = DtlsTransportStateEvent_DtlsTransportState_DtlsTransportState_MIN;
  static constexpr DtlsTransportState DtlsTransportState_MAX = DtlsTransportStateEvent_DtlsTransportState_DtlsTransportState_MAX;
  static constexpr int DtlsTransportState_ARRAYSIZE = DtlsTransportStateEvent_DtlsTransportState_DtlsTransportState_ARRAYSIZE;
  template <typename T>
  static inline const std::string& DtlsTransportState_Name(T value) {
    return DtlsTransportStateEvent_DtlsTransportState_Name(value);
  }
  static inline bool DtlsTransportState_Parse(absl::string_view name, DtlsTransportState* value) {
    return DtlsTransportStateEvent_DtlsTransportState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kDtlsTransportStateFieldNumber = 2,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional .webrtc.rtclog2.DtlsTransportStateEvent.DtlsTransportState dtls_transport_state = 2;
  bool has_dtls_transport_state() const;
  void clear_dtls_transport_state() ;
  ::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState dtls_transport_state() const;
  void set_dtls_transport_state(::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState value);

  private:
  ::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState _internal_dtls_transport_state() const;
  void _internal_set_dtls_transport_state(::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.DtlsTransportStateEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_ms_;
    int dtls_transport_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class DependencyDescriptorsWireInfo final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.DependencyDescriptorsWireInfo) */ {
 public:
  inline DependencyDescriptorsWireInfo() : DependencyDescriptorsWireInfo(nullptr) {}
  ~DependencyDescriptorsWireInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DependencyDescriptorsWireInfo(::google::protobuf::internal::ConstantInitialized);

  inline DependencyDescriptorsWireInfo(const DependencyDescriptorsWireInfo& from)
      : DependencyDescriptorsWireInfo(nullptr, from) {}
  DependencyDescriptorsWireInfo(DependencyDescriptorsWireInfo&& from) noexcept
    : DependencyDescriptorsWireInfo() {
    *this = ::std::move(from);
  }

  inline DependencyDescriptorsWireInfo& operator=(const DependencyDescriptorsWireInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DependencyDescriptorsWireInfo& operator=(DependencyDescriptorsWireInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DependencyDescriptorsWireInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DependencyDescriptorsWireInfo* internal_default_instance() {
    return reinterpret_cast<const DependencyDescriptorsWireInfo*>(
               &_DependencyDescriptorsWireInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DependencyDescriptorsWireInfo& a, DependencyDescriptorsWireInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DependencyDescriptorsWireInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DependencyDescriptorsWireInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DependencyDescriptorsWireInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DependencyDescriptorsWireInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const DependencyDescriptorsWireInfo& from);
  void MergeFrom(const DependencyDescriptorsWireInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DependencyDescriptorsWireInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.DependencyDescriptorsWireInfo";
  }
  protected:
  explicit DependencyDescriptorsWireInfo(::google::protobuf::Arena* arena);
  DependencyDescriptorsWireInfo(::google::protobuf::Arena* arena, const DependencyDescriptorsWireInfo& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartEndBitDeltasFieldNumber = 2,
    kTemplateIdDeltasFieldNumber = 4,
    kFrameIdDeltasFieldNumber = 6,
    kExtendedInfosFieldNumber = 7,
    kStartEndBitFieldNumber = 1,
    kTemplateIdFieldNumber = 3,
    kFrameIdFieldNumber = 5,
  };
  // optional bytes start_end_bit_deltas = 2;
  bool has_start_end_bit_deltas() const;
  void clear_start_end_bit_deltas() ;
  const std::string& start_end_bit_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_end_bit_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_start_end_bit_deltas();
  PROTOBUF_NODISCARD std::string* release_start_end_bit_deltas();
  void set_allocated_start_end_bit_deltas(std::string* value);

  private:
  const std::string& _internal_start_end_bit_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_end_bit_deltas(
      const std::string& value);
  std::string* _internal_mutable_start_end_bit_deltas();

  public:
  // optional bytes template_id_deltas = 4;
  bool has_template_id_deltas() const;
  void clear_template_id_deltas() ;
  const std::string& template_id_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_template_id_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_template_id_deltas();
  PROTOBUF_NODISCARD std::string* release_template_id_deltas();
  void set_allocated_template_id_deltas(std::string* value);

  private:
  const std::string& _internal_template_id_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_template_id_deltas(
      const std::string& value);
  std::string* _internal_mutable_template_id_deltas();

  public:
  // optional bytes frame_id_deltas = 6;
  bool has_frame_id_deltas() const;
  void clear_frame_id_deltas() ;
  const std::string& frame_id_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_frame_id_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_frame_id_deltas();
  PROTOBUF_NODISCARD std::string* release_frame_id_deltas();
  void set_allocated_frame_id_deltas(std::string* value);

  private:
  const std::string& _internal_frame_id_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_id_deltas(
      const std::string& value);
  std::string* _internal_mutable_frame_id_deltas();

  public:
  // optional bytes extended_infos = 7;
  bool has_extended_infos() const;
  void clear_extended_infos() ;
  const std::string& extended_infos() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extended_infos(Arg_&& arg, Args_... args);
  std::string* mutable_extended_infos();
  PROTOBUF_NODISCARD std::string* release_extended_infos();
  void set_allocated_extended_infos(std::string* value);

  private:
  const std::string& _internal_extended_infos() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extended_infos(
      const std::string& value);
  std::string* _internal_mutable_extended_infos();

  public:
  // optional uint32 start_end_bit = 1;
  bool has_start_end_bit() const;
  void clear_start_end_bit() ;
  ::uint32_t start_end_bit() const;
  void set_start_end_bit(::uint32_t value);

  private:
  ::uint32_t _internal_start_end_bit() const;
  void _internal_set_start_end_bit(::uint32_t value);

  public:
  // optional uint32 template_id = 3;
  bool has_template_id() const;
  void clear_template_id() ;
  ::uint32_t template_id() const;
  void set_template_id(::uint32_t value);

  private:
  ::uint32_t _internal_template_id() const;
  void _internal_set_template_id(::uint32_t value);

  public:
  // optional uint32 frame_id = 5;
  bool has_frame_id() const;
  void clear_frame_id() ;
  ::uint32_t frame_id() const;
  void set_frame_id(::uint32_t value);

  private:
  ::uint32_t _internal_frame_id() const;
  void _internal_set_frame_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.DependencyDescriptorsWireInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr start_end_bit_deltas_;
    ::google::protobuf::internal::ArenaStringPtr template_id_deltas_;
    ::google::protobuf::internal::ArenaStringPtr frame_id_deltas_;
    ::google::protobuf::internal::ArenaStringPtr extended_infos_;
    ::uint32_t start_end_bit_;
    ::uint32_t template_id_;
    ::uint32_t frame_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class DelayBasedBweUpdates final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.DelayBasedBweUpdates) */ {
 public:
  inline DelayBasedBweUpdates() : DelayBasedBweUpdates(nullptr) {}
  ~DelayBasedBweUpdates() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DelayBasedBweUpdates(::google::protobuf::internal::ConstantInitialized);

  inline DelayBasedBweUpdates(const DelayBasedBweUpdates& from)
      : DelayBasedBweUpdates(nullptr, from) {}
  DelayBasedBweUpdates(DelayBasedBweUpdates&& from) noexcept
    : DelayBasedBweUpdates() {
    *this = ::std::move(from);
  }

  inline DelayBasedBweUpdates& operator=(const DelayBasedBweUpdates& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelayBasedBweUpdates& operator=(DelayBasedBweUpdates&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DelayBasedBweUpdates& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelayBasedBweUpdates* internal_default_instance() {
    return reinterpret_cast<const DelayBasedBweUpdates*>(
               &_DelayBasedBweUpdates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DelayBasedBweUpdates& a, DelayBasedBweUpdates& b) {
    a.Swap(&b);
  }
  inline void Swap(DelayBasedBweUpdates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelayBasedBweUpdates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelayBasedBweUpdates* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DelayBasedBweUpdates>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const DelayBasedBweUpdates& from);
  void MergeFrom(const DelayBasedBweUpdates& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DelayBasedBweUpdates* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.DelayBasedBweUpdates";
  }
  protected:
  explicit DelayBasedBweUpdates(::google::protobuf::Arena* arena);
  DelayBasedBweUpdates(::google::protobuf::Arena* arena, const DelayBasedBweUpdates& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using DetectorState = DelayBasedBweUpdates_DetectorState;
  static constexpr DetectorState BWE_UNKNOWN_STATE = DelayBasedBweUpdates_DetectorState_BWE_UNKNOWN_STATE;
  static constexpr DetectorState BWE_NORMAL = DelayBasedBweUpdates_DetectorState_BWE_NORMAL;
  static constexpr DetectorState BWE_UNDERUSING = DelayBasedBweUpdates_DetectorState_BWE_UNDERUSING;
  static constexpr DetectorState BWE_OVERUSING = DelayBasedBweUpdates_DetectorState_BWE_OVERUSING;
  static inline bool DetectorState_IsValid(int value) {
    return DelayBasedBweUpdates_DetectorState_IsValid(value);
  }
  static constexpr DetectorState DetectorState_MIN = DelayBasedBweUpdates_DetectorState_DetectorState_MIN;
  static constexpr DetectorState DetectorState_MAX = DelayBasedBweUpdates_DetectorState_DetectorState_MAX;
  static constexpr int DetectorState_ARRAYSIZE = DelayBasedBweUpdates_DetectorState_DetectorState_ARRAYSIZE;
  template <typename T>
  static inline const std::string& DetectorState_Name(T value) {
    return DelayBasedBweUpdates_DetectorState_Name(value);
  }
  static inline bool DetectorState_Parse(absl::string_view name, DetectorState* value) {
    return DelayBasedBweUpdates_DetectorState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 101,
    kBitrateBpsDeltasFieldNumber = 102,
    kDetectorStateDeltasFieldNumber = 103,
    kTimestampMsFieldNumber = 1,
    kBitrateBpsFieldNumber = 2,
    kDetectorStateFieldNumber = 3,
    kNumberOfDeltasFieldNumber = 4,
  };
  // optional bytes timestamp_ms_deltas = 101;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes bitrate_bps_deltas = 102;
  bool has_bitrate_bps_deltas() const;
  void clear_bitrate_bps_deltas() ;
  const std::string& bitrate_bps_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bitrate_bps_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_bitrate_bps_deltas();
  PROTOBUF_NODISCARD std::string* release_bitrate_bps_deltas();
  void set_allocated_bitrate_bps_deltas(std::string* value);

  private:
  const std::string& _internal_bitrate_bps_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bitrate_bps_deltas(
      const std::string& value);
  std::string* _internal_mutable_bitrate_bps_deltas();

  public:
  // optional bytes detector_state_deltas = 103;
  bool has_detector_state_deltas() const;
  void clear_detector_state_deltas() ;
  const std::string& detector_state_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_detector_state_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_detector_state_deltas();
  PROTOBUF_NODISCARD std::string* release_detector_state_deltas();
  void set_allocated_detector_state_deltas(std::string* value);

  private:
  const std::string& _internal_detector_state_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detector_state_deltas(
      const std::string& value);
  std::string* _internal_mutable_detector_state_deltas();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 bitrate_bps = 2;
  bool has_bitrate_bps() const;
  void clear_bitrate_bps() ;
  ::uint32_t bitrate_bps() const;
  void set_bitrate_bps(::uint32_t value);

  private:
  ::uint32_t _internal_bitrate_bps() const;
  void _internal_set_bitrate_bps(::uint32_t value);

  public:
  // optional .webrtc.rtclog2.DelayBasedBweUpdates.DetectorState detector_state = 3;
  bool has_detector_state() const;
  void clear_detector_state() ;
  ::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState detector_state() const;
  void set_detector_state(::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState value);

  private:
  ::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState _internal_detector_state() const;
  void _internal_set_detector_state(::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState value);

  public:
  // optional uint32 number_of_deltas = 4;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.DelayBasedBweUpdates)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr bitrate_bps_deltas_;
    ::google::protobuf::internal::ArenaStringPtr detector_state_deltas_;
    ::int64_t timestamp_ms_;
    ::uint32_t bitrate_bps_;
    int detector_state_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class BweProbeResultSuccess final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.BweProbeResultSuccess) */ {
 public:
  inline BweProbeResultSuccess() : BweProbeResultSuccess(nullptr) {}
  ~BweProbeResultSuccess() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BweProbeResultSuccess(::google::protobuf::internal::ConstantInitialized);

  inline BweProbeResultSuccess(const BweProbeResultSuccess& from)
      : BweProbeResultSuccess(nullptr, from) {}
  BweProbeResultSuccess(BweProbeResultSuccess&& from) noexcept
    : BweProbeResultSuccess() {
    *this = ::std::move(from);
  }

  inline BweProbeResultSuccess& operator=(const BweProbeResultSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline BweProbeResultSuccess& operator=(BweProbeResultSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BweProbeResultSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const BweProbeResultSuccess* internal_default_instance() {
    return reinterpret_cast<const BweProbeResultSuccess*>(
               &_BweProbeResultSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(BweProbeResultSuccess& a, BweProbeResultSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(BweProbeResultSuccess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BweProbeResultSuccess* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BweProbeResultSuccess* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BweProbeResultSuccess>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const BweProbeResultSuccess& from);
  void MergeFrom(const BweProbeResultSuccess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BweProbeResultSuccess* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.BweProbeResultSuccess";
  }
  protected:
  explicit BweProbeResultSuccess(::google::protobuf::Arena* arena);
  BweProbeResultSuccess(::google::protobuf::Arena* arena, const BweProbeResultSuccess& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kIdFieldNumber = 2,
    kBitrateBpsFieldNumber = 3,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 id = 2;
  bool has_id() const;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // optional uint32 bitrate_bps = 3;
  bool has_bitrate_bps() const;
  void clear_bitrate_bps() ;
  ::uint32_t bitrate_bps() const;
  void set_bitrate_bps(::uint32_t value);

  private:
  ::uint32_t _internal_bitrate_bps() const;
  void _internal_set_bitrate_bps(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.BweProbeResultSuccess)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_ms_;
    ::uint32_t id_;
    ::uint32_t bitrate_bps_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class BweProbeResultFailure final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.BweProbeResultFailure) */ {
 public:
  inline BweProbeResultFailure() : BweProbeResultFailure(nullptr) {}
  ~BweProbeResultFailure() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BweProbeResultFailure(::google::protobuf::internal::ConstantInitialized);

  inline BweProbeResultFailure(const BweProbeResultFailure& from)
      : BweProbeResultFailure(nullptr, from) {}
  BweProbeResultFailure(BweProbeResultFailure&& from) noexcept
    : BweProbeResultFailure() {
    *this = ::std::move(from);
  }

  inline BweProbeResultFailure& operator=(const BweProbeResultFailure& from) {
    CopyFrom(from);
    return *this;
  }
  inline BweProbeResultFailure& operator=(BweProbeResultFailure&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BweProbeResultFailure& default_instance() {
    return *internal_default_instance();
  }
  static inline const BweProbeResultFailure* internal_default_instance() {
    return reinterpret_cast<const BweProbeResultFailure*>(
               &_BweProbeResultFailure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(BweProbeResultFailure& a, BweProbeResultFailure& b) {
    a.Swap(&b);
  }
  inline void Swap(BweProbeResultFailure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BweProbeResultFailure* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BweProbeResultFailure* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BweProbeResultFailure>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const BweProbeResultFailure& from);
  void MergeFrom(const BweProbeResultFailure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BweProbeResultFailure* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.BweProbeResultFailure";
  }
  protected:
  explicit BweProbeResultFailure(::google::protobuf::Arena* arena);
  BweProbeResultFailure(::google::protobuf::Arena* arena, const BweProbeResultFailure& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using FailureReason = BweProbeResultFailure_FailureReason;
  static constexpr FailureReason UNKNOWN = BweProbeResultFailure_FailureReason_UNKNOWN;
  static constexpr FailureReason INVALID_SEND_RECEIVE_INTERVAL = BweProbeResultFailure_FailureReason_INVALID_SEND_RECEIVE_INTERVAL;
  static constexpr FailureReason INVALID_SEND_RECEIVE_RATIO = BweProbeResultFailure_FailureReason_INVALID_SEND_RECEIVE_RATIO;
  static constexpr FailureReason TIMEOUT = BweProbeResultFailure_FailureReason_TIMEOUT;
  static inline bool FailureReason_IsValid(int value) {
    return BweProbeResultFailure_FailureReason_IsValid(value);
  }
  static constexpr FailureReason FailureReason_MIN = BweProbeResultFailure_FailureReason_FailureReason_MIN;
  static constexpr FailureReason FailureReason_MAX = BweProbeResultFailure_FailureReason_FailureReason_MAX;
  static constexpr int FailureReason_ARRAYSIZE = BweProbeResultFailure_FailureReason_FailureReason_ARRAYSIZE;
  template <typename T>
  static inline const std::string& FailureReason_Name(T value) {
    return BweProbeResultFailure_FailureReason_Name(value);
  }
  static inline bool FailureReason_Parse(absl::string_view name, FailureReason* value) {
    return BweProbeResultFailure_FailureReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kIdFieldNumber = 2,
    kFailureFieldNumber = 3,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 id = 2;
  bool has_id() const;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // optional .webrtc.rtclog2.BweProbeResultFailure.FailureReason failure = 3;
  bool has_failure() const;
  void clear_failure() ;
  ::webrtc::rtclog2::BweProbeResultFailure_FailureReason failure() const;
  void set_failure(::webrtc::rtclog2::BweProbeResultFailure_FailureReason value);

  private:
  ::webrtc::rtclog2::BweProbeResultFailure_FailureReason _internal_failure() const;
  void _internal_set_failure(::webrtc::rtclog2::BweProbeResultFailure_FailureReason value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.BweProbeResultFailure)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_ms_;
    ::uint32_t id_;
    int failure_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class BweProbeCluster final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.BweProbeCluster) */ {
 public:
  inline BweProbeCluster() : BweProbeCluster(nullptr) {}
  ~BweProbeCluster() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BweProbeCluster(::google::protobuf::internal::ConstantInitialized);

  inline BweProbeCluster(const BweProbeCluster& from)
      : BweProbeCluster(nullptr, from) {}
  BweProbeCluster(BweProbeCluster&& from) noexcept
    : BweProbeCluster() {
    *this = ::std::move(from);
  }

  inline BweProbeCluster& operator=(const BweProbeCluster& from) {
    CopyFrom(from);
    return *this;
  }
  inline BweProbeCluster& operator=(BweProbeCluster&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BweProbeCluster& default_instance() {
    return *internal_default_instance();
  }
  static inline const BweProbeCluster* internal_default_instance() {
    return reinterpret_cast<const BweProbeCluster*>(
               &_BweProbeCluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(BweProbeCluster& a, BweProbeCluster& b) {
    a.Swap(&b);
  }
  inline void Swap(BweProbeCluster* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BweProbeCluster* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BweProbeCluster* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BweProbeCluster>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const BweProbeCluster& from);
  void MergeFrom(const BweProbeCluster& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BweProbeCluster* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.BweProbeCluster";
  }
  protected:
  explicit BweProbeCluster(::google::protobuf::Arena* arena);
  BweProbeCluster(::google::protobuf::Arena* arena, const BweProbeCluster& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kIdFieldNumber = 2,
    kBitrateBpsFieldNumber = 3,
    kMinPacketsFieldNumber = 4,
    kMinBytesFieldNumber = 5,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 id = 2;
  bool has_id() const;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // optional uint32 bitrate_bps = 3;
  bool has_bitrate_bps() const;
  void clear_bitrate_bps() ;
  ::uint32_t bitrate_bps() const;
  void set_bitrate_bps(::uint32_t value);

  private:
  ::uint32_t _internal_bitrate_bps() const;
  void _internal_set_bitrate_bps(::uint32_t value);

  public:
  // optional uint32 min_packets = 4;
  bool has_min_packets() const;
  void clear_min_packets() ;
  ::uint32_t min_packets() const;
  void set_min_packets(::uint32_t value);

  private:
  ::uint32_t _internal_min_packets() const;
  void _internal_set_min_packets(::uint32_t value);

  public:
  // optional uint32 min_bytes = 5;
  bool has_min_bytes() const;
  void clear_min_bytes() ;
  ::uint32_t min_bytes() const;
  void set_min_bytes(::uint32_t value);

  private:
  ::uint32_t _internal_min_bytes() const;
  void _internal_set_min_bytes(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.BweProbeCluster)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_ms_;
    ::uint32_t id_;
    ::uint32_t bitrate_bps_;
    ::uint32_t min_packets_;
    ::uint32_t min_bytes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class BeginLogEvent final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.BeginLogEvent) */ {
 public:
  inline BeginLogEvent() : BeginLogEvent(nullptr) {}
  ~BeginLogEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BeginLogEvent(::google::protobuf::internal::ConstantInitialized);

  inline BeginLogEvent(const BeginLogEvent& from)
      : BeginLogEvent(nullptr, from) {}
  BeginLogEvent(BeginLogEvent&& from) noexcept
    : BeginLogEvent() {
    *this = ::std::move(from);
  }

  inline BeginLogEvent& operator=(const BeginLogEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeginLogEvent& operator=(BeginLogEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BeginLogEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeginLogEvent* internal_default_instance() {
    return reinterpret_cast<const BeginLogEvent*>(
               &_BeginLogEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BeginLogEvent& a, BeginLogEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BeginLogEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeginLogEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeginLogEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeginLogEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const BeginLogEvent& from);
  void MergeFrom(const BeginLogEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BeginLogEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.BeginLogEvent";
  }
  protected:
  explicit BeginLogEvent(::google::protobuf::Arena* arena);
  BeginLogEvent(::google::protobuf::Arena* arena, const BeginLogEvent& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kUtcTimeMsFieldNumber = 3,
    kVersionFieldNumber = 2,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional int64 utc_time_ms = 3;
  bool has_utc_time_ms() const;
  void clear_utc_time_ms() ;
  ::int64_t utc_time_ms() const;
  void set_utc_time_ms(::int64_t value);

  private:
  ::int64_t _internal_utc_time_ms() const;
  void _internal_set_utc_time_ms(::int64_t value);

  public:
  // optional uint32 version = 2;
  bool has_version() const;
  void clear_version() ;
  ::uint32_t version() const;
  void set_version(::uint32_t value);

  private:
  ::uint32_t _internal_version() const;
  void _internal_set_version(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.BeginLogEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_ms_;
    ::int64_t utc_time_ms_;
    ::uint32_t version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class AudioPlayoutEvents final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.AudioPlayoutEvents) */ {
 public:
  inline AudioPlayoutEvents() : AudioPlayoutEvents(nullptr) {}
  ~AudioPlayoutEvents() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AudioPlayoutEvents(::google::protobuf::internal::ConstantInitialized);

  inline AudioPlayoutEvents(const AudioPlayoutEvents& from)
      : AudioPlayoutEvents(nullptr, from) {}
  AudioPlayoutEvents(AudioPlayoutEvents&& from) noexcept
    : AudioPlayoutEvents() {
    *this = ::std::move(from);
  }

  inline AudioPlayoutEvents& operator=(const AudioPlayoutEvents& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioPlayoutEvents& operator=(AudioPlayoutEvents&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioPlayoutEvents& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioPlayoutEvents* internal_default_instance() {
    return reinterpret_cast<const AudioPlayoutEvents*>(
               &_AudioPlayoutEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AudioPlayoutEvents& a, AudioPlayoutEvents& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioPlayoutEvents* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioPlayoutEvents* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioPlayoutEvents* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioPlayoutEvents>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const AudioPlayoutEvents& from);
  void MergeFrom(const AudioPlayoutEvents& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AudioPlayoutEvents* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.AudioPlayoutEvents";
  }
  protected:
  explicit AudioPlayoutEvents(::google::protobuf::Arena* arena);
  AudioPlayoutEvents(::google::protobuf::Arena* arena, const AudioPlayoutEvents& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 101,
    kLocalSsrcDeltasFieldNumber = 102,
    kTimestampMsFieldNumber = 1,
    kLocalSsrcFieldNumber = 2,
    kNumberOfDeltasFieldNumber = 3,
  };
  // optional bytes timestamp_ms_deltas = 101;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes local_ssrc_deltas = 102;
  bool has_local_ssrc_deltas() const;
  void clear_local_ssrc_deltas() ;
  const std::string& local_ssrc_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_local_ssrc_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_local_ssrc_deltas();
  PROTOBUF_NODISCARD std::string* release_local_ssrc_deltas();
  void set_allocated_local_ssrc_deltas(std::string* value);

  private:
  const std::string& _internal_local_ssrc_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_ssrc_deltas(
      const std::string& value);
  std::string* _internal_mutable_local_ssrc_deltas();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 local_ssrc = 2;
  bool has_local_ssrc() const;
  void clear_local_ssrc() ;
  ::uint32_t local_ssrc() const;
  void set_local_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_local_ssrc() const;
  void _internal_set_local_ssrc(::uint32_t value);

  public:
  // optional uint32 number_of_deltas = 3;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.AudioPlayoutEvents)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr local_ssrc_deltas_;
    ::int64_t timestamp_ms_;
    ::uint32_t local_ssrc_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class AudioNetworkAdaptations final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.AudioNetworkAdaptations) */ {
 public:
  inline AudioNetworkAdaptations() : AudioNetworkAdaptations(nullptr) {}
  ~AudioNetworkAdaptations() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AudioNetworkAdaptations(::google::protobuf::internal::ConstantInitialized);

  inline AudioNetworkAdaptations(const AudioNetworkAdaptations& from)
      : AudioNetworkAdaptations(nullptr, from) {}
  AudioNetworkAdaptations(AudioNetworkAdaptations&& from) noexcept
    : AudioNetworkAdaptations() {
    *this = ::std::move(from);
  }

  inline AudioNetworkAdaptations& operator=(const AudioNetworkAdaptations& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioNetworkAdaptations& operator=(AudioNetworkAdaptations&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioNetworkAdaptations& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioNetworkAdaptations* internal_default_instance() {
    return reinterpret_cast<const AudioNetworkAdaptations*>(
               &_AudioNetworkAdaptations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(AudioNetworkAdaptations& a, AudioNetworkAdaptations& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioNetworkAdaptations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioNetworkAdaptations* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioNetworkAdaptations* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioNetworkAdaptations>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const AudioNetworkAdaptations& from);
  void MergeFrom(const AudioNetworkAdaptations& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AudioNetworkAdaptations* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.AudioNetworkAdaptations";
  }
  protected:
  explicit AudioNetworkAdaptations(::google::protobuf::Arena* arena);
  AudioNetworkAdaptations(::google::protobuf::Arena* arena, const AudioNetworkAdaptations& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 101,
    kBitrateBpsDeltasFieldNumber = 102,
    kFrameLengthMsDeltasFieldNumber = 103,
    kUplinkPacketLossFractionDeltasFieldNumber = 104,
    kEnableFecDeltasFieldNumber = 105,
    kEnableDtxDeltasFieldNumber = 106,
    kNumChannelsDeltasFieldNumber = 107,
    kTimestampMsFieldNumber = 1,
    kBitrateBpsFieldNumber = 2,
    kFrameLengthMsFieldNumber = 3,
    kUplinkPacketLossFractionFieldNumber = 4,
    kEnableFecFieldNumber = 5,
    kEnableDtxFieldNumber = 6,
    kNumChannelsFieldNumber = 7,
    kNumberOfDeltasFieldNumber = 8,
  };
  // optional bytes timestamp_ms_deltas = 101;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes bitrate_bps_deltas = 102;
  bool has_bitrate_bps_deltas() const;
  void clear_bitrate_bps_deltas() ;
  const std::string& bitrate_bps_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bitrate_bps_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_bitrate_bps_deltas();
  PROTOBUF_NODISCARD std::string* release_bitrate_bps_deltas();
  void set_allocated_bitrate_bps_deltas(std::string* value);

  private:
  const std::string& _internal_bitrate_bps_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bitrate_bps_deltas(
      const std::string& value);
  std::string* _internal_mutable_bitrate_bps_deltas();

  public:
  // optional bytes frame_length_ms_deltas = 103;
  bool has_frame_length_ms_deltas() const;
  void clear_frame_length_ms_deltas() ;
  const std::string& frame_length_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_frame_length_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_frame_length_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_frame_length_ms_deltas();
  void set_allocated_frame_length_ms_deltas(std::string* value);

  private:
  const std::string& _internal_frame_length_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame_length_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_frame_length_ms_deltas();

  public:
  // optional bytes uplink_packet_loss_fraction_deltas = 104;
  bool has_uplink_packet_loss_fraction_deltas() const;
  void clear_uplink_packet_loss_fraction_deltas() ;
  const std::string& uplink_packet_loss_fraction_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uplink_packet_loss_fraction_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_uplink_packet_loss_fraction_deltas();
  PROTOBUF_NODISCARD std::string* release_uplink_packet_loss_fraction_deltas();
  void set_allocated_uplink_packet_loss_fraction_deltas(std::string* value);

  private:
  const std::string& _internal_uplink_packet_loss_fraction_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uplink_packet_loss_fraction_deltas(
      const std::string& value);
  std::string* _internal_mutable_uplink_packet_loss_fraction_deltas();

  public:
  // optional bytes enable_fec_deltas = 105;
  bool has_enable_fec_deltas() const;
  void clear_enable_fec_deltas() ;
  const std::string& enable_fec_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_enable_fec_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_enable_fec_deltas();
  PROTOBUF_NODISCARD std::string* release_enable_fec_deltas();
  void set_allocated_enable_fec_deltas(std::string* value);

  private:
  const std::string& _internal_enable_fec_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enable_fec_deltas(
      const std::string& value);
  std::string* _internal_mutable_enable_fec_deltas();

  public:
  // optional bytes enable_dtx_deltas = 106;
  bool has_enable_dtx_deltas() const;
  void clear_enable_dtx_deltas() ;
  const std::string& enable_dtx_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_enable_dtx_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_enable_dtx_deltas();
  PROTOBUF_NODISCARD std::string* release_enable_dtx_deltas();
  void set_allocated_enable_dtx_deltas(std::string* value);

  private:
  const std::string& _internal_enable_dtx_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enable_dtx_deltas(
      const std::string& value);
  std::string* _internal_mutable_enable_dtx_deltas();

  public:
  // optional bytes num_channels_deltas = 107;
  bool has_num_channels_deltas() const;
  void clear_num_channels_deltas() ;
  const std::string& num_channels_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_num_channels_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_num_channels_deltas();
  PROTOBUF_NODISCARD std::string* release_num_channels_deltas();
  void set_allocated_num_channels_deltas(std::string* value);

  private:
  const std::string& _internal_num_channels_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_num_channels_deltas(
      const std::string& value);
  std::string* _internal_mutable_num_channels_deltas();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional int32 bitrate_bps = 2;
  bool has_bitrate_bps() const;
  void clear_bitrate_bps() ;
  ::int32_t bitrate_bps() const;
  void set_bitrate_bps(::int32_t value);

  private:
  ::int32_t _internal_bitrate_bps() const;
  void _internal_set_bitrate_bps(::int32_t value);

  public:
  // optional int32 frame_length_ms = 3;
  bool has_frame_length_ms() const;
  void clear_frame_length_ms() ;
  ::int32_t frame_length_ms() const;
  void set_frame_length_ms(::int32_t value);

  private:
  ::int32_t _internal_frame_length_ms() const;
  void _internal_set_frame_length_ms(::int32_t value);

  public:
  // optional uint32 uplink_packet_loss_fraction = 4;
  bool has_uplink_packet_loss_fraction() const;
  void clear_uplink_packet_loss_fraction() ;
  ::uint32_t uplink_packet_loss_fraction() const;
  void set_uplink_packet_loss_fraction(::uint32_t value);

  private:
  ::uint32_t _internal_uplink_packet_loss_fraction() const;
  void _internal_set_uplink_packet_loss_fraction(::uint32_t value);

  public:
  // optional bool enable_fec = 5;
  bool has_enable_fec() const;
  void clear_enable_fec() ;
  bool enable_fec() const;
  void set_enable_fec(bool value);

  private:
  bool _internal_enable_fec() const;
  void _internal_set_enable_fec(bool value);

  public:
  // optional bool enable_dtx = 6;
  bool has_enable_dtx() const;
  void clear_enable_dtx() ;
  bool enable_dtx() const;
  void set_enable_dtx(bool value);

  private:
  bool _internal_enable_dtx() const;
  void _internal_set_enable_dtx(bool value);

  public:
  // optional uint32 num_channels = 7;
  bool has_num_channels() const;
  void clear_num_channels() ;
  ::uint32_t num_channels() const;
  void set_num_channels(::uint32_t value);

  private:
  ::uint32_t _internal_num_channels() const;
  void _internal_set_num_channels(::uint32_t value);

  public:
  // optional uint32 number_of_deltas = 8;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.AudioNetworkAdaptations)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 0,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr bitrate_bps_deltas_;
    ::google::protobuf::internal::ArenaStringPtr frame_length_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr uplink_packet_loss_fraction_deltas_;
    ::google::protobuf::internal::ArenaStringPtr enable_fec_deltas_;
    ::google::protobuf::internal::ArenaStringPtr enable_dtx_deltas_;
    ::google::protobuf::internal::ArenaStringPtr num_channels_deltas_;
    ::int64_t timestamp_ms_;
    ::int32_t bitrate_bps_;
    ::int32_t frame_length_ms_;
    ::uint32_t uplink_packet_loss_fraction_;
    bool enable_fec_;
    bool enable_dtx_;
    ::uint32_t num_channels_;
    ::uint32_t number_of_deltas_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class AlrState final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.AlrState) */ {
 public:
  inline AlrState() : AlrState(nullptr) {}
  ~AlrState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AlrState(::google::protobuf::internal::ConstantInitialized);

  inline AlrState(const AlrState& from)
      : AlrState(nullptr, from) {}
  AlrState(AlrState&& from) noexcept
    : AlrState() {
    *this = ::std::move(from);
  }

  inline AlrState& operator=(const AlrState& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlrState& operator=(AlrState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AlrState& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlrState* internal_default_instance() {
    return reinterpret_cast<const AlrState*>(
               &_AlrState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(AlrState& a, AlrState& b) {
    a.Swap(&b);
  }
  inline void Swap(AlrState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlrState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlrState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlrState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const AlrState& from);
  void MergeFrom(const AlrState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AlrState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.AlrState";
  }
  protected:
  explicit AlrState(::google::protobuf::Arena* arena);
  AlrState(::google::protobuf::Arena* arena, const AlrState& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsFieldNumber = 1,
    kInAlrFieldNumber = 2,
  };
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional bool in_alr = 2;
  bool has_in_alr() const;
  void clear_in_alr() ;
  bool in_alr() const;
  void set_in_alr(bool value);

  private:
  bool _internal_in_alr() const;
  void _internal_set_in_alr(bool value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.AlrState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t timestamp_ms_;
    bool in_alr_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class VideoSendStreamConfig final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.VideoSendStreamConfig) */ {
 public:
  inline VideoSendStreamConfig() : VideoSendStreamConfig(nullptr) {}
  ~VideoSendStreamConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VideoSendStreamConfig(::google::protobuf::internal::ConstantInitialized);

  inline VideoSendStreamConfig(const VideoSendStreamConfig& from)
      : VideoSendStreamConfig(nullptr, from) {}
  VideoSendStreamConfig(VideoSendStreamConfig&& from) noexcept
    : VideoSendStreamConfig() {
    *this = ::std::move(from);
  }

  inline VideoSendStreamConfig& operator=(const VideoSendStreamConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoSendStreamConfig& operator=(VideoSendStreamConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VideoSendStreamConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoSendStreamConfig* internal_default_instance() {
    return reinterpret_cast<const VideoSendStreamConfig*>(
               &_VideoSendStreamConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(VideoSendStreamConfig& a, VideoSendStreamConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoSendStreamConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoSendStreamConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoSendStreamConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoSendStreamConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const VideoSendStreamConfig& from);
  void MergeFrom(const VideoSendStreamConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VideoSendStreamConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.VideoSendStreamConfig";
  }
  protected:
  explicit VideoSendStreamConfig(::google::protobuf::Arena* arena);
  VideoSendStreamConfig(::google::protobuf::Arena* arena, const VideoSendStreamConfig& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderExtensionsFieldNumber = 4,
    kTimestampMsFieldNumber = 1,
    kSsrcFieldNumber = 2,
    kRtxSsrcFieldNumber = 3,
  };
  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
  bool has_header_extensions() const;
  void clear_header_extensions() ;
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions() const;
  PROTOBUF_NODISCARD ::webrtc::rtclog2::RtpHeaderExtensionConfig* release_header_extensions();
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* mutable_header_extensions();
  void set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value);
  void unsafe_arena_set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value);
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* unsafe_arena_release_header_extensions();

  private:
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig& _internal_header_extensions() const;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* _internal_mutable_header_extensions();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 ssrc = 2;
  bool has_ssrc() const;
  void clear_ssrc() ;
  ::uint32_t ssrc() const;
  void set_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_ssrc() const;
  void _internal_set_ssrc(::uint32_t value);

  public:
  // optional uint32 rtx_ssrc = 3;
  bool has_rtx_ssrc() const;
  void clear_rtx_ssrc() ;
  ::uint32_t rtx_ssrc() const;
  void set_rtx_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_rtx_ssrc() const;
  void _internal_set_rtx_ssrc(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.VideoSendStreamConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::webrtc::rtclog2::RtpHeaderExtensionConfig* header_extensions_;
    ::int64_t timestamp_ms_;
    ::uint32_t ssrc_;
    ::uint32_t rtx_ssrc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class VideoRecvStreamConfig final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.VideoRecvStreamConfig) */ {
 public:
  inline VideoRecvStreamConfig() : VideoRecvStreamConfig(nullptr) {}
  ~VideoRecvStreamConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VideoRecvStreamConfig(::google::protobuf::internal::ConstantInitialized);

  inline VideoRecvStreamConfig(const VideoRecvStreamConfig& from)
      : VideoRecvStreamConfig(nullptr, from) {}
  VideoRecvStreamConfig(VideoRecvStreamConfig&& from) noexcept
    : VideoRecvStreamConfig() {
    *this = ::std::move(from);
  }

  inline VideoRecvStreamConfig& operator=(const VideoRecvStreamConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoRecvStreamConfig& operator=(VideoRecvStreamConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VideoRecvStreamConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoRecvStreamConfig* internal_default_instance() {
    return reinterpret_cast<const VideoRecvStreamConfig*>(
               &_VideoRecvStreamConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VideoRecvStreamConfig& a, VideoRecvStreamConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoRecvStreamConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoRecvStreamConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoRecvStreamConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoRecvStreamConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const VideoRecvStreamConfig& from);
  void MergeFrom(const VideoRecvStreamConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VideoRecvStreamConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.VideoRecvStreamConfig";
  }
  protected:
  explicit VideoRecvStreamConfig(::google::protobuf::Arena* arena);
  VideoRecvStreamConfig(::google::protobuf::Arena* arena, const VideoRecvStreamConfig& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderExtensionsFieldNumber = 5,
    kTimestampMsFieldNumber = 1,
    kRemoteSsrcFieldNumber = 2,
    kLocalSsrcFieldNumber = 3,
    kRtxSsrcFieldNumber = 4,
  };
  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
  bool has_header_extensions() const;
  void clear_header_extensions() ;
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions() const;
  PROTOBUF_NODISCARD ::webrtc::rtclog2::RtpHeaderExtensionConfig* release_header_extensions();
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* mutable_header_extensions();
  void set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value);
  void unsafe_arena_set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value);
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* unsafe_arena_release_header_extensions();

  private:
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig& _internal_header_extensions() const;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* _internal_mutable_header_extensions();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 remote_ssrc = 2;
  bool has_remote_ssrc() const;
  void clear_remote_ssrc() ;
  ::uint32_t remote_ssrc() const;
  void set_remote_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_remote_ssrc() const;
  void _internal_set_remote_ssrc(::uint32_t value);

  public:
  // optional uint32 local_ssrc = 3;
  bool has_local_ssrc() const;
  void clear_local_ssrc() ;
  ::uint32_t local_ssrc() const;
  void set_local_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_local_ssrc() const;
  void _internal_set_local_ssrc(::uint32_t value);

  public:
  // optional uint32 rtx_ssrc = 4;
  bool has_rtx_ssrc() const;
  void clear_rtx_ssrc() ;
  ::uint32_t rtx_ssrc() const;
  void set_rtx_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_rtx_ssrc() const;
  void _internal_set_rtx_ssrc(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.VideoRecvStreamConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::webrtc::rtclog2::RtpHeaderExtensionConfig* header_extensions_;
    ::int64_t timestamp_ms_;
    ::uint32_t remote_ssrc_;
    ::uint32_t local_ssrc_;
    ::uint32_t rtx_ssrc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class OutgoingRtpPackets final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.OutgoingRtpPackets) */ {
 public:
  inline OutgoingRtpPackets() : OutgoingRtpPackets(nullptr) {}
  ~OutgoingRtpPackets() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OutgoingRtpPackets(::google::protobuf::internal::ConstantInitialized);

  inline OutgoingRtpPackets(const OutgoingRtpPackets& from)
      : OutgoingRtpPackets(nullptr, from) {}
  OutgoingRtpPackets(OutgoingRtpPackets&& from) noexcept
    : OutgoingRtpPackets() {
    *this = ::std::move(from);
  }

  inline OutgoingRtpPackets& operator=(const OutgoingRtpPackets& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutgoingRtpPackets& operator=(OutgoingRtpPackets&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OutgoingRtpPackets& default_instance() {
    return *internal_default_instance();
  }
  static inline const OutgoingRtpPackets* internal_default_instance() {
    return reinterpret_cast<const OutgoingRtpPackets*>(
               &_OutgoingRtpPackets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OutgoingRtpPackets& a, OutgoingRtpPackets& b) {
    a.Swap(&b);
  }
  inline void Swap(OutgoingRtpPackets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutgoingRtpPackets* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OutgoingRtpPackets* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OutgoingRtpPackets>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const OutgoingRtpPackets& from);
  void MergeFrom(const OutgoingRtpPackets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OutgoingRtpPackets* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.OutgoingRtpPackets";
  }
  protected:
  explicit OutgoingRtpPackets(::google::protobuf::Arena* arena);
  OutgoingRtpPackets(::google::protobuf::Arena* arena, const OutgoingRtpPackets& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 101,
    kMarkerDeltasFieldNumber = 102,
    kPayloadTypeDeltasFieldNumber = 103,
    kSequenceNumberDeltasFieldNumber = 104,
    kRtpTimestampDeltasFieldNumber = 105,
    kSsrcDeltasFieldNumber = 106,
    kPayloadSizeDeltasFieldNumber = 108,
    kHeaderSizeDeltasFieldNumber = 109,
    kPaddingSizeDeltasFieldNumber = 110,
    kTransportSequenceNumberDeltasFieldNumber = 115,
    kTransmissionTimeOffsetDeltasFieldNumber = 116,
    kAbsoluteSendTimeDeltasFieldNumber = 117,
    kVideoRotationDeltasFieldNumber = 118,
    kAudioLevelDeltasFieldNumber = 119,
    kVoiceActivityDeltasFieldNumber = 120,
    kDependencyDescriptorFieldNumber = 21,
    kTimestampMsFieldNumber = 1,
    kPayloadTypeFieldNumber = 3,
    kSequenceNumberFieldNumber = 4,
    kRtpTimestampFieldNumber = 5,
    kSsrcFieldNumber = 6,
    kPayloadSizeFieldNumber = 8,
    kHeaderSizeFieldNumber = 9,
    kPaddingSizeFieldNumber = 10,
    kNumberOfDeltasFieldNumber = 11,
    kMarkerFieldNumber = 2,
    kVoiceActivityFieldNumber = 20,
    kTransportSequenceNumberFieldNumber = 15,
    kTransmissionTimeOffsetFieldNumber = 16,
    kAbsoluteSendTimeFieldNumber = 17,
    kVideoRotationFieldNumber = 18,
    kAudioLevelFieldNumber = 19,
  };
  // optional bytes timestamp_ms_deltas = 101;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes marker_deltas = 102;
  bool has_marker_deltas() const;
  void clear_marker_deltas() ;
  const std::string& marker_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_marker_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_marker_deltas();
  PROTOBUF_NODISCARD std::string* release_marker_deltas();
  void set_allocated_marker_deltas(std::string* value);

  private:
  const std::string& _internal_marker_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marker_deltas(
      const std::string& value);
  std::string* _internal_mutable_marker_deltas();

  public:
  // optional bytes payload_type_deltas = 103;
  bool has_payload_type_deltas() const;
  void clear_payload_type_deltas() ;
  const std::string& payload_type_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload_type_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_payload_type_deltas();
  PROTOBUF_NODISCARD std::string* release_payload_type_deltas();
  void set_allocated_payload_type_deltas(std::string* value);

  private:
  const std::string& _internal_payload_type_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_type_deltas(
      const std::string& value);
  std::string* _internal_mutable_payload_type_deltas();

  public:
  // optional bytes sequence_number_deltas = 104;
  bool has_sequence_number_deltas() const;
  void clear_sequence_number_deltas() ;
  const std::string& sequence_number_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sequence_number_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_sequence_number_deltas();
  PROTOBUF_NODISCARD std::string* release_sequence_number_deltas();
  void set_allocated_sequence_number_deltas(std::string* value);

  private:
  const std::string& _internal_sequence_number_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence_number_deltas(
      const std::string& value);
  std::string* _internal_mutable_sequence_number_deltas();

  public:
  // optional bytes rtp_timestamp_deltas = 105;
  bool has_rtp_timestamp_deltas() const;
  void clear_rtp_timestamp_deltas() ;
  const std::string& rtp_timestamp_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rtp_timestamp_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_rtp_timestamp_deltas();
  PROTOBUF_NODISCARD std::string* release_rtp_timestamp_deltas();
  void set_allocated_rtp_timestamp_deltas(std::string* value);

  private:
  const std::string& _internal_rtp_timestamp_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rtp_timestamp_deltas(
      const std::string& value);
  std::string* _internal_mutable_rtp_timestamp_deltas();

  public:
  // optional bytes ssrc_deltas = 106;
  bool has_ssrc_deltas() const;
  void clear_ssrc_deltas() ;
  const std::string& ssrc_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ssrc_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_ssrc_deltas();
  PROTOBUF_NODISCARD std::string* release_ssrc_deltas();
  void set_allocated_ssrc_deltas(std::string* value);

  private:
  const std::string& _internal_ssrc_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssrc_deltas(
      const std::string& value);
  std::string* _internal_mutable_ssrc_deltas();

  public:
  // optional bytes payload_size_deltas = 108;
  bool has_payload_size_deltas() const;
  void clear_payload_size_deltas() ;
  const std::string& payload_size_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload_size_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_payload_size_deltas();
  PROTOBUF_NODISCARD std::string* release_payload_size_deltas();
  void set_allocated_payload_size_deltas(std::string* value);

  private:
  const std::string& _internal_payload_size_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_size_deltas(
      const std::string& value);
  std::string* _internal_mutable_payload_size_deltas();

  public:
  // optional bytes header_size_deltas = 109;
  bool has_header_size_deltas() const;
  void clear_header_size_deltas() ;
  const std::string& header_size_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_header_size_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_header_size_deltas();
  PROTOBUF_NODISCARD std::string* release_header_size_deltas();
  void set_allocated_header_size_deltas(std::string* value);

  private:
  const std::string& _internal_header_size_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_header_size_deltas(
      const std::string& value);
  std::string* _internal_mutable_header_size_deltas();

  public:
  // optional bytes padding_size_deltas = 110;
  bool has_padding_size_deltas() const;
  void clear_padding_size_deltas() ;
  const std::string& padding_size_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_padding_size_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_padding_size_deltas();
  PROTOBUF_NODISCARD std::string* release_padding_size_deltas();
  void set_allocated_padding_size_deltas(std::string* value);

  private:
  const std::string& _internal_padding_size_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_padding_size_deltas(
      const std::string& value);
  std::string* _internal_mutable_padding_size_deltas();

  public:
  // optional bytes transport_sequence_number_deltas = 115;
  bool has_transport_sequence_number_deltas() const;
  void clear_transport_sequence_number_deltas() ;
  const std::string& transport_sequence_number_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transport_sequence_number_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_transport_sequence_number_deltas();
  PROTOBUF_NODISCARD std::string* release_transport_sequence_number_deltas();
  void set_allocated_transport_sequence_number_deltas(std::string* value);

  private:
  const std::string& _internal_transport_sequence_number_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transport_sequence_number_deltas(
      const std::string& value);
  std::string* _internal_mutable_transport_sequence_number_deltas();

  public:
  // optional bytes transmission_time_offset_deltas = 116;
  bool has_transmission_time_offset_deltas() const;
  void clear_transmission_time_offset_deltas() ;
  const std::string& transmission_time_offset_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transmission_time_offset_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_transmission_time_offset_deltas();
  PROTOBUF_NODISCARD std::string* release_transmission_time_offset_deltas();
  void set_allocated_transmission_time_offset_deltas(std::string* value);

  private:
  const std::string& _internal_transmission_time_offset_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transmission_time_offset_deltas(
      const std::string& value);
  std::string* _internal_mutable_transmission_time_offset_deltas();

  public:
  // optional bytes absolute_send_time_deltas = 117;
  bool has_absolute_send_time_deltas() const;
  void clear_absolute_send_time_deltas() ;
  const std::string& absolute_send_time_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_absolute_send_time_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_absolute_send_time_deltas();
  PROTOBUF_NODISCARD std::string* release_absolute_send_time_deltas();
  void set_allocated_absolute_send_time_deltas(std::string* value);

  private:
  const std::string& _internal_absolute_send_time_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_absolute_send_time_deltas(
      const std::string& value);
  std::string* _internal_mutable_absolute_send_time_deltas();

  public:
  // optional bytes video_rotation_deltas = 118;
  bool has_video_rotation_deltas() const;
  void clear_video_rotation_deltas() ;
  const std::string& video_rotation_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_video_rotation_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_video_rotation_deltas();
  PROTOBUF_NODISCARD std::string* release_video_rotation_deltas();
  void set_allocated_video_rotation_deltas(std::string* value);

  private:
  const std::string& _internal_video_rotation_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_video_rotation_deltas(
      const std::string& value);
  std::string* _internal_mutable_video_rotation_deltas();

  public:
  // optional bytes audio_level_deltas = 119;
  bool has_audio_level_deltas() const;
  void clear_audio_level_deltas() ;
  const std::string& audio_level_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio_level_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_audio_level_deltas();
  PROTOBUF_NODISCARD std::string* release_audio_level_deltas();
  void set_allocated_audio_level_deltas(std::string* value);

  private:
  const std::string& _internal_audio_level_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_level_deltas(
      const std::string& value);
  std::string* _internal_mutable_audio_level_deltas();

  public:
  // optional bytes voice_activity_deltas = 120;
  bool has_voice_activity_deltas() const;
  void clear_voice_activity_deltas() ;
  const std::string& voice_activity_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_voice_activity_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_voice_activity_deltas();
  PROTOBUF_NODISCARD std::string* release_voice_activity_deltas();
  void set_allocated_voice_activity_deltas(std::string* value);

  private:
  const std::string& _internal_voice_activity_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voice_activity_deltas(
      const std::string& value);
  std::string* _internal_mutable_voice_activity_deltas();

  public:
  // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
  bool has_dependency_descriptor() const;
  void clear_dependency_descriptor() ;
  const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& dependency_descriptor() const;
  PROTOBUF_NODISCARD ::webrtc::rtclog2::DependencyDescriptorsWireInfo* release_dependency_descriptor();
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* mutable_dependency_descriptor();
  void set_allocated_dependency_descriptor(::webrtc::rtclog2::DependencyDescriptorsWireInfo* value);
  void unsafe_arena_set_allocated_dependency_descriptor(::webrtc::rtclog2::DependencyDescriptorsWireInfo* value);
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* unsafe_arena_release_dependency_descriptor();

  private:
  const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& _internal_dependency_descriptor() const;
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* _internal_mutable_dependency_descriptor();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 payload_type = 3;
  bool has_payload_type() const;
  void clear_payload_type() ;
  ::uint32_t payload_type() const;
  void set_payload_type(::uint32_t value);

  private:
  ::uint32_t _internal_payload_type() const;
  void _internal_set_payload_type(::uint32_t value);

  public:
  // optional uint32 sequence_number = 4;
  bool has_sequence_number() const;
  void clear_sequence_number() ;
  ::uint32_t sequence_number() const;
  void set_sequence_number(::uint32_t value);

  private:
  ::uint32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(::uint32_t value);

  public:
  // optional fixed32 rtp_timestamp = 5;
  bool has_rtp_timestamp() const;
  void clear_rtp_timestamp() ;
  ::uint32_t rtp_timestamp() const;
  void set_rtp_timestamp(::uint32_t value);

  private:
  ::uint32_t _internal_rtp_timestamp() const;
  void _internal_set_rtp_timestamp(::uint32_t value);

  public:
  // optional fixed32 ssrc = 6;
  bool has_ssrc() const;
  void clear_ssrc() ;
  ::uint32_t ssrc() const;
  void set_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_ssrc() const;
  void _internal_set_ssrc(::uint32_t value);

  public:
  // optional uint32 payload_size = 8;
  bool has_payload_size() const;
  void clear_payload_size() ;
  ::uint32_t payload_size() const;
  void set_payload_size(::uint32_t value);

  private:
  ::uint32_t _internal_payload_size() const;
  void _internal_set_payload_size(::uint32_t value);

  public:
  // optional uint32 header_size = 9;
  bool has_header_size() const;
  void clear_header_size() ;
  ::uint32_t header_size() const;
  void set_header_size(::uint32_t value);

  private:
  ::uint32_t _internal_header_size() const;
  void _internal_set_header_size(::uint32_t value);

  public:
  // optional uint32 padding_size = 10;
  bool has_padding_size() const;
  void clear_padding_size() ;
  ::uint32_t padding_size() const;
  void set_padding_size(::uint32_t value);

  private:
  ::uint32_t _internal_padding_size() const;
  void _internal_set_padding_size(::uint32_t value);

  public:
  // optional uint32 number_of_deltas = 11;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // optional bool marker = 2;
  bool has_marker() const;
  void clear_marker() ;
  bool marker() const;
  void set_marker(bool value);

  private:
  bool _internal_marker() const;
  void _internal_set_marker(bool value);

  public:
  // optional bool voice_activity = 20;
  bool has_voice_activity() const;
  void clear_voice_activity() ;
  bool voice_activity() const;
  void set_voice_activity(bool value);

  private:
  bool _internal_voice_activity() const;
  void _internal_set_voice_activity(bool value);

  public:
  // optional uint32 transport_sequence_number = 15;
  bool has_transport_sequence_number() const;
  void clear_transport_sequence_number() ;
  ::uint32_t transport_sequence_number() const;
  void set_transport_sequence_number(::uint32_t value);

  private:
  ::uint32_t _internal_transport_sequence_number() const;
  void _internal_set_transport_sequence_number(::uint32_t value);

  public:
  // optional int32 transmission_time_offset = 16;
  bool has_transmission_time_offset() const;
  void clear_transmission_time_offset() ;
  ::int32_t transmission_time_offset() const;
  void set_transmission_time_offset(::int32_t value);

  private:
  ::int32_t _internal_transmission_time_offset() const;
  void _internal_set_transmission_time_offset(::int32_t value);

  public:
  // optional uint32 absolute_send_time = 17;
  bool has_absolute_send_time() const;
  void clear_absolute_send_time() ;
  ::uint32_t absolute_send_time() const;
  void set_absolute_send_time(::uint32_t value);

  private:
  ::uint32_t _internal_absolute_send_time() const;
  void _internal_set_absolute_send_time(::uint32_t value);

  public:
  // optional uint32 video_rotation = 18;
  bool has_video_rotation() const;
  void clear_video_rotation() ;
  ::uint32_t video_rotation() const;
  void set_video_rotation(::uint32_t value);

  private:
  ::uint32_t _internal_video_rotation() const;
  void _internal_set_video_rotation(::uint32_t value);

  public:
  // optional uint32 audio_level = 19;
  bool has_audio_level() const;
  void clear_audio_level() ;
  ::uint32_t audio_level() const;
  void set_audio_level(::uint32_t value);

  private:
  ::uint32_t _internal_audio_level() const;
  void _internal_set_audio_level(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.OutgoingRtpPackets)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 32, 1,
      0, 9>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr marker_deltas_;
    ::google::protobuf::internal::ArenaStringPtr payload_type_deltas_;
    ::google::protobuf::internal::ArenaStringPtr sequence_number_deltas_;
    ::google::protobuf::internal::ArenaStringPtr rtp_timestamp_deltas_;
    ::google::protobuf::internal::ArenaStringPtr ssrc_deltas_;
    ::google::protobuf::internal::ArenaStringPtr payload_size_deltas_;
    ::google::protobuf::internal::ArenaStringPtr header_size_deltas_;
    ::google::protobuf::internal::ArenaStringPtr padding_size_deltas_;
    ::google::protobuf::internal::ArenaStringPtr transport_sequence_number_deltas_;
    ::google::protobuf::internal::ArenaStringPtr transmission_time_offset_deltas_;
    ::google::protobuf::internal::ArenaStringPtr absolute_send_time_deltas_;
    ::google::protobuf::internal::ArenaStringPtr video_rotation_deltas_;
    ::google::protobuf::internal::ArenaStringPtr audio_level_deltas_;
    ::google::protobuf::internal::ArenaStringPtr voice_activity_deltas_;
    ::webrtc::rtclog2::DependencyDescriptorsWireInfo* dependency_descriptor_;
    ::int64_t timestamp_ms_;
    ::uint32_t payload_type_;
    ::uint32_t sequence_number_;
    ::uint32_t rtp_timestamp_;
    ::uint32_t ssrc_;
    ::uint32_t payload_size_;
    ::uint32_t header_size_;
    ::uint32_t padding_size_;
    ::uint32_t number_of_deltas_;
    bool marker_;
    bool voice_activity_;
    ::uint32_t transport_sequence_number_;
    ::int32_t transmission_time_offset_;
    ::uint32_t absolute_send_time_;
    ::uint32_t video_rotation_;
    ::uint32_t audio_level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class IncomingRtpPackets final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.IncomingRtpPackets) */ {
 public:
  inline IncomingRtpPackets() : IncomingRtpPackets(nullptr) {}
  ~IncomingRtpPackets() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IncomingRtpPackets(::google::protobuf::internal::ConstantInitialized);

  inline IncomingRtpPackets(const IncomingRtpPackets& from)
      : IncomingRtpPackets(nullptr, from) {}
  IncomingRtpPackets(IncomingRtpPackets&& from) noexcept
    : IncomingRtpPackets() {
    *this = ::std::move(from);
  }

  inline IncomingRtpPackets& operator=(const IncomingRtpPackets& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncomingRtpPackets& operator=(IncomingRtpPackets&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IncomingRtpPackets& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncomingRtpPackets* internal_default_instance() {
    return reinterpret_cast<const IncomingRtpPackets*>(
               &_IncomingRtpPackets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(IncomingRtpPackets& a, IncomingRtpPackets& b) {
    a.Swap(&b);
  }
  inline void Swap(IncomingRtpPackets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncomingRtpPackets* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncomingRtpPackets* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IncomingRtpPackets>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const IncomingRtpPackets& from);
  void MergeFrom(const IncomingRtpPackets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IncomingRtpPackets* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.IncomingRtpPackets";
  }
  protected:
  explicit IncomingRtpPackets(::google::protobuf::Arena* arena);
  IncomingRtpPackets(::google::protobuf::Arena* arena, const IncomingRtpPackets& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampMsDeltasFieldNumber = 101,
    kMarkerDeltasFieldNumber = 102,
    kPayloadTypeDeltasFieldNumber = 103,
    kSequenceNumberDeltasFieldNumber = 104,
    kRtpTimestampDeltasFieldNumber = 105,
    kSsrcDeltasFieldNumber = 106,
    kPayloadSizeDeltasFieldNumber = 108,
    kHeaderSizeDeltasFieldNumber = 109,
    kPaddingSizeDeltasFieldNumber = 110,
    kTransportSequenceNumberDeltasFieldNumber = 115,
    kTransmissionTimeOffsetDeltasFieldNumber = 116,
    kAbsoluteSendTimeDeltasFieldNumber = 117,
    kVideoRotationDeltasFieldNumber = 118,
    kAudioLevelDeltasFieldNumber = 119,
    kVoiceActivityDeltasFieldNumber = 120,
    kDependencyDescriptorFieldNumber = 21,
    kTimestampMsFieldNumber = 1,
    kPayloadTypeFieldNumber = 3,
    kSequenceNumberFieldNumber = 4,
    kRtpTimestampFieldNumber = 5,
    kSsrcFieldNumber = 6,
    kPayloadSizeFieldNumber = 8,
    kHeaderSizeFieldNumber = 9,
    kPaddingSizeFieldNumber = 10,
    kNumberOfDeltasFieldNumber = 11,
    kMarkerFieldNumber = 2,
    kVoiceActivityFieldNumber = 20,
    kTransportSequenceNumberFieldNumber = 15,
    kTransmissionTimeOffsetFieldNumber = 16,
    kAbsoluteSendTimeFieldNumber = 17,
    kVideoRotationFieldNumber = 18,
    kAudioLevelFieldNumber = 19,
  };
  // optional bytes timestamp_ms_deltas = 101;
  bool has_timestamp_ms_deltas() const;
  void clear_timestamp_ms_deltas() ;
  const std::string& timestamp_ms_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp_ms_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp_ms_deltas();
  PROTOBUF_NODISCARD std::string* release_timestamp_ms_deltas();
  void set_allocated_timestamp_ms_deltas(std::string* value);

  private:
  const std::string& _internal_timestamp_ms_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp_ms_deltas(
      const std::string& value);
  std::string* _internal_mutable_timestamp_ms_deltas();

  public:
  // optional bytes marker_deltas = 102;
  bool has_marker_deltas() const;
  void clear_marker_deltas() ;
  const std::string& marker_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_marker_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_marker_deltas();
  PROTOBUF_NODISCARD std::string* release_marker_deltas();
  void set_allocated_marker_deltas(std::string* value);

  private:
  const std::string& _internal_marker_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_marker_deltas(
      const std::string& value);
  std::string* _internal_mutable_marker_deltas();

  public:
  // optional bytes payload_type_deltas = 103;
  bool has_payload_type_deltas() const;
  void clear_payload_type_deltas() ;
  const std::string& payload_type_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload_type_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_payload_type_deltas();
  PROTOBUF_NODISCARD std::string* release_payload_type_deltas();
  void set_allocated_payload_type_deltas(std::string* value);

  private:
  const std::string& _internal_payload_type_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_type_deltas(
      const std::string& value);
  std::string* _internal_mutable_payload_type_deltas();

  public:
  // optional bytes sequence_number_deltas = 104;
  bool has_sequence_number_deltas() const;
  void clear_sequence_number_deltas() ;
  const std::string& sequence_number_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sequence_number_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_sequence_number_deltas();
  PROTOBUF_NODISCARD std::string* release_sequence_number_deltas();
  void set_allocated_sequence_number_deltas(std::string* value);

  private:
  const std::string& _internal_sequence_number_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence_number_deltas(
      const std::string& value);
  std::string* _internal_mutable_sequence_number_deltas();

  public:
  // optional bytes rtp_timestamp_deltas = 105;
  bool has_rtp_timestamp_deltas() const;
  void clear_rtp_timestamp_deltas() ;
  const std::string& rtp_timestamp_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_rtp_timestamp_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_rtp_timestamp_deltas();
  PROTOBUF_NODISCARD std::string* release_rtp_timestamp_deltas();
  void set_allocated_rtp_timestamp_deltas(std::string* value);

  private:
  const std::string& _internal_rtp_timestamp_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rtp_timestamp_deltas(
      const std::string& value);
  std::string* _internal_mutable_rtp_timestamp_deltas();

  public:
  // optional bytes ssrc_deltas = 106;
  bool has_ssrc_deltas() const;
  void clear_ssrc_deltas() ;
  const std::string& ssrc_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ssrc_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_ssrc_deltas();
  PROTOBUF_NODISCARD std::string* release_ssrc_deltas();
  void set_allocated_ssrc_deltas(std::string* value);

  private:
  const std::string& _internal_ssrc_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssrc_deltas(
      const std::string& value);
  std::string* _internal_mutable_ssrc_deltas();

  public:
  // optional bytes payload_size_deltas = 108;
  bool has_payload_size_deltas() const;
  void clear_payload_size_deltas() ;
  const std::string& payload_size_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload_size_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_payload_size_deltas();
  PROTOBUF_NODISCARD std::string* release_payload_size_deltas();
  void set_allocated_payload_size_deltas(std::string* value);

  private:
  const std::string& _internal_payload_size_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_size_deltas(
      const std::string& value);
  std::string* _internal_mutable_payload_size_deltas();

  public:
  // optional bytes header_size_deltas = 109;
  bool has_header_size_deltas() const;
  void clear_header_size_deltas() ;
  const std::string& header_size_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_header_size_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_header_size_deltas();
  PROTOBUF_NODISCARD std::string* release_header_size_deltas();
  void set_allocated_header_size_deltas(std::string* value);

  private:
  const std::string& _internal_header_size_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_header_size_deltas(
      const std::string& value);
  std::string* _internal_mutable_header_size_deltas();

  public:
  // optional bytes padding_size_deltas = 110;
  bool has_padding_size_deltas() const;
  void clear_padding_size_deltas() ;
  const std::string& padding_size_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_padding_size_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_padding_size_deltas();
  PROTOBUF_NODISCARD std::string* release_padding_size_deltas();
  void set_allocated_padding_size_deltas(std::string* value);

  private:
  const std::string& _internal_padding_size_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_padding_size_deltas(
      const std::string& value);
  std::string* _internal_mutable_padding_size_deltas();

  public:
  // optional bytes transport_sequence_number_deltas = 115;
  bool has_transport_sequence_number_deltas() const;
  void clear_transport_sequence_number_deltas() ;
  const std::string& transport_sequence_number_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transport_sequence_number_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_transport_sequence_number_deltas();
  PROTOBUF_NODISCARD std::string* release_transport_sequence_number_deltas();
  void set_allocated_transport_sequence_number_deltas(std::string* value);

  private:
  const std::string& _internal_transport_sequence_number_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transport_sequence_number_deltas(
      const std::string& value);
  std::string* _internal_mutable_transport_sequence_number_deltas();

  public:
  // optional bytes transmission_time_offset_deltas = 116;
  bool has_transmission_time_offset_deltas() const;
  void clear_transmission_time_offset_deltas() ;
  const std::string& transmission_time_offset_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_transmission_time_offset_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_transmission_time_offset_deltas();
  PROTOBUF_NODISCARD std::string* release_transmission_time_offset_deltas();
  void set_allocated_transmission_time_offset_deltas(std::string* value);

  private:
  const std::string& _internal_transmission_time_offset_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transmission_time_offset_deltas(
      const std::string& value);
  std::string* _internal_mutable_transmission_time_offset_deltas();

  public:
  // optional bytes absolute_send_time_deltas = 117;
  bool has_absolute_send_time_deltas() const;
  void clear_absolute_send_time_deltas() ;
  const std::string& absolute_send_time_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_absolute_send_time_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_absolute_send_time_deltas();
  PROTOBUF_NODISCARD std::string* release_absolute_send_time_deltas();
  void set_allocated_absolute_send_time_deltas(std::string* value);

  private:
  const std::string& _internal_absolute_send_time_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_absolute_send_time_deltas(
      const std::string& value);
  std::string* _internal_mutable_absolute_send_time_deltas();

  public:
  // optional bytes video_rotation_deltas = 118;
  bool has_video_rotation_deltas() const;
  void clear_video_rotation_deltas() ;
  const std::string& video_rotation_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_video_rotation_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_video_rotation_deltas();
  PROTOBUF_NODISCARD std::string* release_video_rotation_deltas();
  void set_allocated_video_rotation_deltas(std::string* value);

  private:
  const std::string& _internal_video_rotation_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_video_rotation_deltas(
      const std::string& value);
  std::string* _internal_mutable_video_rotation_deltas();

  public:
  // optional bytes audio_level_deltas = 119;
  bool has_audio_level_deltas() const;
  void clear_audio_level_deltas() ;
  const std::string& audio_level_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio_level_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_audio_level_deltas();
  PROTOBUF_NODISCARD std::string* release_audio_level_deltas();
  void set_allocated_audio_level_deltas(std::string* value);

  private:
  const std::string& _internal_audio_level_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_level_deltas(
      const std::string& value);
  std::string* _internal_mutable_audio_level_deltas();

  public:
  // optional bytes voice_activity_deltas = 120;
  bool has_voice_activity_deltas() const;
  void clear_voice_activity_deltas() ;
  const std::string& voice_activity_deltas() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_voice_activity_deltas(Arg_&& arg, Args_... args);
  std::string* mutable_voice_activity_deltas();
  PROTOBUF_NODISCARD std::string* release_voice_activity_deltas();
  void set_allocated_voice_activity_deltas(std::string* value);

  private:
  const std::string& _internal_voice_activity_deltas() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_voice_activity_deltas(
      const std::string& value);
  std::string* _internal_mutable_voice_activity_deltas();

  public:
  // optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
  bool has_dependency_descriptor() const;
  void clear_dependency_descriptor() ;
  const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& dependency_descriptor() const;
  PROTOBUF_NODISCARD ::webrtc::rtclog2::DependencyDescriptorsWireInfo* release_dependency_descriptor();
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* mutable_dependency_descriptor();
  void set_allocated_dependency_descriptor(::webrtc::rtclog2::DependencyDescriptorsWireInfo* value);
  void unsafe_arena_set_allocated_dependency_descriptor(::webrtc::rtclog2::DependencyDescriptorsWireInfo* value);
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* unsafe_arena_release_dependency_descriptor();

  private:
  const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& _internal_dependency_descriptor() const;
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* _internal_mutable_dependency_descriptor();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 payload_type = 3;
  bool has_payload_type() const;
  void clear_payload_type() ;
  ::uint32_t payload_type() const;
  void set_payload_type(::uint32_t value);

  private:
  ::uint32_t _internal_payload_type() const;
  void _internal_set_payload_type(::uint32_t value);

  public:
  // optional uint32 sequence_number = 4;
  bool has_sequence_number() const;
  void clear_sequence_number() ;
  ::uint32_t sequence_number() const;
  void set_sequence_number(::uint32_t value);

  private:
  ::uint32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(::uint32_t value);

  public:
  // optional fixed32 rtp_timestamp = 5;
  bool has_rtp_timestamp() const;
  void clear_rtp_timestamp() ;
  ::uint32_t rtp_timestamp() const;
  void set_rtp_timestamp(::uint32_t value);

  private:
  ::uint32_t _internal_rtp_timestamp() const;
  void _internal_set_rtp_timestamp(::uint32_t value);

  public:
  // optional fixed32 ssrc = 6;
  bool has_ssrc() const;
  void clear_ssrc() ;
  ::uint32_t ssrc() const;
  void set_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_ssrc() const;
  void _internal_set_ssrc(::uint32_t value);

  public:
  // optional uint32 payload_size = 8;
  bool has_payload_size() const;
  void clear_payload_size() ;
  ::uint32_t payload_size() const;
  void set_payload_size(::uint32_t value);

  private:
  ::uint32_t _internal_payload_size() const;
  void _internal_set_payload_size(::uint32_t value);

  public:
  // optional uint32 header_size = 9;
  bool has_header_size() const;
  void clear_header_size() ;
  ::uint32_t header_size() const;
  void set_header_size(::uint32_t value);

  private:
  ::uint32_t _internal_header_size() const;
  void _internal_set_header_size(::uint32_t value);

  public:
  // optional uint32 padding_size = 10;
  bool has_padding_size() const;
  void clear_padding_size() ;
  ::uint32_t padding_size() const;
  void set_padding_size(::uint32_t value);

  private:
  ::uint32_t _internal_padding_size() const;
  void _internal_set_padding_size(::uint32_t value);

  public:
  // optional uint32 number_of_deltas = 11;
  bool has_number_of_deltas() const;
  void clear_number_of_deltas() ;
  ::uint32_t number_of_deltas() const;
  void set_number_of_deltas(::uint32_t value);

  private:
  ::uint32_t _internal_number_of_deltas() const;
  void _internal_set_number_of_deltas(::uint32_t value);

  public:
  // optional bool marker = 2;
  bool has_marker() const;
  void clear_marker() ;
  bool marker() const;
  void set_marker(bool value);

  private:
  bool _internal_marker() const;
  void _internal_set_marker(bool value);

  public:
  // optional bool voice_activity = 20;
  bool has_voice_activity() const;
  void clear_voice_activity() ;
  bool voice_activity() const;
  void set_voice_activity(bool value);

  private:
  bool _internal_voice_activity() const;
  void _internal_set_voice_activity(bool value);

  public:
  // optional uint32 transport_sequence_number = 15;
  bool has_transport_sequence_number() const;
  void clear_transport_sequence_number() ;
  ::uint32_t transport_sequence_number() const;
  void set_transport_sequence_number(::uint32_t value);

  private:
  ::uint32_t _internal_transport_sequence_number() const;
  void _internal_set_transport_sequence_number(::uint32_t value);

  public:
  // optional int32 transmission_time_offset = 16;
  bool has_transmission_time_offset() const;
  void clear_transmission_time_offset() ;
  ::int32_t transmission_time_offset() const;
  void set_transmission_time_offset(::int32_t value);

  private:
  ::int32_t _internal_transmission_time_offset() const;
  void _internal_set_transmission_time_offset(::int32_t value);

  public:
  // optional uint32 absolute_send_time = 17;
  bool has_absolute_send_time() const;
  void clear_absolute_send_time() ;
  ::uint32_t absolute_send_time() const;
  void set_absolute_send_time(::uint32_t value);

  private:
  ::uint32_t _internal_absolute_send_time() const;
  void _internal_set_absolute_send_time(::uint32_t value);

  public:
  // optional uint32 video_rotation = 18;
  bool has_video_rotation() const;
  void clear_video_rotation() ;
  ::uint32_t video_rotation() const;
  void set_video_rotation(::uint32_t value);

  private:
  ::uint32_t _internal_video_rotation() const;
  void _internal_set_video_rotation(::uint32_t value);

  public:
  // optional uint32 audio_level = 19;
  bool has_audio_level() const;
  void clear_audio_level() ;
  ::uint32_t audio_level() const;
  void set_audio_level(::uint32_t value);

  private:
  ::uint32_t _internal_audio_level() const;
  void _internal_set_audio_level(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.IncomingRtpPackets)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 32, 1,
      0, 9>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_ms_deltas_;
    ::google::protobuf::internal::ArenaStringPtr marker_deltas_;
    ::google::protobuf::internal::ArenaStringPtr payload_type_deltas_;
    ::google::protobuf::internal::ArenaStringPtr sequence_number_deltas_;
    ::google::protobuf::internal::ArenaStringPtr rtp_timestamp_deltas_;
    ::google::protobuf::internal::ArenaStringPtr ssrc_deltas_;
    ::google::protobuf::internal::ArenaStringPtr payload_size_deltas_;
    ::google::protobuf::internal::ArenaStringPtr header_size_deltas_;
    ::google::protobuf::internal::ArenaStringPtr padding_size_deltas_;
    ::google::protobuf::internal::ArenaStringPtr transport_sequence_number_deltas_;
    ::google::protobuf::internal::ArenaStringPtr transmission_time_offset_deltas_;
    ::google::protobuf::internal::ArenaStringPtr absolute_send_time_deltas_;
    ::google::protobuf::internal::ArenaStringPtr video_rotation_deltas_;
    ::google::protobuf::internal::ArenaStringPtr audio_level_deltas_;
    ::google::protobuf::internal::ArenaStringPtr voice_activity_deltas_;
    ::webrtc::rtclog2::DependencyDescriptorsWireInfo* dependency_descriptor_;
    ::int64_t timestamp_ms_;
    ::uint32_t payload_type_;
    ::uint32_t sequence_number_;
    ::uint32_t rtp_timestamp_;
    ::uint32_t ssrc_;
    ::uint32_t payload_size_;
    ::uint32_t header_size_;
    ::uint32_t padding_size_;
    ::uint32_t number_of_deltas_;
    bool marker_;
    bool voice_activity_;
    ::uint32_t transport_sequence_number_;
    ::int32_t transmission_time_offset_;
    ::uint32_t absolute_send_time_;
    ::uint32_t video_rotation_;
    ::uint32_t audio_level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class AudioSendStreamConfig final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.AudioSendStreamConfig) */ {
 public:
  inline AudioSendStreamConfig() : AudioSendStreamConfig(nullptr) {}
  ~AudioSendStreamConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AudioSendStreamConfig(::google::protobuf::internal::ConstantInitialized);

  inline AudioSendStreamConfig(const AudioSendStreamConfig& from)
      : AudioSendStreamConfig(nullptr, from) {}
  AudioSendStreamConfig(AudioSendStreamConfig&& from) noexcept
    : AudioSendStreamConfig() {
    *this = ::std::move(from);
  }

  inline AudioSendStreamConfig& operator=(const AudioSendStreamConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioSendStreamConfig& operator=(AudioSendStreamConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioSendStreamConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioSendStreamConfig* internal_default_instance() {
    return reinterpret_cast<const AudioSendStreamConfig*>(
               &_AudioSendStreamConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AudioSendStreamConfig& a, AudioSendStreamConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioSendStreamConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioSendStreamConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioSendStreamConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioSendStreamConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const AudioSendStreamConfig& from);
  void MergeFrom(const AudioSendStreamConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AudioSendStreamConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.AudioSendStreamConfig";
  }
  protected:
  explicit AudioSendStreamConfig(::google::protobuf::Arena* arena);
  AudioSendStreamConfig(::google::protobuf::Arena* arena, const AudioSendStreamConfig& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderExtensionsFieldNumber = 4,
    kTimestampMsFieldNumber = 1,
    kSsrcFieldNumber = 2,
  };
  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
  bool has_header_extensions() const;
  void clear_header_extensions() ;
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions() const;
  PROTOBUF_NODISCARD ::webrtc::rtclog2::RtpHeaderExtensionConfig* release_header_extensions();
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* mutable_header_extensions();
  void set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value);
  void unsafe_arena_set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value);
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* unsafe_arena_release_header_extensions();

  private:
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig& _internal_header_extensions() const;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* _internal_mutable_header_extensions();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 ssrc = 2;
  bool has_ssrc() const;
  void clear_ssrc() ;
  ::uint32_t ssrc() const;
  void set_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_ssrc() const;
  void _internal_set_ssrc(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.AudioSendStreamConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::webrtc::rtclog2::RtpHeaderExtensionConfig* header_extensions_;
    ::int64_t timestamp_ms_;
    ::uint32_t ssrc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class AudioRecvStreamConfig final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.AudioRecvStreamConfig) */ {
 public:
  inline AudioRecvStreamConfig() : AudioRecvStreamConfig(nullptr) {}
  ~AudioRecvStreamConfig() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AudioRecvStreamConfig(::google::protobuf::internal::ConstantInitialized);

  inline AudioRecvStreamConfig(const AudioRecvStreamConfig& from)
      : AudioRecvStreamConfig(nullptr, from) {}
  AudioRecvStreamConfig(AudioRecvStreamConfig&& from) noexcept
    : AudioRecvStreamConfig() {
    *this = ::std::move(from);
  }

  inline AudioRecvStreamConfig& operator=(const AudioRecvStreamConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioRecvStreamConfig& operator=(AudioRecvStreamConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioRecvStreamConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioRecvStreamConfig* internal_default_instance() {
    return reinterpret_cast<const AudioRecvStreamConfig*>(
               &_AudioRecvStreamConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AudioRecvStreamConfig& a, AudioRecvStreamConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioRecvStreamConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioRecvStreamConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioRecvStreamConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioRecvStreamConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const AudioRecvStreamConfig& from);
  void MergeFrom(const AudioRecvStreamConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AudioRecvStreamConfig* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.AudioRecvStreamConfig";
  }
  protected:
  explicit AudioRecvStreamConfig(::google::protobuf::Arena* arena);
  AudioRecvStreamConfig(::google::protobuf::Arena* arena, const AudioRecvStreamConfig& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderExtensionsFieldNumber = 5,
    kTimestampMsFieldNumber = 1,
    kRemoteSsrcFieldNumber = 2,
    kLocalSsrcFieldNumber = 3,
  };
  // optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
  bool has_header_extensions() const;
  void clear_header_extensions() ;
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig& header_extensions() const;
  PROTOBUF_NODISCARD ::webrtc::rtclog2::RtpHeaderExtensionConfig* release_header_extensions();
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* mutable_header_extensions();
  void set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value);
  void unsafe_arena_set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value);
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* unsafe_arena_release_header_extensions();

  private:
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig& _internal_header_extensions() const;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* _internal_mutable_header_extensions();

  public:
  // optional int64 timestamp_ms = 1;
  bool has_timestamp_ms() const;
  void clear_timestamp_ms() ;
  ::int64_t timestamp_ms() const;
  void set_timestamp_ms(::int64_t value);

  private:
  ::int64_t _internal_timestamp_ms() const;
  void _internal_set_timestamp_ms(::int64_t value);

  public:
  // optional uint32 remote_ssrc = 2;
  bool has_remote_ssrc() const;
  void clear_remote_ssrc() ;
  ::uint32_t remote_ssrc() const;
  void set_remote_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_remote_ssrc() const;
  void _internal_set_remote_ssrc(::uint32_t value);

  public:
  // optional uint32 local_ssrc = 3;
  bool has_local_ssrc() const;
  void clear_local_ssrc() ;
  ::uint32_t local_ssrc() const;
  void set_local_ssrc(::uint32_t value);

  private:
  ::uint32_t _internal_local_ssrc() const;
  void _internal_set_local_ssrc(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.AudioRecvStreamConfig)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::webrtc::rtclog2::RtpHeaderExtensionConfig* header_extensions_;
    ::int64_t timestamp_ms_;
    ::uint32_t remote_ssrc_;
    ::uint32_t local_ssrc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};// -------------------------------------------------------------------

class EventStream final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.rtclog2.EventStream) */ {
 public:
  inline EventStream() : EventStream(nullptr) {}
  ~EventStream() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EventStream(::google::protobuf::internal::ConstantInitialized);

  inline EventStream(const EventStream& from)
      : EventStream(nullptr, from) {}
  EventStream(EventStream&& from) noexcept
    : EventStream() {
    *this = ::std::move(from);
  }

  inline EventStream& operator=(const EventStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventStream& operator=(EventStream&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EventStream& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventStream* internal_default_instance() {
    return reinterpret_cast<const EventStream*>(
               &_EventStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EventStream& a, EventStream& b) {
    a.Swap(&b);
  }
  inline void Swap(EventStream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventStream* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventStream* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventStream>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const EventStream& from);
  void MergeFrom(const EventStream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EventStream* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.rtclog2.EventStream";
  }
  protected:
  explicit EventStream(::google::protobuf::Arena* arena);
  EventStream(::google::protobuf::Arena* arena, const EventStream& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kIncomingRtpPacketsFieldNumber = 2,
    kOutgoingRtpPacketsFieldNumber = 3,
    kIncomingRtcpPacketsFieldNumber = 4,
    kOutgoingRtcpPacketsFieldNumber = 5,
    kAudioPlayoutEventsFieldNumber = 6,
    kFrameDecodedEventsFieldNumber = 7,
    kBeginLogEventsFieldNumber = 16,
    kEndLogEventsFieldNumber = 17,
    kLossBasedBweUpdatesFieldNumber = 18,
    kDelayBasedBweUpdatesFieldNumber = 19,
    kAudioNetworkAdaptationsFieldNumber = 20,
    kProbeClustersFieldNumber = 21,
    kProbeSuccessFieldNumber = 22,
    kProbeFailureFieldNumber = 23,
    kAlrStatesFieldNumber = 24,
    kIceCandidateConfigsFieldNumber = 25,
    kIceCandidateEventsFieldNumber = 26,
    kDtlsTransportStateEventsFieldNumber = 27,
    kDtlsWritableStatesFieldNumber = 28,
    kGenericPacketsSentFieldNumber = 29,
    kGenericPacketsReceivedFieldNumber = 30,
    kGenericAcksReceivedFieldNumber = 31,
    kRouteChangesFieldNumber = 32,
    kRemoteEstimatesFieldNumber = 33,
    kNeteqSetMinimumDelayFieldNumber = 34,
    kAudioRecvStreamConfigsFieldNumber = 101,
    kAudioSendStreamConfigsFieldNumber = 102,
    kVideoRecvStreamConfigsFieldNumber = 103,
    kVideoSendStreamConfigsFieldNumber = 104,
  };
  // repeated .webrtc.rtclog2.Event stream = 1 [deprecated = true];
  [[deprecated]]  int stream_size() const;
  private:
  int _internal_stream_size() const;

  public:
  [[deprecated]]  void clear_stream() ;
  [[deprecated]] ::webrtc::rtclog2::Event* mutable_stream(int index);
  [[deprecated]] ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::Event >*
      mutable_stream();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::Event>& _internal_stream() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::Event>* _internal_mutable_stream();
  public:
  [[deprecated]] const ::webrtc::rtclog2::Event& stream(int index) const;
  [[deprecated]] ::webrtc::rtclog2::Event* add_stream();
  [[deprecated]] const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::Event >&
      stream() const;
  // repeated .webrtc.rtclog2.IncomingRtpPackets incoming_rtp_packets = 2;
  int incoming_rtp_packets_size() const;
  private:
  int _internal_incoming_rtp_packets_size() const;

  public:
  void clear_incoming_rtp_packets() ;
  ::webrtc::rtclog2::IncomingRtpPackets* mutable_incoming_rtp_packets(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IncomingRtpPackets >*
      mutable_incoming_rtp_packets();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtpPackets>& _internal_incoming_rtp_packets() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtpPackets>* _internal_mutable_incoming_rtp_packets();
  public:
  const ::webrtc::rtclog2::IncomingRtpPackets& incoming_rtp_packets(int index) const;
  ::webrtc::rtclog2::IncomingRtpPackets* add_incoming_rtp_packets();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IncomingRtpPackets >&
      incoming_rtp_packets() const;
  // repeated .webrtc.rtclog2.OutgoingRtpPackets outgoing_rtp_packets = 3;
  int outgoing_rtp_packets_size() const;
  private:
  int _internal_outgoing_rtp_packets_size() const;

  public:
  void clear_outgoing_rtp_packets() ;
  ::webrtc::rtclog2::OutgoingRtpPackets* mutable_outgoing_rtp_packets(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::OutgoingRtpPackets >*
      mutable_outgoing_rtp_packets();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtpPackets>& _internal_outgoing_rtp_packets() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtpPackets>* _internal_mutable_outgoing_rtp_packets();
  public:
  const ::webrtc::rtclog2::OutgoingRtpPackets& outgoing_rtp_packets(int index) const;
  ::webrtc::rtclog2::OutgoingRtpPackets* add_outgoing_rtp_packets();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::OutgoingRtpPackets >&
      outgoing_rtp_packets() const;
  // repeated .webrtc.rtclog2.IncomingRtcpPackets incoming_rtcp_packets = 4;
  int incoming_rtcp_packets_size() const;
  private:
  int _internal_incoming_rtcp_packets_size() const;

  public:
  void clear_incoming_rtcp_packets() ;
  ::webrtc::rtclog2::IncomingRtcpPackets* mutable_incoming_rtcp_packets(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IncomingRtcpPackets >*
      mutable_incoming_rtcp_packets();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtcpPackets>& _internal_incoming_rtcp_packets() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtcpPackets>* _internal_mutable_incoming_rtcp_packets();
  public:
  const ::webrtc::rtclog2::IncomingRtcpPackets& incoming_rtcp_packets(int index) const;
  ::webrtc::rtclog2::IncomingRtcpPackets* add_incoming_rtcp_packets();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IncomingRtcpPackets >&
      incoming_rtcp_packets() const;
  // repeated .webrtc.rtclog2.OutgoingRtcpPackets outgoing_rtcp_packets = 5;
  int outgoing_rtcp_packets_size() const;
  private:
  int _internal_outgoing_rtcp_packets_size() const;

  public:
  void clear_outgoing_rtcp_packets() ;
  ::webrtc::rtclog2::OutgoingRtcpPackets* mutable_outgoing_rtcp_packets(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::OutgoingRtcpPackets >*
      mutable_outgoing_rtcp_packets();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtcpPackets>& _internal_outgoing_rtcp_packets() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtcpPackets>* _internal_mutable_outgoing_rtcp_packets();
  public:
  const ::webrtc::rtclog2::OutgoingRtcpPackets& outgoing_rtcp_packets(int index) const;
  ::webrtc::rtclog2::OutgoingRtcpPackets* add_outgoing_rtcp_packets();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::OutgoingRtcpPackets >&
      outgoing_rtcp_packets() const;
  // repeated .webrtc.rtclog2.AudioPlayoutEvents audio_playout_events = 6;
  int audio_playout_events_size() const;
  private:
  int _internal_audio_playout_events_size() const;

  public:
  void clear_audio_playout_events() ;
  ::webrtc::rtclog2::AudioPlayoutEvents* mutable_audio_playout_events(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioPlayoutEvents >*
      mutable_audio_playout_events();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioPlayoutEvents>& _internal_audio_playout_events() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioPlayoutEvents>* _internal_mutable_audio_playout_events();
  public:
  const ::webrtc::rtclog2::AudioPlayoutEvents& audio_playout_events(int index) const;
  ::webrtc::rtclog2::AudioPlayoutEvents* add_audio_playout_events();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioPlayoutEvents >&
      audio_playout_events() const;
  // repeated .webrtc.rtclog2.FrameDecodedEvents frame_decoded_events = 7;
  int frame_decoded_events_size() const;
  private:
  int _internal_frame_decoded_events_size() const;

  public:
  void clear_frame_decoded_events() ;
  ::webrtc::rtclog2::FrameDecodedEvents* mutable_frame_decoded_events(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::FrameDecodedEvents >*
      mutable_frame_decoded_events();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::FrameDecodedEvents>& _internal_frame_decoded_events() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::FrameDecodedEvents>* _internal_mutable_frame_decoded_events();
  public:
  const ::webrtc::rtclog2::FrameDecodedEvents& frame_decoded_events(int index) const;
  ::webrtc::rtclog2::FrameDecodedEvents* add_frame_decoded_events();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::FrameDecodedEvents >&
      frame_decoded_events() const;
  // repeated .webrtc.rtclog2.BeginLogEvent begin_log_events = 16;
  int begin_log_events_size() const;
  private:
  int _internal_begin_log_events_size() const;

  public:
  void clear_begin_log_events() ;
  ::webrtc::rtclog2::BeginLogEvent* mutable_begin_log_events(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BeginLogEvent >*
      mutable_begin_log_events();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BeginLogEvent>& _internal_begin_log_events() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BeginLogEvent>* _internal_mutable_begin_log_events();
  public:
  const ::webrtc::rtclog2::BeginLogEvent& begin_log_events(int index) const;
  ::webrtc::rtclog2::BeginLogEvent* add_begin_log_events();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BeginLogEvent >&
      begin_log_events() const;
  // repeated .webrtc.rtclog2.EndLogEvent end_log_events = 17;
  int end_log_events_size() const;
  private:
  int _internal_end_log_events_size() const;

  public:
  void clear_end_log_events() ;
  ::webrtc::rtclog2::EndLogEvent* mutable_end_log_events(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::EndLogEvent >*
      mutable_end_log_events();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::EndLogEvent>& _internal_end_log_events() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::EndLogEvent>* _internal_mutable_end_log_events();
  public:
  const ::webrtc::rtclog2::EndLogEvent& end_log_events(int index) const;
  ::webrtc::rtclog2::EndLogEvent* add_end_log_events();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::EndLogEvent >&
      end_log_events() const;
  // repeated .webrtc.rtclog2.LossBasedBweUpdates loss_based_bwe_updates = 18;
  int loss_based_bwe_updates_size() const;
  private:
  int _internal_loss_based_bwe_updates_size() const;

  public:
  void clear_loss_based_bwe_updates() ;
  ::webrtc::rtclog2::LossBasedBweUpdates* mutable_loss_based_bwe_updates(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::LossBasedBweUpdates >*
      mutable_loss_based_bwe_updates();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::LossBasedBweUpdates>& _internal_loss_based_bwe_updates() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::LossBasedBweUpdates>* _internal_mutable_loss_based_bwe_updates();
  public:
  const ::webrtc::rtclog2::LossBasedBweUpdates& loss_based_bwe_updates(int index) const;
  ::webrtc::rtclog2::LossBasedBweUpdates* add_loss_based_bwe_updates();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::LossBasedBweUpdates >&
      loss_based_bwe_updates() const;
  // repeated .webrtc.rtclog2.DelayBasedBweUpdates delay_based_bwe_updates = 19;
  int delay_based_bwe_updates_size() const;
  private:
  int _internal_delay_based_bwe_updates_size() const;

  public:
  void clear_delay_based_bwe_updates() ;
  ::webrtc::rtclog2::DelayBasedBweUpdates* mutable_delay_based_bwe_updates(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::DelayBasedBweUpdates >*
      mutable_delay_based_bwe_updates();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DelayBasedBweUpdates>& _internal_delay_based_bwe_updates() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DelayBasedBweUpdates>* _internal_mutable_delay_based_bwe_updates();
  public:
  const ::webrtc::rtclog2::DelayBasedBweUpdates& delay_based_bwe_updates(int index) const;
  ::webrtc::rtclog2::DelayBasedBweUpdates* add_delay_based_bwe_updates();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::DelayBasedBweUpdates >&
      delay_based_bwe_updates() const;
  // repeated .webrtc.rtclog2.AudioNetworkAdaptations audio_network_adaptations = 20;
  int audio_network_adaptations_size() const;
  private:
  int _internal_audio_network_adaptations_size() const;

  public:
  void clear_audio_network_adaptations() ;
  ::webrtc::rtclog2::AudioNetworkAdaptations* mutable_audio_network_adaptations(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioNetworkAdaptations >*
      mutable_audio_network_adaptations();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioNetworkAdaptations>& _internal_audio_network_adaptations() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioNetworkAdaptations>* _internal_mutable_audio_network_adaptations();
  public:
  const ::webrtc::rtclog2::AudioNetworkAdaptations& audio_network_adaptations(int index) const;
  ::webrtc::rtclog2::AudioNetworkAdaptations* add_audio_network_adaptations();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioNetworkAdaptations >&
      audio_network_adaptations() const;
  // repeated .webrtc.rtclog2.BweProbeCluster probe_clusters = 21;
  int probe_clusters_size() const;
  private:
  int _internal_probe_clusters_size() const;

  public:
  void clear_probe_clusters() ;
  ::webrtc::rtclog2::BweProbeCluster* mutable_probe_clusters(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BweProbeCluster >*
      mutable_probe_clusters();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeCluster>& _internal_probe_clusters() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeCluster>* _internal_mutable_probe_clusters();
  public:
  const ::webrtc::rtclog2::BweProbeCluster& probe_clusters(int index) const;
  ::webrtc::rtclog2::BweProbeCluster* add_probe_clusters();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BweProbeCluster >&
      probe_clusters() const;
  // repeated .webrtc.rtclog2.BweProbeResultSuccess probe_success = 22;
  int probe_success_size() const;
  private:
  int _internal_probe_success_size() const;

  public:
  void clear_probe_success() ;
  ::webrtc::rtclog2::BweProbeResultSuccess* mutable_probe_success(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BweProbeResultSuccess >*
      mutable_probe_success();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultSuccess>& _internal_probe_success() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultSuccess>* _internal_mutable_probe_success();
  public:
  const ::webrtc::rtclog2::BweProbeResultSuccess& probe_success(int index) const;
  ::webrtc::rtclog2::BweProbeResultSuccess* add_probe_success();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BweProbeResultSuccess >&
      probe_success() const;
  // repeated .webrtc.rtclog2.BweProbeResultFailure probe_failure = 23;
  int probe_failure_size() const;
  private:
  int _internal_probe_failure_size() const;

  public:
  void clear_probe_failure() ;
  ::webrtc::rtclog2::BweProbeResultFailure* mutable_probe_failure(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BweProbeResultFailure >*
      mutable_probe_failure();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultFailure>& _internal_probe_failure() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultFailure>* _internal_mutable_probe_failure();
  public:
  const ::webrtc::rtclog2::BweProbeResultFailure& probe_failure(int index) const;
  ::webrtc::rtclog2::BweProbeResultFailure* add_probe_failure();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BweProbeResultFailure >&
      probe_failure() const;
  // repeated .webrtc.rtclog2.AlrState alr_states = 24;
  int alr_states_size() const;
  private:
  int _internal_alr_states_size() const;

  public:
  void clear_alr_states() ;
  ::webrtc::rtclog2::AlrState* mutable_alr_states(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AlrState >*
      mutable_alr_states();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AlrState>& _internal_alr_states() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AlrState>* _internal_mutable_alr_states();
  public:
  const ::webrtc::rtclog2::AlrState& alr_states(int index) const;
  ::webrtc::rtclog2::AlrState* add_alr_states();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AlrState >&
      alr_states() const;
  // repeated .webrtc.rtclog2.IceCandidatePairConfig ice_candidate_configs = 25;
  int ice_candidate_configs_size() const;
  private:
  int _internal_ice_candidate_configs_size() const;

  public:
  void clear_ice_candidate_configs() ;
  ::webrtc::rtclog2::IceCandidatePairConfig* mutable_ice_candidate_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IceCandidatePairConfig >*
      mutable_ice_candidate_configs();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairConfig>& _internal_ice_candidate_configs() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairConfig>* _internal_mutable_ice_candidate_configs();
  public:
  const ::webrtc::rtclog2::IceCandidatePairConfig& ice_candidate_configs(int index) const;
  ::webrtc::rtclog2::IceCandidatePairConfig* add_ice_candidate_configs();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IceCandidatePairConfig >&
      ice_candidate_configs() const;
  // repeated .webrtc.rtclog2.IceCandidatePairEvent ice_candidate_events = 26;
  int ice_candidate_events_size() const;
  private:
  int _internal_ice_candidate_events_size() const;

  public:
  void clear_ice_candidate_events() ;
  ::webrtc::rtclog2::IceCandidatePairEvent* mutable_ice_candidate_events(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IceCandidatePairEvent >*
      mutable_ice_candidate_events();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairEvent>& _internal_ice_candidate_events() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairEvent>* _internal_mutable_ice_candidate_events();
  public:
  const ::webrtc::rtclog2::IceCandidatePairEvent& ice_candidate_events(int index) const;
  ::webrtc::rtclog2::IceCandidatePairEvent* add_ice_candidate_events();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IceCandidatePairEvent >&
      ice_candidate_events() const;
  // repeated .webrtc.rtclog2.DtlsTransportStateEvent dtls_transport_state_events = 27;
  int dtls_transport_state_events_size() const;
  private:
  int _internal_dtls_transport_state_events_size() const;

  public:
  void clear_dtls_transport_state_events() ;
  ::webrtc::rtclog2::DtlsTransportStateEvent* mutable_dtls_transport_state_events(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::DtlsTransportStateEvent >*
      mutable_dtls_transport_state_events();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsTransportStateEvent>& _internal_dtls_transport_state_events() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsTransportStateEvent>* _internal_mutable_dtls_transport_state_events();
  public:
  const ::webrtc::rtclog2::DtlsTransportStateEvent& dtls_transport_state_events(int index) const;
  ::webrtc::rtclog2::DtlsTransportStateEvent* add_dtls_transport_state_events();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::DtlsTransportStateEvent >&
      dtls_transport_state_events() const;
  // repeated .webrtc.rtclog2.DtlsWritableState dtls_writable_states = 28;
  int dtls_writable_states_size() const;
  private:
  int _internal_dtls_writable_states_size() const;

  public:
  void clear_dtls_writable_states() ;
  ::webrtc::rtclog2::DtlsWritableState* mutable_dtls_writable_states(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::DtlsWritableState >*
      mutable_dtls_writable_states();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsWritableState>& _internal_dtls_writable_states() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsWritableState>* _internal_mutable_dtls_writable_states();
  public:
  const ::webrtc::rtclog2::DtlsWritableState& dtls_writable_states(int index) const;
  ::webrtc::rtclog2::DtlsWritableState* add_dtls_writable_states();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::DtlsWritableState >&
      dtls_writable_states() const;
  // repeated .webrtc.rtclog2.GenericPacketSent generic_packets_sent = 29;
  int generic_packets_sent_size() const;
  private:
  int _internal_generic_packets_sent_size() const;

  public:
  void clear_generic_packets_sent() ;
  ::webrtc::rtclog2::GenericPacketSent* mutable_generic_packets_sent(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::GenericPacketSent >*
      mutable_generic_packets_sent();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketSent>& _internal_generic_packets_sent() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketSent>* _internal_mutable_generic_packets_sent();
  public:
  const ::webrtc::rtclog2::GenericPacketSent& generic_packets_sent(int index) const;
  ::webrtc::rtclog2::GenericPacketSent* add_generic_packets_sent();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::GenericPacketSent >&
      generic_packets_sent() const;
  // repeated .webrtc.rtclog2.GenericPacketReceived generic_packets_received = 30;
  int generic_packets_received_size() const;
  private:
  int _internal_generic_packets_received_size() const;

  public:
  void clear_generic_packets_received() ;
  ::webrtc::rtclog2::GenericPacketReceived* mutable_generic_packets_received(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::GenericPacketReceived >*
      mutable_generic_packets_received();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketReceived>& _internal_generic_packets_received() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketReceived>* _internal_mutable_generic_packets_received();
  public:
  const ::webrtc::rtclog2::GenericPacketReceived& generic_packets_received(int index) const;
  ::webrtc::rtclog2::GenericPacketReceived* add_generic_packets_received();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::GenericPacketReceived >&
      generic_packets_received() const;
  // repeated .webrtc.rtclog2.GenericAckReceived generic_acks_received = 31;
  int generic_acks_received_size() const;
  private:
  int _internal_generic_acks_received_size() const;

  public:
  void clear_generic_acks_received() ;
  ::webrtc::rtclog2::GenericAckReceived* mutable_generic_acks_received(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::GenericAckReceived >*
      mutable_generic_acks_received();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericAckReceived>& _internal_generic_acks_received() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericAckReceived>* _internal_mutable_generic_acks_received();
  public:
  const ::webrtc::rtclog2::GenericAckReceived& generic_acks_received(int index) const;
  ::webrtc::rtclog2::GenericAckReceived* add_generic_acks_received();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::GenericAckReceived >&
      generic_acks_received() const;
  // repeated .webrtc.rtclog2.RouteChange route_changes = 32;
  int route_changes_size() const;
  private:
  int _internal_route_changes_size() const;

  public:
  void clear_route_changes() ;
  ::webrtc::rtclog2::RouteChange* mutable_route_changes(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::RouteChange >*
      mutable_route_changes();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RouteChange>& _internal_route_changes() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RouteChange>* _internal_mutable_route_changes();
  public:
  const ::webrtc::rtclog2::RouteChange& route_changes(int index) const;
  ::webrtc::rtclog2::RouteChange* add_route_changes();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::RouteChange >&
      route_changes() const;
  // repeated .webrtc.rtclog2.RemoteEstimates remote_estimates = 33;
  int remote_estimates_size() const;
  private:
  int _internal_remote_estimates_size() const;

  public:
  void clear_remote_estimates() ;
  ::webrtc::rtclog2::RemoteEstimates* mutable_remote_estimates(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::RemoteEstimates >*
      mutable_remote_estimates();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RemoteEstimates>& _internal_remote_estimates() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RemoteEstimates>* _internal_mutable_remote_estimates();
  public:
  const ::webrtc::rtclog2::RemoteEstimates& remote_estimates(int index) const;
  ::webrtc::rtclog2::RemoteEstimates* add_remote_estimates();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::RemoteEstimates >&
      remote_estimates() const;
  // repeated .webrtc.rtclog2.NetEqSetMinimumDelay neteq_set_minimum_delay = 34;
  int neteq_set_minimum_delay_size() const;
  private:
  int _internal_neteq_set_minimum_delay_size() const;

  public:
  void clear_neteq_set_minimum_delay() ;
  ::webrtc::rtclog2::NetEqSetMinimumDelay* mutable_neteq_set_minimum_delay(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::NetEqSetMinimumDelay >*
      mutable_neteq_set_minimum_delay();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::NetEqSetMinimumDelay>& _internal_neteq_set_minimum_delay() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::NetEqSetMinimumDelay>* _internal_mutable_neteq_set_minimum_delay();
  public:
  const ::webrtc::rtclog2::NetEqSetMinimumDelay& neteq_set_minimum_delay(int index) const;
  ::webrtc::rtclog2::NetEqSetMinimumDelay* add_neteq_set_minimum_delay();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::NetEqSetMinimumDelay >&
      neteq_set_minimum_delay() const;
  // repeated .webrtc.rtclog2.AudioRecvStreamConfig audio_recv_stream_configs = 101;
  int audio_recv_stream_configs_size() const;
  private:
  int _internal_audio_recv_stream_configs_size() const;

  public:
  void clear_audio_recv_stream_configs() ;
  ::webrtc::rtclog2::AudioRecvStreamConfig* mutable_audio_recv_stream_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioRecvStreamConfig >*
      mutable_audio_recv_stream_configs();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioRecvStreamConfig>& _internal_audio_recv_stream_configs() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioRecvStreamConfig>* _internal_mutable_audio_recv_stream_configs();
  public:
  const ::webrtc::rtclog2::AudioRecvStreamConfig& audio_recv_stream_configs(int index) const;
  ::webrtc::rtclog2::AudioRecvStreamConfig* add_audio_recv_stream_configs();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioRecvStreamConfig >&
      audio_recv_stream_configs() const;
  // repeated .webrtc.rtclog2.AudioSendStreamConfig audio_send_stream_configs = 102;
  int audio_send_stream_configs_size() const;
  private:
  int _internal_audio_send_stream_configs_size() const;

  public:
  void clear_audio_send_stream_configs() ;
  ::webrtc::rtclog2::AudioSendStreamConfig* mutable_audio_send_stream_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioSendStreamConfig >*
      mutable_audio_send_stream_configs();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioSendStreamConfig>& _internal_audio_send_stream_configs() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioSendStreamConfig>* _internal_mutable_audio_send_stream_configs();
  public:
  const ::webrtc::rtclog2::AudioSendStreamConfig& audio_send_stream_configs(int index) const;
  ::webrtc::rtclog2::AudioSendStreamConfig* add_audio_send_stream_configs();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioSendStreamConfig >&
      audio_send_stream_configs() const;
  // repeated .webrtc.rtclog2.VideoRecvStreamConfig video_recv_stream_configs = 103;
  int video_recv_stream_configs_size() const;
  private:
  int _internal_video_recv_stream_configs_size() const;

  public:
  void clear_video_recv_stream_configs() ;
  ::webrtc::rtclog2::VideoRecvStreamConfig* mutable_video_recv_stream_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::VideoRecvStreamConfig >*
      mutable_video_recv_stream_configs();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoRecvStreamConfig>& _internal_video_recv_stream_configs() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoRecvStreamConfig>* _internal_mutable_video_recv_stream_configs();
  public:
  const ::webrtc::rtclog2::VideoRecvStreamConfig& video_recv_stream_configs(int index) const;
  ::webrtc::rtclog2::VideoRecvStreamConfig* add_video_recv_stream_configs();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::VideoRecvStreamConfig >&
      video_recv_stream_configs() const;
  // repeated .webrtc.rtclog2.VideoSendStreamConfig video_send_stream_configs = 104;
  int video_send_stream_configs_size() const;
  private:
  int _internal_video_send_stream_configs_size() const;

  public:
  void clear_video_send_stream_configs() ;
  ::webrtc::rtclog2::VideoSendStreamConfig* mutable_video_send_stream_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::VideoSendStreamConfig >*
      mutable_video_send_stream_configs();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoSendStreamConfig>& _internal_video_send_stream_configs() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoSendStreamConfig>* _internal_mutable_video_send_stream_configs();
  public:
  const ::webrtc::rtclog2::VideoSendStreamConfig& video_send_stream_configs(int index) const;
  ::webrtc::rtclog2::VideoSendStreamConfig* add_video_send_stream_configs();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::VideoSendStreamConfig >&
      video_send_stream_configs() const;
  // @@protoc_insertion_point(class_scope:webrtc.rtclog2.EventStream)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 30, 30,
      0, 15>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::Event > stream_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IncomingRtpPackets > incoming_rtp_packets_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::OutgoingRtpPackets > outgoing_rtp_packets_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IncomingRtcpPackets > incoming_rtcp_packets_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::OutgoingRtcpPackets > outgoing_rtcp_packets_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioPlayoutEvents > audio_playout_events_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::FrameDecodedEvents > frame_decoded_events_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BeginLogEvent > begin_log_events_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::EndLogEvent > end_log_events_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::LossBasedBweUpdates > loss_based_bwe_updates_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::DelayBasedBweUpdates > delay_based_bwe_updates_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioNetworkAdaptations > audio_network_adaptations_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BweProbeCluster > probe_clusters_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BweProbeResultSuccess > probe_success_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::BweProbeResultFailure > probe_failure_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AlrState > alr_states_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IceCandidatePairConfig > ice_candidate_configs_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::IceCandidatePairEvent > ice_candidate_events_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::DtlsTransportStateEvent > dtls_transport_state_events_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::DtlsWritableState > dtls_writable_states_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::GenericPacketSent > generic_packets_sent_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::GenericPacketReceived > generic_packets_received_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::GenericAckReceived > generic_acks_received_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::RouteChange > route_changes_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::RemoteEstimates > remote_estimates_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::NetEqSetMinimumDelay > neteq_set_minimum_delay_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioRecvStreamConfig > audio_recv_stream_configs_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::AudioSendStreamConfig > audio_send_stream_configs_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::VideoRecvStreamConfig > video_recv_stream_configs_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::rtclog2::VideoSendStreamConfig > video_send_stream_configs_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rtc_5fevent_5flog2_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// EventStream

// repeated .webrtc.rtclog2.Event stream = 1 [deprecated = true];
inline int EventStream::_internal_stream_size() const {
  return _internal_stream().size();
}
inline int EventStream::stream_size() const {
  return _internal_stream_size();
}
inline void EventStream::clear_stream() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stream_.Clear();
}
inline ::webrtc::rtclog2::Event* EventStream::mutable_stream(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.stream)
  return _internal_mutable_stream()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::Event>* EventStream::mutable_stream()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.stream)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_stream();
}
inline const ::webrtc::rtclog2::Event& EventStream::stream(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.stream)
  return _internal_stream().Get(index);
}
inline ::webrtc::rtclog2::Event* EventStream::add_stream() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::Event* _add = _internal_mutable_stream()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.stream)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::Event>& EventStream::stream() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.stream)
  return _internal_stream();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::Event>&
EventStream::_internal_stream() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stream_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::Event>*
EventStream::_internal_mutable_stream() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.stream_;
}

// repeated .webrtc.rtclog2.IncomingRtpPackets incoming_rtp_packets = 2;
inline int EventStream::_internal_incoming_rtp_packets_size() const {
  return _internal_incoming_rtp_packets().size();
}
inline int EventStream::incoming_rtp_packets_size() const {
  return _internal_incoming_rtp_packets_size();
}
inline void EventStream::clear_incoming_rtp_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.incoming_rtp_packets_.Clear();
}
inline ::webrtc::rtclog2::IncomingRtpPackets* EventStream::mutable_incoming_rtp_packets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.incoming_rtp_packets)
  return _internal_mutable_incoming_rtp_packets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtpPackets>* EventStream::mutable_incoming_rtp_packets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.incoming_rtp_packets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_incoming_rtp_packets();
}
inline const ::webrtc::rtclog2::IncomingRtpPackets& EventStream::incoming_rtp_packets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.incoming_rtp_packets)
  return _internal_incoming_rtp_packets().Get(index);
}
inline ::webrtc::rtclog2::IncomingRtpPackets* EventStream::add_incoming_rtp_packets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::IncomingRtpPackets* _add = _internal_mutable_incoming_rtp_packets()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.incoming_rtp_packets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtpPackets>& EventStream::incoming_rtp_packets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.incoming_rtp_packets)
  return _internal_incoming_rtp_packets();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtpPackets>&
EventStream::_internal_incoming_rtp_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.incoming_rtp_packets_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtpPackets>*
EventStream::_internal_mutable_incoming_rtp_packets() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.incoming_rtp_packets_;
}

// repeated .webrtc.rtclog2.OutgoingRtpPackets outgoing_rtp_packets = 3;
inline int EventStream::_internal_outgoing_rtp_packets_size() const {
  return _internal_outgoing_rtp_packets().size();
}
inline int EventStream::outgoing_rtp_packets_size() const {
  return _internal_outgoing_rtp_packets_size();
}
inline void EventStream::clear_outgoing_rtp_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.outgoing_rtp_packets_.Clear();
}
inline ::webrtc::rtclog2::OutgoingRtpPackets* EventStream::mutable_outgoing_rtp_packets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.outgoing_rtp_packets)
  return _internal_mutable_outgoing_rtp_packets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtpPackets>* EventStream::mutable_outgoing_rtp_packets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.outgoing_rtp_packets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_outgoing_rtp_packets();
}
inline const ::webrtc::rtclog2::OutgoingRtpPackets& EventStream::outgoing_rtp_packets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.outgoing_rtp_packets)
  return _internal_outgoing_rtp_packets().Get(index);
}
inline ::webrtc::rtclog2::OutgoingRtpPackets* EventStream::add_outgoing_rtp_packets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::OutgoingRtpPackets* _add = _internal_mutable_outgoing_rtp_packets()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.outgoing_rtp_packets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtpPackets>& EventStream::outgoing_rtp_packets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.outgoing_rtp_packets)
  return _internal_outgoing_rtp_packets();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtpPackets>&
EventStream::_internal_outgoing_rtp_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.outgoing_rtp_packets_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtpPackets>*
EventStream::_internal_mutable_outgoing_rtp_packets() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.outgoing_rtp_packets_;
}

// repeated .webrtc.rtclog2.IncomingRtcpPackets incoming_rtcp_packets = 4;
inline int EventStream::_internal_incoming_rtcp_packets_size() const {
  return _internal_incoming_rtcp_packets().size();
}
inline int EventStream::incoming_rtcp_packets_size() const {
  return _internal_incoming_rtcp_packets_size();
}
inline void EventStream::clear_incoming_rtcp_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.incoming_rtcp_packets_.Clear();
}
inline ::webrtc::rtclog2::IncomingRtcpPackets* EventStream::mutable_incoming_rtcp_packets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.incoming_rtcp_packets)
  return _internal_mutable_incoming_rtcp_packets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtcpPackets>* EventStream::mutable_incoming_rtcp_packets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.incoming_rtcp_packets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_incoming_rtcp_packets();
}
inline const ::webrtc::rtclog2::IncomingRtcpPackets& EventStream::incoming_rtcp_packets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.incoming_rtcp_packets)
  return _internal_incoming_rtcp_packets().Get(index);
}
inline ::webrtc::rtclog2::IncomingRtcpPackets* EventStream::add_incoming_rtcp_packets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::IncomingRtcpPackets* _add = _internal_mutable_incoming_rtcp_packets()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.incoming_rtcp_packets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtcpPackets>& EventStream::incoming_rtcp_packets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.incoming_rtcp_packets)
  return _internal_incoming_rtcp_packets();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtcpPackets>&
EventStream::_internal_incoming_rtcp_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.incoming_rtcp_packets_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IncomingRtcpPackets>*
EventStream::_internal_mutable_incoming_rtcp_packets() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.incoming_rtcp_packets_;
}

// repeated .webrtc.rtclog2.OutgoingRtcpPackets outgoing_rtcp_packets = 5;
inline int EventStream::_internal_outgoing_rtcp_packets_size() const {
  return _internal_outgoing_rtcp_packets().size();
}
inline int EventStream::outgoing_rtcp_packets_size() const {
  return _internal_outgoing_rtcp_packets_size();
}
inline void EventStream::clear_outgoing_rtcp_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.outgoing_rtcp_packets_.Clear();
}
inline ::webrtc::rtclog2::OutgoingRtcpPackets* EventStream::mutable_outgoing_rtcp_packets(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.outgoing_rtcp_packets)
  return _internal_mutable_outgoing_rtcp_packets()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtcpPackets>* EventStream::mutable_outgoing_rtcp_packets()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.outgoing_rtcp_packets)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_outgoing_rtcp_packets();
}
inline const ::webrtc::rtclog2::OutgoingRtcpPackets& EventStream::outgoing_rtcp_packets(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.outgoing_rtcp_packets)
  return _internal_outgoing_rtcp_packets().Get(index);
}
inline ::webrtc::rtclog2::OutgoingRtcpPackets* EventStream::add_outgoing_rtcp_packets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::OutgoingRtcpPackets* _add = _internal_mutable_outgoing_rtcp_packets()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.outgoing_rtcp_packets)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtcpPackets>& EventStream::outgoing_rtcp_packets() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.outgoing_rtcp_packets)
  return _internal_outgoing_rtcp_packets();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtcpPackets>&
EventStream::_internal_outgoing_rtcp_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.outgoing_rtcp_packets_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::OutgoingRtcpPackets>*
EventStream::_internal_mutable_outgoing_rtcp_packets() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.outgoing_rtcp_packets_;
}

// repeated .webrtc.rtclog2.AudioPlayoutEvents audio_playout_events = 6;
inline int EventStream::_internal_audio_playout_events_size() const {
  return _internal_audio_playout_events().size();
}
inline int EventStream::audio_playout_events_size() const {
  return _internal_audio_playout_events_size();
}
inline void EventStream::clear_audio_playout_events() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_playout_events_.Clear();
}
inline ::webrtc::rtclog2::AudioPlayoutEvents* EventStream::mutable_audio_playout_events(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.audio_playout_events)
  return _internal_mutable_audio_playout_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioPlayoutEvents>* EventStream::mutable_audio_playout_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.audio_playout_events)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_audio_playout_events();
}
inline const ::webrtc::rtclog2::AudioPlayoutEvents& EventStream::audio_playout_events(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.audio_playout_events)
  return _internal_audio_playout_events().Get(index);
}
inline ::webrtc::rtclog2::AudioPlayoutEvents* EventStream::add_audio_playout_events() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::AudioPlayoutEvents* _add = _internal_mutable_audio_playout_events()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.audio_playout_events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioPlayoutEvents>& EventStream::audio_playout_events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.audio_playout_events)
  return _internal_audio_playout_events();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioPlayoutEvents>&
EventStream::_internal_audio_playout_events() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_playout_events_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioPlayoutEvents>*
EventStream::_internal_mutable_audio_playout_events() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.audio_playout_events_;
}

// repeated .webrtc.rtclog2.FrameDecodedEvents frame_decoded_events = 7;
inline int EventStream::_internal_frame_decoded_events_size() const {
  return _internal_frame_decoded_events().size();
}
inline int EventStream::frame_decoded_events_size() const {
  return _internal_frame_decoded_events_size();
}
inline void EventStream::clear_frame_decoded_events() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_decoded_events_.Clear();
}
inline ::webrtc::rtclog2::FrameDecodedEvents* EventStream::mutable_frame_decoded_events(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.frame_decoded_events)
  return _internal_mutable_frame_decoded_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::FrameDecodedEvents>* EventStream::mutable_frame_decoded_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.frame_decoded_events)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_frame_decoded_events();
}
inline const ::webrtc::rtclog2::FrameDecodedEvents& EventStream::frame_decoded_events(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.frame_decoded_events)
  return _internal_frame_decoded_events().Get(index);
}
inline ::webrtc::rtclog2::FrameDecodedEvents* EventStream::add_frame_decoded_events() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::FrameDecodedEvents* _add = _internal_mutable_frame_decoded_events()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.frame_decoded_events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::FrameDecodedEvents>& EventStream::frame_decoded_events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.frame_decoded_events)
  return _internal_frame_decoded_events();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::FrameDecodedEvents>&
EventStream::_internal_frame_decoded_events() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_decoded_events_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::FrameDecodedEvents>*
EventStream::_internal_mutable_frame_decoded_events() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.frame_decoded_events_;
}

// repeated .webrtc.rtclog2.BeginLogEvent begin_log_events = 16;
inline int EventStream::_internal_begin_log_events_size() const {
  return _internal_begin_log_events().size();
}
inline int EventStream::begin_log_events_size() const {
  return _internal_begin_log_events_size();
}
inline void EventStream::clear_begin_log_events() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_log_events_.Clear();
}
inline ::webrtc::rtclog2::BeginLogEvent* EventStream::mutable_begin_log_events(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.begin_log_events)
  return _internal_mutable_begin_log_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BeginLogEvent>* EventStream::mutable_begin_log_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.begin_log_events)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_begin_log_events();
}
inline const ::webrtc::rtclog2::BeginLogEvent& EventStream::begin_log_events(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.begin_log_events)
  return _internal_begin_log_events().Get(index);
}
inline ::webrtc::rtclog2::BeginLogEvent* EventStream::add_begin_log_events() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::BeginLogEvent* _add = _internal_mutable_begin_log_events()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.begin_log_events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BeginLogEvent>& EventStream::begin_log_events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.begin_log_events)
  return _internal_begin_log_events();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BeginLogEvent>&
EventStream::_internal_begin_log_events() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_log_events_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BeginLogEvent>*
EventStream::_internal_mutable_begin_log_events() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.begin_log_events_;
}

// repeated .webrtc.rtclog2.EndLogEvent end_log_events = 17;
inline int EventStream::_internal_end_log_events_size() const {
  return _internal_end_log_events().size();
}
inline int EventStream::end_log_events_size() const {
  return _internal_end_log_events_size();
}
inline void EventStream::clear_end_log_events() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_log_events_.Clear();
}
inline ::webrtc::rtclog2::EndLogEvent* EventStream::mutable_end_log_events(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.end_log_events)
  return _internal_mutable_end_log_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::EndLogEvent>* EventStream::mutable_end_log_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.end_log_events)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_end_log_events();
}
inline const ::webrtc::rtclog2::EndLogEvent& EventStream::end_log_events(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.end_log_events)
  return _internal_end_log_events().Get(index);
}
inline ::webrtc::rtclog2::EndLogEvent* EventStream::add_end_log_events() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::EndLogEvent* _add = _internal_mutable_end_log_events()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.end_log_events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::EndLogEvent>& EventStream::end_log_events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.end_log_events)
  return _internal_end_log_events();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::EndLogEvent>&
EventStream::_internal_end_log_events() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_log_events_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::EndLogEvent>*
EventStream::_internal_mutable_end_log_events() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.end_log_events_;
}

// repeated .webrtc.rtclog2.LossBasedBweUpdates loss_based_bwe_updates = 18;
inline int EventStream::_internal_loss_based_bwe_updates_size() const {
  return _internal_loss_based_bwe_updates().size();
}
inline int EventStream::loss_based_bwe_updates_size() const {
  return _internal_loss_based_bwe_updates_size();
}
inline void EventStream::clear_loss_based_bwe_updates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.loss_based_bwe_updates_.Clear();
}
inline ::webrtc::rtclog2::LossBasedBweUpdates* EventStream::mutable_loss_based_bwe_updates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.loss_based_bwe_updates)
  return _internal_mutable_loss_based_bwe_updates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::LossBasedBweUpdates>* EventStream::mutable_loss_based_bwe_updates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.loss_based_bwe_updates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_loss_based_bwe_updates();
}
inline const ::webrtc::rtclog2::LossBasedBweUpdates& EventStream::loss_based_bwe_updates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.loss_based_bwe_updates)
  return _internal_loss_based_bwe_updates().Get(index);
}
inline ::webrtc::rtclog2::LossBasedBweUpdates* EventStream::add_loss_based_bwe_updates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::LossBasedBweUpdates* _add = _internal_mutable_loss_based_bwe_updates()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.loss_based_bwe_updates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::LossBasedBweUpdates>& EventStream::loss_based_bwe_updates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.loss_based_bwe_updates)
  return _internal_loss_based_bwe_updates();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::LossBasedBweUpdates>&
EventStream::_internal_loss_based_bwe_updates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.loss_based_bwe_updates_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::LossBasedBweUpdates>*
EventStream::_internal_mutable_loss_based_bwe_updates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.loss_based_bwe_updates_;
}

// repeated .webrtc.rtclog2.DelayBasedBweUpdates delay_based_bwe_updates = 19;
inline int EventStream::_internal_delay_based_bwe_updates_size() const {
  return _internal_delay_based_bwe_updates().size();
}
inline int EventStream::delay_based_bwe_updates_size() const {
  return _internal_delay_based_bwe_updates_size();
}
inline void EventStream::clear_delay_based_bwe_updates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.delay_based_bwe_updates_.Clear();
}
inline ::webrtc::rtclog2::DelayBasedBweUpdates* EventStream::mutable_delay_based_bwe_updates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.delay_based_bwe_updates)
  return _internal_mutable_delay_based_bwe_updates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DelayBasedBweUpdates>* EventStream::mutable_delay_based_bwe_updates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.delay_based_bwe_updates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_delay_based_bwe_updates();
}
inline const ::webrtc::rtclog2::DelayBasedBweUpdates& EventStream::delay_based_bwe_updates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.delay_based_bwe_updates)
  return _internal_delay_based_bwe_updates().Get(index);
}
inline ::webrtc::rtclog2::DelayBasedBweUpdates* EventStream::add_delay_based_bwe_updates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::DelayBasedBweUpdates* _add = _internal_mutable_delay_based_bwe_updates()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.delay_based_bwe_updates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DelayBasedBweUpdates>& EventStream::delay_based_bwe_updates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.delay_based_bwe_updates)
  return _internal_delay_based_bwe_updates();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DelayBasedBweUpdates>&
EventStream::_internal_delay_based_bwe_updates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.delay_based_bwe_updates_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DelayBasedBweUpdates>*
EventStream::_internal_mutable_delay_based_bwe_updates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.delay_based_bwe_updates_;
}

// repeated .webrtc.rtclog2.AudioNetworkAdaptations audio_network_adaptations = 20;
inline int EventStream::_internal_audio_network_adaptations_size() const {
  return _internal_audio_network_adaptations().size();
}
inline int EventStream::audio_network_adaptations_size() const {
  return _internal_audio_network_adaptations_size();
}
inline void EventStream::clear_audio_network_adaptations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_network_adaptations_.Clear();
}
inline ::webrtc::rtclog2::AudioNetworkAdaptations* EventStream::mutable_audio_network_adaptations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.audio_network_adaptations)
  return _internal_mutable_audio_network_adaptations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioNetworkAdaptations>* EventStream::mutable_audio_network_adaptations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.audio_network_adaptations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_audio_network_adaptations();
}
inline const ::webrtc::rtclog2::AudioNetworkAdaptations& EventStream::audio_network_adaptations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.audio_network_adaptations)
  return _internal_audio_network_adaptations().Get(index);
}
inline ::webrtc::rtclog2::AudioNetworkAdaptations* EventStream::add_audio_network_adaptations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::AudioNetworkAdaptations* _add = _internal_mutable_audio_network_adaptations()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.audio_network_adaptations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioNetworkAdaptations>& EventStream::audio_network_adaptations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.audio_network_adaptations)
  return _internal_audio_network_adaptations();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioNetworkAdaptations>&
EventStream::_internal_audio_network_adaptations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_network_adaptations_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioNetworkAdaptations>*
EventStream::_internal_mutable_audio_network_adaptations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.audio_network_adaptations_;
}

// repeated .webrtc.rtclog2.BweProbeCluster probe_clusters = 21;
inline int EventStream::_internal_probe_clusters_size() const {
  return _internal_probe_clusters().size();
}
inline int EventStream::probe_clusters_size() const {
  return _internal_probe_clusters_size();
}
inline void EventStream::clear_probe_clusters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.probe_clusters_.Clear();
}
inline ::webrtc::rtclog2::BweProbeCluster* EventStream::mutable_probe_clusters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.probe_clusters)
  return _internal_mutable_probe_clusters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeCluster>* EventStream::mutable_probe_clusters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.probe_clusters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_probe_clusters();
}
inline const ::webrtc::rtclog2::BweProbeCluster& EventStream::probe_clusters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.probe_clusters)
  return _internal_probe_clusters().Get(index);
}
inline ::webrtc::rtclog2::BweProbeCluster* EventStream::add_probe_clusters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::BweProbeCluster* _add = _internal_mutable_probe_clusters()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.probe_clusters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeCluster>& EventStream::probe_clusters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.probe_clusters)
  return _internal_probe_clusters();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeCluster>&
EventStream::_internal_probe_clusters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.probe_clusters_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeCluster>*
EventStream::_internal_mutable_probe_clusters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.probe_clusters_;
}

// repeated .webrtc.rtclog2.BweProbeResultSuccess probe_success = 22;
inline int EventStream::_internal_probe_success_size() const {
  return _internal_probe_success().size();
}
inline int EventStream::probe_success_size() const {
  return _internal_probe_success_size();
}
inline void EventStream::clear_probe_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.probe_success_.Clear();
}
inline ::webrtc::rtclog2::BweProbeResultSuccess* EventStream::mutable_probe_success(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.probe_success)
  return _internal_mutable_probe_success()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultSuccess>* EventStream::mutable_probe_success()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.probe_success)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_probe_success();
}
inline const ::webrtc::rtclog2::BweProbeResultSuccess& EventStream::probe_success(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.probe_success)
  return _internal_probe_success().Get(index);
}
inline ::webrtc::rtclog2::BweProbeResultSuccess* EventStream::add_probe_success() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::BweProbeResultSuccess* _add = _internal_mutable_probe_success()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.probe_success)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultSuccess>& EventStream::probe_success() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.probe_success)
  return _internal_probe_success();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultSuccess>&
EventStream::_internal_probe_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.probe_success_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultSuccess>*
EventStream::_internal_mutable_probe_success() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.probe_success_;
}

// repeated .webrtc.rtclog2.BweProbeResultFailure probe_failure = 23;
inline int EventStream::_internal_probe_failure_size() const {
  return _internal_probe_failure().size();
}
inline int EventStream::probe_failure_size() const {
  return _internal_probe_failure_size();
}
inline void EventStream::clear_probe_failure() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.probe_failure_.Clear();
}
inline ::webrtc::rtclog2::BweProbeResultFailure* EventStream::mutable_probe_failure(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.probe_failure)
  return _internal_mutable_probe_failure()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultFailure>* EventStream::mutable_probe_failure()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.probe_failure)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_probe_failure();
}
inline const ::webrtc::rtclog2::BweProbeResultFailure& EventStream::probe_failure(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.probe_failure)
  return _internal_probe_failure().Get(index);
}
inline ::webrtc::rtclog2::BweProbeResultFailure* EventStream::add_probe_failure() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::BweProbeResultFailure* _add = _internal_mutable_probe_failure()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.probe_failure)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultFailure>& EventStream::probe_failure() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.probe_failure)
  return _internal_probe_failure();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultFailure>&
EventStream::_internal_probe_failure() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.probe_failure_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::BweProbeResultFailure>*
EventStream::_internal_mutable_probe_failure() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.probe_failure_;
}

// repeated .webrtc.rtclog2.AlrState alr_states = 24;
inline int EventStream::_internal_alr_states_size() const {
  return _internal_alr_states().size();
}
inline int EventStream::alr_states_size() const {
  return _internal_alr_states_size();
}
inline void EventStream::clear_alr_states() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alr_states_.Clear();
}
inline ::webrtc::rtclog2::AlrState* EventStream::mutable_alr_states(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.alr_states)
  return _internal_mutable_alr_states()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AlrState>* EventStream::mutable_alr_states()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.alr_states)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_alr_states();
}
inline const ::webrtc::rtclog2::AlrState& EventStream::alr_states(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.alr_states)
  return _internal_alr_states().Get(index);
}
inline ::webrtc::rtclog2::AlrState* EventStream::add_alr_states() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::AlrState* _add = _internal_mutable_alr_states()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.alr_states)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AlrState>& EventStream::alr_states() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.alr_states)
  return _internal_alr_states();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AlrState>&
EventStream::_internal_alr_states() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.alr_states_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AlrState>*
EventStream::_internal_mutable_alr_states() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.alr_states_;
}

// repeated .webrtc.rtclog2.IceCandidatePairConfig ice_candidate_configs = 25;
inline int EventStream::_internal_ice_candidate_configs_size() const {
  return _internal_ice_candidate_configs().size();
}
inline int EventStream::ice_candidate_configs_size() const {
  return _internal_ice_candidate_configs_size();
}
inline void EventStream::clear_ice_candidate_configs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ice_candidate_configs_.Clear();
}
inline ::webrtc::rtclog2::IceCandidatePairConfig* EventStream::mutable_ice_candidate_configs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.ice_candidate_configs)
  return _internal_mutable_ice_candidate_configs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairConfig>* EventStream::mutable_ice_candidate_configs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.ice_candidate_configs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ice_candidate_configs();
}
inline const ::webrtc::rtclog2::IceCandidatePairConfig& EventStream::ice_candidate_configs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.ice_candidate_configs)
  return _internal_ice_candidate_configs().Get(index);
}
inline ::webrtc::rtclog2::IceCandidatePairConfig* EventStream::add_ice_candidate_configs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::IceCandidatePairConfig* _add = _internal_mutable_ice_candidate_configs()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.ice_candidate_configs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairConfig>& EventStream::ice_candidate_configs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.ice_candidate_configs)
  return _internal_ice_candidate_configs();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairConfig>&
EventStream::_internal_ice_candidate_configs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ice_candidate_configs_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairConfig>*
EventStream::_internal_mutable_ice_candidate_configs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ice_candidate_configs_;
}

// repeated .webrtc.rtclog2.IceCandidatePairEvent ice_candidate_events = 26;
inline int EventStream::_internal_ice_candidate_events_size() const {
  return _internal_ice_candidate_events().size();
}
inline int EventStream::ice_candidate_events_size() const {
  return _internal_ice_candidate_events_size();
}
inline void EventStream::clear_ice_candidate_events() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ice_candidate_events_.Clear();
}
inline ::webrtc::rtclog2::IceCandidatePairEvent* EventStream::mutable_ice_candidate_events(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.ice_candidate_events)
  return _internal_mutable_ice_candidate_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairEvent>* EventStream::mutable_ice_candidate_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.ice_candidate_events)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ice_candidate_events();
}
inline const ::webrtc::rtclog2::IceCandidatePairEvent& EventStream::ice_candidate_events(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.ice_candidate_events)
  return _internal_ice_candidate_events().Get(index);
}
inline ::webrtc::rtclog2::IceCandidatePairEvent* EventStream::add_ice_candidate_events() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::IceCandidatePairEvent* _add = _internal_mutable_ice_candidate_events()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.ice_candidate_events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairEvent>& EventStream::ice_candidate_events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.ice_candidate_events)
  return _internal_ice_candidate_events();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairEvent>&
EventStream::_internal_ice_candidate_events() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ice_candidate_events_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::IceCandidatePairEvent>*
EventStream::_internal_mutable_ice_candidate_events() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ice_candidate_events_;
}

// repeated .webrtc.rtclog2.DtlsTransportStateEvent dtls_transport_state_events = 27;
inline int EventStream::_internal_dtls_transport_state_events_size() const {
  return _internal_dtls_transport_state_events().size();
}
inline int EventStream::dtls_transport_state_events_size() const {
  return _internal_dtls_transport_state_events_size();
}
inline void EventStream::clear_dtls_transport_state_events() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dtls_transport_state_events_.Clear();
}
inline ::webrtc::rtclog2::DtlsTransportStateEvent* EventStream::mutable_dtls_transport_state_events(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.dtls_transport_state_events)
  return _internal_mutable_dtls_transport_state_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsTransportStateEvent>* EventStream::mutable_dtls_transport_state_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.dtls_transport_state_events)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dtls_transport_state_events();
}
inline const ::webrtc::rtclog2::DtlsTransportStateEvent& EventStream::dtls_transport_state_events(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.dtls_transport_state_events)
  return _internal_dtls_transport_state_events().Get(index);
}
inline ::webrtc::rtclog2::DtlsTransportStateEvent* EventStream::add_dtls_transport_state_events() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::DtlsTransportStateEvent* _add = _internal_mutable_dtls_transport_state_events()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.dtls_transport_state_events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsTransportStateEvent>& EventStream::dtls_transport_state_events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.dtls_transport_state_events)
  return _internal_dtls_transport_state_events();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsTransportStateEvent>&
EventStream::_internal_dtls_transport_state_events() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dtls_transport_state_events_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsTransportStateEvent>*
EventStream::_internal_mutable_dtls_transport_state_events() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dtls_transport_state_events_;
}

// repeated .webrtc.rtclog2.DtlsWritableState dtls_writable_states = 28;
inline int EventStream::_internal_dtls_writable_states_size() const {
  return _internal_dtls_writable_states().size();
}
inline int EventStream::dtls_writable_states_size() const {
  return _internal_dtls_writable_states_size();
}
inline void EventStream::clear_dtls_writable_states() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dtls_writable_states_.Clear();
}
inline ::webrtc::rtclog2::DtlsWritableState* EventStream::mutable_dtls_writable_states(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.dtls_writable_states)
  return _internal_mutable_dtls_writable_states()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsWritableState>* EventStream::mutable_dtls_writable_states()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.dtls_writable_states)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dtls_writable_states();
}
inline const ::webrtc::rtclog2::DtlsWritableState& EventStream::dtls_writable_states(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.dtls_writable_states)
  return _internal_dtls_writable_states().Get(index);
}
inline ::webrtc::rtclog2::DtlsWritableState* EventStream::add_dtls_writable_states() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::DtlsWritableState* _add = _internal_mutable_dtls_writable_states()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.dtls_writable_states)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsWritableState>& EventStream::dtls_writable_states() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.dtls_writable_states)
  return _internal_dtls_writable_states();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsWritableState>&
EventStream::_internal_dtls_writable_states() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dtls_writable_states_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::DtlsWritableState>*
EventStream::_internal_mutable_dtls_writable_states() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dtls_writable_states_;
}

// repeated .webrtc.rtclog2.GenericPacketSent generic_packets_sent = 29;
inline int EventStream::_internal_generic_packets_sent_size() const {
  return _internal_generic_packets_sent().size();
}
inline int EventStream::generic_packets_sent_size() const {
  return _internal_generic_packets_sent_size();
}
inline void EventStream::clear_generic_packets_sent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.generic_packets_sent_.Clear();
}
inline ::webrtc::rtclog2::GenericPacketSent* EventStream::mutable_generic_packets_sent(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.generic_packets_sent)
  return _internal_mutable_generic_packets_sent()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketSent>* EventStream::mutable_generic_packets_sent()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.generic_packets_sent)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_generic_packets_sent();
}
inline const ::webrtc::rtclog2::GenericPacketSent& EventStream::generic_packets_sent(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.generic_packets_sent)
  return _internal_generic_packets_sent().Get(index);
}
inline ::webrtc::rtclog2::GenericPacketSent* EventStream::add_generic_packets_sent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::GenericPacketSent* _add = _internal_mutable_generic_packets_sent()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.generic_packets_sent)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketSent>& EventStream::generic_packets_sent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.generic_packets_sent)
  return _internal_generic_packets_sent();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketSent>&
EventStream::_internal_generic_packets_sent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.generic_packets_sent_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketSent>*
EventStream::_internal_mutable_generic_packets_sent() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.generic_packets_sent_;
}

// repeated .webrtc.rtclog2.GenericPacketReceived generic_packets_received = 30;
inline int EventStream::_internal_generic_packets_received_size() const {
  return _internal_generic_packets_received().size();
}
inline int EventStream::generic_packets_received_size() const {
  return _internal_generic_packets_received_size();
}
inline void EventStream::clear_generic_packets_received() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.generic_packets_received_.Clear();
}
inline ::webrtc::rtclog2::GenericPacketReceived* EventStream::mutable_generic_packets_received(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.generic_packets_received)
  return _internal_mutable_generic_packets_received()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketReceived>* EventStream::mutable_generic_packets_received()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.generic_packets_received)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_generic_packets_received();
}
inline const ::webrtc::rtclog2::GenericPacketReceived& EventStream::generic_packets_received(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.generic_packets_received)
  return _internal_generic_packets_received().Get(index);
}
inline ::webrtc::rtclog2::GenericPacketReceived* EventStream::add_generic_packets_received() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::GenericPacketReceived* _add = _internal_mutable_generic_packets_received()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.generic_packets_received)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketReceived>& EventStream::generic_packets_received() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.generic_packets_received)
  return _internal_generic_packets_received();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketReceived>&
EventStream::_internal_generic_packets_received() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.generic_packets_received_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericPacketReceived>*
EventStream::_internal_mutable_generic_packets_received() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.generic_packets_received_;
}

// repeated .webrtc.rtclog2.GenericAckReceived generic_acks_received = 31;
inline int EventStream::_internal_generic_acks_received_size() const {
  return _internal_generic_acks_received().size();
}
inline int EventStream::generic_acks_received_size() const {
  return _internal_generic_acks_received_size();
}
inline void EventStream::clear_generic_acks_received() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.generic_acks_received_.Clear();
}
inline ::webrtc::rtclog2::GenericAckReceived* EventStream::mutable_generic_acks_received(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.generic_acks_received)
  return _internal_mutable_generic_acks_received()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericAckReceived>* EventStream::mutable_generic_acks_received()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.generic_acks_received)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_generic_acks_received();
}
inline const ::webrtc::rtclog2::GenericAckReceived& EventStream::generic_acks_received(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.generic_acks_received)
  return _internal_generic_acks_received().Get(index);
}
inline ::webrtc::rtclog2::GenericAckReceived* EventStream::add_generic_acks_received() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::GenericAckReceived* _add = _internal_mutable_generic_acks_received()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.generic_acks_received)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericAckReceived>& EventStream::generic_acks_received() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.generic_acks_received)
  return _internal_generic_acks_received();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericAckReceived>&
EventStream::_internal_generic_acks_received() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.generic_acks_received_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::GenericAckReceived>*
EventStream::_internal_mutable_generic_acks_received() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.generic_acks_received_;
}

// repeated .webrtc.rtclog2.RouteChange route_changes = 32;
inline int EventStream::_internal_route_changes_size() const {
  return _internal_route_changes().size();
}
inline int EventStream::route_changes_size() const {
  return _internal_route_changes_size();
}
inline void EventStream::clear_route_changes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.route_changes_.Clear();
}
inline ::webrtc::rtclog2::RouteChange* EventStream::mutable_route_changes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.route_changes)
  return _internal_mutable_route_changes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RouteChange>* EventStream::mutable_route_changes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.route_changes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_route_changes();
}
inline const ::webrtc::rtclog2::RouteChange& EventStream::route_changes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.route_changes)
  return _internal_route_changes().Get(index);
}
inline ::webrtc::rtclog2::RouteChange* EventStream::add_route_changes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::RouteChange* _add = _internal_mutable_route_changes()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.route_changes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RouteChange>& EventStream::route_changes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.route_changes)
  return _internal_route_changes();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RouteChange>&
EventStream::_internal_route_changes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.route_changes_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RouteChange>*
EventStream::_internal_mutable_route_changes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.route_changes_;
}

// repeated .webrtc.rtclog2.RemoteEstimates remote_estimates = 33;
inline int EventStream::_internal_remote_estimates_size() const {
  return _internal_remote_estimates().size();
}
inline int EventStream::remote_estimates_size() const {
  return _internal_remote_estimates_size();
}
inline void EventStream::clear_remote_estimates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remote_estimates_.Clear();
}
inline ::webrtc::rtclog2::RemoteEstimates* EventStream::mutable_remote_estimates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.remote_estimates)
  return _internal_mutable_remote_estimates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RemoteEstimates>* EventStream::mutable_remote_estimates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.remote_estimates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_remote_estimates();
}
inline const ::webrtc::rtclog2::RemoteEstimates& EventStream::remote_estimates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.remote_estimates)
  return _internal_remote_estimates().Get(index);
}
inline ::webrtc::rtclog2::RemoteEstimates* EventStream::add_remote_estimates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::RemoteEstimates* _add = _internal_mutable_remote_estimates()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.remote_estimates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RemoteEstimates>& EventStream::remote_estimates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.remote_estimates)
  return _internal_remote_estimates();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RemoteEstimates>&
EventStream::_internal_remote_estimates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.remote_estimates_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::RemoteEstimates>*
EventStream::_internal_mutable_remote_estimates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.remote_estimates_;
}

// repeated .webrtc.rtclog2.NetEqSetMinimumDelay neteq_set_minimum_delay = 34;
inline int EventStream::_internal_neteq_set_minimum_delay_size() const {
  return _internal_neteq_set_minimum_delay().size();
}
inline int EventStream::neteq_set_minimum_delay_size() const {
  return _internal_neteq_set_minimum_delay_size();
}
inline void EventStream::clear_neteq_set_minimum_delay() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.neteq_set_minimum_delay_.Clear();
}
inline ::webrtc::rtclog2::NetEqSetMinimumDelay* EventStream::mutable_neteq_set_minimum_delay(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.neteq_set_minimum_delay)
  return _internal_mutable_neteq_set_minimum_delay()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::NetEqSetMinimumDelay>* EventStream::mutable_neteq_set_minimum_delay()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.neteq_set_minimum_delay)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_neteq_set_minimum_delay();
}
inline const ::webrtc::rtclog2::NetEqSetMinimumDelay& EventStream::neteq_set_minimum_delay(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.neteq_set_minimum_delay)
  return _internal_neteq_set_minimum_delay().Get(index);
}
inline ::webrtc::rtclog2::NetEqSetMinimumDelay* EventStream::add_neteq_set_minimum_delay() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::NetEqSetMinimumDelay* _add = _internal_mutable_neteq_set_minimum_delay()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.neteq_set_minimum_delay)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::NetEqSetMinimumDelay>& EventStream::neteq_set_minimum_delay() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.neteq_set_minimum_delay)
  return _internal_neteq_set_minimum_delay();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::NetEqSetMinimumDelay>&
EventStream::_internal_neteq_set_minimum_delay() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.neteq_set_minimum_delay_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::NetEqSetMinimumDelay>*
EventStream::_internal_mutable_neteq_set_minimum_delay() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.neteq_set_minimum_delay_;
}

// repeated .webrtc.rtclog2.AudioRecvStreamConfig audio_recv_stream_configs = 101;
inline int EventStream::_internal_audio_recv_stream_configs_size() const {
  return _internal_audio_recv_stream_configs().size();
}
inline int EventStream::audio_recv_stream_configs_size() const {
  return _internal_audio_recv_stream_configs_size();
}
inline void EventStream::clear_audio_recv_stream_configs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_recv_stream_configs_.Clear();
}
inline ::webrtc::rtclog2::AudioRecvStreamConfig* EventStream::mutable_audio_recv_stream_configs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.audio_recv_stream_configs)
  return _internal_mutable_audio_recv_stream_configs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioRecvStreamConfig>* EventStream::mutable_audio_recv_stream_configs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.audio_recv_stream_configs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_audio_recv_stream_configs();
}
inline const ::webrtc::rtclog2::AudioRecvStreamConfig& EventStream::audio_recv_stream_configs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.audio_recv_stream_configs)
  return _internal_audio_recv_stream_configs().Get(index);
}
inline ::webrtc::rtclog2::AudioRecvStreamConfig* EventStream::add_audio_recv_stream_configs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::AudioRecvStreamConfig* _add = _internal_mutable_audio_recv_stream_configs()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.audio_recv_stream_configs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioRecvStreamConfig>& EventStream::audio_recv_stream_configs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.audio_recv_stream_configs)
  return _internal_audio_recv_stream_configs();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioRecvStreamConfig>&
EventStream::_internal_audio_recv_stream_configs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_recv_stream_configs_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioRecvStreamConfig>*
EventStream::_internal_mutable_audio_recv_stream_configs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.audio_recv_stream_configs_;
}

// repeated .webrtc.rtclog2.AudioSendStreamConfig audio_send_stream_configs = 102;
inline int EventStream::_internal_audio_send_stream_configs_size() const {
  return _internal_audio_send_stream_configs().size();
}
inline int EventStream::audio_send_stream_configs_size() const {
  return _internal_audio_send_stream_configs_size();
}
inline void EventStream::clear_audio_send_stream_configs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_send_stream_configs_.Clear();
}
inline ::webrtc::rtclog2::AudioSendStreamConfig* EventStream::mutable_audio_send_stream_configs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.audio_send_stream_configs)
  return _internal_mutable_audio_send_stream_configs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioSendStreamConfig>* EventStream::mutable_audio_send_stream_configs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.audio_send_stream_configs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_audio_send_stream_configs();
}
inline const ::webrtc::rtclog2::AudioSendStreamConfig& EventStream::audio_send_stream_configs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.audio_send_stream_configs)
  return _internal_audio_send_stream_configs().Get(index);
}
inline ::webrtc::rtclog2::AudioSendStreamConfig* EventStream::add_audio_send_stream_configs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::AudioSendStreamConfig* _add = _internal_mutable_audio_send_stream_configs()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.audio_send_stream_configs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioSendStreamConfig>& EventStream::audio_send_stream_configs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.audio_send_stream_configs)
  return _internal_audio_send_stream_configs();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioSendStreamConfig>&
EventStream::_internal_audio_send_stream_configs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_send_stream_configs_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::AudioSendStreamConfig>*
EventStream::_internal_mutable_audio_send_stream_configs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.audio_send_stream_configs_;
}

// repeated .webrtc.rtclog2.VideoRecvStreamConfig video_recv_stream_configs = 103;
inline int EventStream::_internal_video_recv_stream_configs_size() const {
  return _internal_video_recv_stream_configs().size();
}
inline int EventStream::video_recv_stream_configs_size() const {
  return _internal_video_recv_stream_configs_size();
}
inline void EventStream::clear_video_recv_stream_configs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.video_recv_stream_configs_.Clear();
}
inline ::webrtc::rtclog2::VideoRecvStreamConfig* EventStream::mutable_video_recv_stream_configs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.video_recv_stream_configs)
  return _internal_mutable_video_recv_stream_configs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoRecvStreamConfig>* EventStream::mutable_video_recv_stream_configs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.video_recv_stream_configs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_video_recv_stream_configs();
}
inline const ::webrtc::rtclog2::VideoRecvStreamConfig& EventStream::video_recv_stream_configs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.video_recv_stream_configs)
  return _internal_video_recv_stream_configs().Get(index);
}
inline ::webrtc::rtclog2::VideoRecvStreamConfig* EventStream::add_video_recv_stream_configs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::VideoRecvStreamConfig* _add = _internal_mutable_video_recv_stream_configs()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.video_recv_stream_configs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoRecvStreamConfig>& EventStream::video_recv_stream_configs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.video_recv_stream_configs)
  return _internal_video_recv_stream_configs();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoRecvStreamConfig>&
EventStream::_internal_video_recv_stream_configs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.video_recv_stream_configs_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoRecvStreamConfig>*
EventStream::_internal_mutable_video_recv_stream_configs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.video_recv_stream_configs_;
}

// repeated .webrtc.rtclog2.VideoSendStreamConfig video_send_stream_configs = 104;
inline int EventStream::_internal_video_send_stream_configs_size() const {
  return _internal_video_send_stream_configs().size();
}
inline int EventStream::video_send_stream_configs_size() const {
  return _internal_video_send_stream_configs_size();
}
inline void EventStream::clear_video_send_stream_configs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.video_send_stream_configs_.Clear();
}
inline ::webrtc::rtclog2::VideoSendStreamConfig* EventStream::mutable_video_send_stream_configs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.EventStream.video_send_stream_configs)
  return _internal_mutable_video_send_stream_configs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoSendStreamConfig>* EventStream::mutable_video_send_stream_configs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.rtclog2.EventStream.video_send_stream_configs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_video_send_stream_configs();
}
inline const ::webrtc::rtclog2::VideoSendStreamConfig& EventStream::video_send_stream_configs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EventStream.video_send_stream_configs)
  return _internal_video_send_stream_configs().Get(index);
}
inline ::webrtc::rtclog2::VideoSendStreamConfig* EventStream::add_video_send_stream_configs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::rtclog2::VideoSendStreamConfig* _add = _internal_mutable_video_send_stream_configs()->Add();
  // @@protoc_insertion_point(field_add:webrtc.rtclog2.EventStream.video_send_stream_configs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoSendStreamConfig>& EventStream::video_send_stream_configs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.rtclog2.EventStream.video_send_stream_configs)
  return _internal_video_send_stream_configs();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoSendStreamConfig>&
EventStream::_internal_video_send_stream_configs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.video_send_stream_configs_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::rtclog2::VideoSendStreamConfig>*
EventStream::_internal_mutable_video_send_stream_configs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.video_send_stream_configs_;
}

// -------------------------------------------------------------------

// Event

// -------------------------------------------------------------------

// GenericPacketReceived

// optional int64 timestamp_ms = 1;
inline bool GenericPacketReceived::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GenericPacketReceived::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t GenericPacketReceived::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketReceived.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void GenericPacketReceived::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketReceived.timestamp_ms)
}
inline ::int64_t GenericPacketReceived::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void GenericPacketReceived::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timestamp_ms_ = value;
}

// optional int64 packet_number = 2;
inline bool GenericPacketReceived::has_packet_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GenericPacketReceived::clear_packet_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_number_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t GenericPacketReceived::packet_number() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketReceived.packet_number)
  return _internal_packet_number();
}
inline void GenericPacketReceived::set_packet_number(::int64_t value) {
  _internal_set_packet_number(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketReceived.packet_number)
}
inline ::int64_t GenericPacketReceived::_internal_packet_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_number_;
}
inline void GenericPacketReceived::_internal_set_packet_number(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.packet_number_ = value;
}

// optional int32 packet_length = 3;
inline bool GenericPacketReceived::has_packet_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void GenericPacketReceived::clear_packet_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t GenericPacketReceived::packet_length() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketReceived.packet_length)
  return _internal_packet_length();
}
inline void GenericPacketReceived::set_packet_length(::int32_t value) {
  _internal_set_packet_length(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketReceived.packet_length)
}
inline ::int32_t GenericPacketReceived::_internal_packet_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_length_;
}
inline void GenericPacketReceived::_internal_set_packet_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.packet_length_ = value;
}

// optional uint32 number_of_deltas = 16;
inline bool GenericPacketReceived::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void GenericPacketReceived::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t GenericPacketReceived::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketReceived.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void GenericPacketReceived::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketReceived.number_of_deltas)
}
inline ::uint32_t GenericPacketReceived::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void GenericPacketReceived::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 17;
inline bool GenericPacketReceived::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GenericPacketReceived::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericPacketReceived::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketReceived.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericPacketReceived::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketReceived.timestamp_ms_deltas)
}
inline std::string* GenericPacketReceived::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericPacketReceived.timestamp_ms_deltas)
  return _s;
}
inline const std::string& GenericPacketReceived::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void GenericPacketReceived::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* GenericPacketReceived::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* GenericPacketReceived::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericPacketReceived.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericPacketReceived::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericPacketReceived.timestamp_ms_deltas)
}

// optional bytes packet_number_deltas = 18;
inline bool GenericPacketReceived::has_packet_number_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GenericPacketReceived::clear_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_number_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GenericPacketReceived::packet_number_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketReceived.packet_number_deltas)
  return _internal_packet_number_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericPacketReceived::set_packet_number_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.packet_number_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketReceived.packet_number_deltas)
}
inline std::string* GenericPacketReceived::mutable_packet_number_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_packet_number_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericPacketReceived.packet_number_deltas)
  return _s;
}
inline const std::string& GenericPacketReceived::_internal_packet_number_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_number_deltas_.Get();
}
inline void GenericPacketReceived::_internal_set_packet_number_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.packet_number_deltas_.Set(value, GetArena());
}
inline std::string* GenericPacketReceived::_internal_mutable_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.packet_number_deltas_.Mutable( GetArena());
}
inline std::string* GenericPacketReceived::release_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericPacketReceived.packet_number_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.packet_number_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.packet_number_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericPacketReceived::set_allocated_packet_number_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.packet_number_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.packet_number_deltas_.IsDefault()) {
          _impl_.packet_number_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericPacketReceived.packet_number_deltas)
}

// optional bytes packet_length_deltas = 19;
inline bool GenericPacketReceived::has_packet_length_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GenericPacketReceived::clear_packet_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_length_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GenericPacketReceived::packet_length_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketReceived.packet_length_deltas)
  return _internal_packet_length_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericPacketReceived::set_packet_length_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.packet_length_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketReceived.packet_length_deltas)
}
inline std::string* GenericPacketReceived::mutable_packet_length_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_packet_length_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericPacketReceived.packet_length_deltas)
  return _s;
}
inline const std::string& GenericPacketReceived::_internal_packet_length_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_length_deltas_.Get();
}
inline void GenericPacketReceived::_internal_set_packet_length_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.packet_length_deltas_.Set(value, GetArena());
}
inline std::string* GenericPacketReceived::_internal_mutable_packet_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.packet_length_deltas_.Mutable( GetArena());
}
inline std::string* GenericPacketReceived::release_packet_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericPacketReceived.packet_length_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.packet_length_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.packet_length_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericPacketReceived::set_allocated_packet_length_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.packet_length_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.packet_length_deltas_.IsDefault()) {
          _impl_.packet_length_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericPacketReceived.packet_length_deltas)
}

// -------------------------------------------------------------------

// GenericPacketSent

// optional int64 timestamp_ms = 1;
inline bool GenericPacketSent::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void GenericPacketSent::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t GenericPacketSent::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketSent.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void GenericPacketSent::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketSent.timestamp_ms)
}
inline ::int64_t GenericPacketSent::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void GenericPacketSent::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.timestamp_ms_ = value;
}

// optional int64 packet_number = 2;
inline bool GenericPacketSent::has_packet_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void GenericPacketSent::clear_packet_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_number_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t GenericPacketSent::packet_number() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketSent.packet_number)
  return _internal_packet_number();
}
inline void GenericPacketSent::set_packet_number(::int64_t value) {
  _internal_set_packet_number(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketSent.packet_number)
}
inline ::int64_t GenericPacketSent::_internal_packet_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_number_;
}
inline void GenericPacketSent::_internal_set_packet_number(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.packet_number_ = value;
}

// optional int32 overhead_length = 3;
inline bool GenericPacketSent::has_overhead_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void GenericPacketSent::clear_overhead_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.overhead_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t GenericPacketSent::overhead_length() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketSent.overhead_length)
  return _internal_overhead_length();
}
inline void GenericPacketSent::set_overhead_length(::int32_t value) {
  _internal_set_overhead_length(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketSent.overhead_length)
}
inline ::int32_t GenericPacketSent::_internal_overhead_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.overhead_length_;
}
inline void GenericPacketSent::_internal_set_overhead_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.overhead_length_ = value;
}

// optional int32 payload_length = 4;
inline bool GenericPacketSent::has_payload_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void GenericPacketSent::clear_payload_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t GenericPacketSent::payload_length() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketSent.payload_length)
  return _internal_payload_length();
}
inline void GenericPacketSent::set_payload_length(::int32_t value) {
  _internal_set_payload_length(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketSent.payload_length)
}
inline ::int32_t GenericPacketSent::_internal_payload_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_length_;
}
inline void GenericPacketSent::_internal_set_payload_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.payload_length_ = value;
}

// optional int32 padding_length = 5;
inline bool GenericPacketSent::has_padding_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void GenericPacketSent::clear_padding_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.padding_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t GenericPacketSent::padding_length() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketSent.padding_length)
  return _internal_padding_length();
}
inline void GenericPacketSent::set_padding_length(::int32_t value) {
  _internal_set_padding_length(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketSent.padding_length)
}
inline ::int32_t GenericPacketSent::_internal_padding_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.padding_length_;
}
inline void GenericPacketSent::_internal_set_padding_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.padding_length_ = value;
}

// optional uint32 number_of_deltas = 16;
inline bool GenericPacketSent::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void GenericPacketSent::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint32_t GenericPacketSent::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketSent.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void GenericPacketSent::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketSent.number_of_deltas)
}
inline ::uint32_t GenericPacketSent::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void GenericPacketSent::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 17;
inline bool GenericPacketSent::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GenericPacketSent::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericPacketSent::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketSent.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericPacketSent::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketSent.timestamp_ms_deltas)
}
inline std::string* GenericPacketSent::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericPacketSent.timestamp_ms_deltas)
  return _s;
}
inline const std::string& GenericPacketSent::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void GenericPacketSent::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* GenericPacketSent::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* GenericPacketSent::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericPacketSent.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericPacketSent::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericPacketSent.timestamp_ms_deltas)
}

// optional bytes packet_number_deltas = 18;
inline bool GenericPacketSent::has_packet_number_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GenericPacketSent::clear_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_number_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GenericPacketSent::packet_number_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketSent.packet_number_deltas)
  return _internal_packet_number_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericPacketSent::set_packet_number_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.packet_number_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketSent.packet_number_deltas)
}
inline std::string* GenericPacketSent::mutable_packet_number_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_packet_number_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericPacketSent.packet_number_deltas)
  return _s;
}
inline const std::string& GenericPacketSent::_internal_packet_number_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_number_deltas_.Get();
}
inline void GenericPacketSent::_internal_set_packet_number_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.packet_number_deltas_.Set(value, GetArena());
}
inline std::string* GenericPacketSent::_internal_mutable_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.packet_number_deltas_.Mutable( GetArena());
}
inline std::string* GenericPacketSent::release_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericPacketSent.packet_number_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.packet_number_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.packet_number_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericPacketSent::set_allocated_packet_number_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.packet_number_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.packet_number_deltas_.IsDefault()) {
          _impl_.packet_number_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericPacketSent.packet_number_deltas)
}

// optional bytes overhead_length_deltas = 19;
inline bool GenericPacketSent::has_overhead_length_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GenericPacketSent::clear_overhead_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.overhead_length_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GenericPacketSent::overhead_length_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketSent.overhead_length_deltas)
  return _internal_overhead_length_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericPacketSent::set_overhead_length_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.overhead_length_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketSent.overhead_length_deltas)
}
inline std::string* GenericPacketSent::mutable_overhead_length_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_overhead_length_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericPacketSent.overhead_length_deltas)
  return _s;
}
inline const std::string& GenericPacketSent::_internal_overhead_length_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.overhead_length_deltas_.Get();
}
inline void GenericPacketSent::_internal_set_overhead_length_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.overhead_length_deltas_.Set(value, GetArena());
}
inline std::string* GenericPacketSent::_internal_mutable_overhead_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.overhead_length_deltas_.Mutable( GetArena());
}
inline std::string* GenericPacketSent::release_overhead_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericPacketSent.overhead_length_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.overhead_length_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.overhead_length_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericPacketSent::set_allocated_overhead_length_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.overhead_length_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.overhead_length_deltas_.IsDefault()) {
          _impl_.overhead_length_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericPacketSent.overhead_length_deltas)
}

// optional bytes payload_length_deltas = 20;
inline bool GenericPacketSent::has_payload_length_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GenericPacketSent::clear_payload_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_length_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GenericPacketSent::payload_length_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketSent.payload_length_deltas)
  return _internal_payload_length_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericPacketSent::set_payload_length_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.payload_length_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketSent.payload_length_deltas)
}
inline std::string* GenericPacketSent::mutable_payload_length_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload_length_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericPacketSent.payload_length_deltas)
  return _s;
}
inline const std::string& GenericPacketSent::_internal_payload_length_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_length_deltas_.Get();
}
inline void GenericPacketSent::_internal_set_payload_length_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.payload_length_deltas_.Set(value, GetArena());
}
inline std::string* GenericPacketSent::_internal_mutable_payload_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.payload_length_deltas_.Mutable( GetArena());
}
inline std::string* GenericPacketSent::release_payload_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericPacketSent.payload_length_deltas)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.payload_length_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payload_length_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericPacketSent::set_allocated_payload_length_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.payload_length_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_length_deltas_.IsDefault()) {
          _impl_.payload_length_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericPacketSent.payload_length_deltas)
}

// optional bytes padding_length_deltas = 21;
inline bool GenericPacketSent::has_padding_length_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GenericPacketSent::clear_padding_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.padding_length_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& GenericPacketSent::padding_length_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericPacketSent.padding_length_deltas)
  return _internal_padding_length_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericPacketSent::set_padding_length_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.padding_length_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericPacketSent.padding_length_deltas)
}
inline std::string* GenericPacketSent::mutable_padding_length_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_padding_length_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericPacketSent.padding_length_deltas)
  return _s;
}
inline const std::string& GenericPacketSent::_internal_padding_length_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.padding_length_deltas_.Get();
}
inline void GenericPacketSent::_internal_set_padding_length_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.padding_length_deltas_.Set(value, GetArena());
}
inline std::string* GenericPacketSent::_internal_mutable_padding_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.padding_length_deltas_.Mutable( GetArena());
}
inline std::string* GenericPacketSent::release_padding_length_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericPacketSent.padding_length_deltas)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.padding_length_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.padding_length_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericPacketSent::set_allocated_padding_length_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.padding_length_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.padding_length_deltas_.IsDefault()) {
          _impl_.padding_length_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericPacketSent.padding_length_deltas)
}

// -------------------------------------------------------------------

// GenericAckReceived

// optional int64 timestamp_ms = 1;
inline bool GenericAckReceived::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GenericAckReceived::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t GenericAckReceived::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericAckReceived.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void GenericAckReceived::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericAckReceived.timestamp_ms)
}
inline ::int64_t GenericAckReceived::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void GenericAckReceived::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.timestamp_ms_ = value;
}

// optional int64 packet_number = 2;
inline bool GenericAckReceived::has_packet_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void GenericAckReceived::clear_packet_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_number_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t GenericAckReceived::packet_number() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericAckReceived.packet_number)
  return _internal_packet_number();
}
inline void GenericAckReceived::set_packet_number(::int64_t value) {
  _internal_set_packet_number(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericAckReceived.packet_number)
}
inline ::int64_t GenericAckReceived::_internal_packet_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_number_;
}
inline void GenericAckReceived::_internal_set_packet_number(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.packet_number_ = value;
}

// optional int64 acked_packet_number = 3;
inline bool GenericAckReceived::has_acked_packet_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void GenericAckReceived::clear_acked_packet_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acked_packet_number_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t GenericAckReceived::acked_packet_number() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericAckReceived.acked_packet_number)
  return _internal_acked_packet_number();
}
inline void GenericAckReceived::set_acked_packet_number(::int64_t value) {
  _internal_set_acked_packet_number(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericAckReceived.acked_packet_number)
}
inline ::int64_t GenericAckReceived::_internal_acked_packet_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acked_packet_number_;
}
inline void GenericAckReceived::_internal_set_acked_packet_number(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.acked_packet_number_ = value;
}

// optional int64 receive_acked_packet_time_ms = 4;
inline bool GenericAckReceived::has_receive_acked_packet_time_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void GenericAckReceived::clear_receive_acked_packet_time_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.receive_acked_packet_time_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int64_t GenericAckReceived::receive_acked_packet_time_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericAckReceived.receive_acked_packet_time_ms)
  return _internal_receive_acked_packet_time_ms();
}
inline void GenericAckReceived::set_receive_acked_packet_time_ms(::int64_t value) {
  _internal_set_receive_acked_packet_time_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericAckReceived.receive_acked_packet_time_ms)
}
inline ::int64_t GenericAckReceived::_internal_receive_acked_packet_time_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.receive_acked_packet_time_ms_;
}
inline void GenericAckReceived::_internal_set_receive_acked_packet_time_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.receive_acked_packet_time_ms_ = value;
}

// optional uint32 number_of_deltas = 16;
inline bool GenericAckReceived::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void GenericAckReceived::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t GenericAckReceived::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericAckReceived.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void GenericAckReceived::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericAckReceived.number_of_deltas)
}
inline ::uint32_t GenericAckReceived::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void GenericAckReceived::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 17;
inline bool GenericAckReceived::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GenericAckReceived::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericAckReceived::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericAckReceived.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericAckReceived::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericAckReceived.timestamp_ms_deltas)
}
inline std::string* GenericAckReceived::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericAckReceived.timestamp_ms_deltas)
  return _s;
}
inline const std::string& GenericAckReceived::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void GenericAckReceived::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* GenericAckReceived::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* GenericAckReceived::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericAckReceived.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericAckReceived::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericAckReceived.timestamp_ms_deltas)
}

// optional bytes packet_number_deltas = 18;
inline bool GenericAckReceived::has_packet_number_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GenericAckReceived::clear_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.packet_number_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GenericAckReceived::packet_number_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericAckReceived.packet_number_deltas)
  return _internal_packet_number_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericAckReceived::set_packet_number_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.packet_number_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericAckReceived.packet_number_deltas)
}
inline std::string* GenericAckReceived::mutable_packet_number_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_packet_number_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericAckReceived.packet_number_deltas)
  return _s;
}
inline const std::string& GenericAckReceived::_internal_packet_number_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.packet_number_deltas_.Get();
}
inline void GenericAckReceived::_internal_set_packet_number_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.packet_number_deltas_.Set(value, GetArena());
}
inline std::string* GenericAckReceived::_internal_mutable_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.packet_number_deltas_.Mutable( GetArena());
}
inline std::string* GenericAckReceived::release_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericAckReceived.packet_number_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.packet_number_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.packet_number_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericAckReceived::set_allocated_packet_number_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.packet_number_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.packet_number_deltas_.IsDefault()) {
          _impl_.packet_number_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericAckReceived.packet_number_deltas)
}

// optional bytes acked_packet_number_deltas = 19;
inline bool GenericAckReceived::has_acked_packet_number_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GenericAckReceived::clear_acked_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.acked_packet_number_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GenericAckReceived::acked_packet_number_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericAckReceived.acked_packet_number_deltas)
  return _internal_acked_packet_number_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericAckReceived::set_acked_packet_number_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.acked_packet_number_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericAckReceived.acked_packet_number_deltas)
}
inline std::string* GenericAckReceived::mutable_acked_packet_number_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_acked_packet_number_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericAckReceived.acked_packet_number_deltas)
  return _s;
}
inline const std::string& GenericAckReceived::_internal_acked_packet_number_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.acked_packet_number_deltas_.Get();
}
inline void GenericAckReceived::_internal_set_acked_packet_number_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.acked_packet_number_deltas_.Set(value, GetArena());
}
inline std::string* GenericAckReceived::_internal_mutable_acked_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.acked_packet_number_deltas_.Mutable( GetArena());
}
inline std::string* GenericAckReceived::release_acked_packet_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericAckReceived.acked_packet_number_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.acked_packet_number_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.acked_packet_number_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericAckReceived::set_allocated_acked_packet_number_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.acked_packet_number_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.acked_packet_number_deltas_.IsDefault()) {
          _impl_.acked_packet_number_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericAckReceived.acked_packet_number_deltas)
}

// optional bytes receive_acked_packet_time_ms_deltas = 20;
inline bool GenericAckReceived::has_receive_acked_packet_time_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GenericAckReceived::clear_receive_acked_packet_time_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.receive_acked_packet_time_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GenericAckReceived::receive_acked_packet_time_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.GenericAckReceived.receive_acked_packet_time_ms_deltas)
  return _internal_receive_acked_packet_time_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenericAckReceived::set_receive_acked_packet_time_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.receive_acked_packet_time_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.GenericAckReceived.receive_acked_packet_time_ms_deltas)
}
inline std::string* GenericAckReceived::mutable_receive_acked_packet_time_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_receive_acked_packet_time_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.GenericAckReceived.receive_acked_packet_time_ms_deltas)
  return _s;
}
inline const std::string& GenericAckReceived::_internal_receive_acked_packet_time_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.receive_acked_packet_time_ms_deltas_.Get();
}
inline void GenericAckReceived::_internal_set_receive_acked_packet_time_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.receive_acked_packet_time_ms_deltas_.Set(value, GetArena());
}
inline std::string* GenericAckReceived::_internal_mutable_receive_acked_packet_time_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.receive_acked_packet_time_ms_deltas_.Mutable( GetArena());
}
inline std::string* GenericAckReceived::release_receive_acked_packet_time_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.GenericAckReceived.receive_acked_packet_time_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.receive_acked_packet_time_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.receive_acked_packet_time_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GenericAckReceived::set_allocated_receive_acked_packet_time_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.receive_acked_packet_time_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.receive_acked_packet_time_ms_deltas_.IsDefault()) {
          _impl_.receive_acked_packet_time_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.GenericAckReceived.receive_acked_packet_time_ms_deltas)
}

// -------------------------------------------------------------------

// DependencyDescriptorsWireInfo

// optional uint32 start_end_bit = 1;
inline bool DependencyDescriptorsWireInfo::has_start_end_bit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void DependencyDescriptorsWireInfo::clear_start_end_bit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_end_bit_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t DependencyDescriptorsWireInfo::start_end_bit() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DependencyDescriptorsWireInfo.start_end_bit)
  return _internal_start_end_bit();
}
inline void DependencyDescriptorsWireInfo::set_start_end_bit(::uint32_t value) {
  _internal_set_start_end_bit(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DependencyDescriptorsWireInfo.start_end_bit)
}
inline ::uint32_t DependencyDescriptorsWireInfo::_internal_start_end_bit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_end_bit_;
}
inline void DependencyDescriptorsWireInfo::_internal_set_start_end_bit(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.start_end_bit_ = value;
}

// optional bytes start_end_bit_deltas = 2;
inline bool DependencyDescriptorsWireInfo::has_start_end_bit_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DependencyDescriptorsWireInfo::clear_start_end_bit_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.start_end_bit_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DependencyDescriptorsWireInfo::start_end_bit_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DependencyDescriptorsWireInfo.start_end_bit_deltas)
  return _internal_start_end_bit_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DependencyDescriptorsWireInfo::set_start_end_bit_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_end_bit_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DependencyDescriptorsWireInfo.start_end_bit_deltas)
}
inline std::string* DependencyDescriptorsWireInfo::mutable_start_end_bit_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_end_bit_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.DependencyDescriptorsWireInfo.start_end_bit_deltas)
  return _s;
}
inline const std::string& DependencyDescriptorsWireInfo::_internal_start_end_bit_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.start_end_bit_deltas_.Get();
}
inline void DependencyDescriptorsWireInfo::_internal_set_start_end_bit_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_end_bit_deltas_.Set(value, GetArena());
}
inline std::string* DependencyDescriptorsWireInfo::_internal_mutable_start_end_bit_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.start_end_bit_deltas_.Mutable( GetArena());
}
inline std::string* DependencyDescriptorsWireInfo::release_start_end_bit_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.DependencyDescriptorsWireInfo.start_end_bit_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.start_end_bit_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.start_end_bit_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DependencyDescriptorsWireInfo::set_allocated_start_end_bit_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.start_end_bit_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.start_end_bit_deltas_.IsDefault()) {
          _impl_.start_end_bit_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.DependencyDescriptorsWireInfo.start_end_bit_deltas)
}

// optional uint32 template_id = 3;
inline bool DependencyDescriptorsWireInfo::has_template_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void DependencyDescriptorsWireInfo::clear_template_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.template_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t DependencyDescriptorsWireInfo::template_id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DependencyDescriptorsWireInfo.template_id)
  return _internal_template_id();
}
inline void DependencyDescriptorsWireInfo::set_template_id(::uint32_t value) {
  _internal_set_template_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DependencyDescriptorsWireInfo.template_id)
}
inline ::uint32_t DependencyDescriptorsWireInfo::_internal_template_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.template_id_;
}
inline void DependencyDescriptorsWireInfo::_internal_set_template_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.template_id_ = value;
}

// optional bytes template_id_deltas = 4;
inline bool DependencyDescriptorsWireInfo::has_template_id_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DependencyDescriptorsWireInfo::clear_template_id_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.template_id_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DependencyDescriptorsWireInfo::template_id_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DependencyDescriptorsWireInfo.template_id_deltas)
  return _internal_template_id_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DependencyDescriptorsWireInfo::set_template_id_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.template_id_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DependencyDescriptorsWireInfo.template_id_deltas)
}
inline std::string* DependencyDescriptorsWireInfo::mutable_template_id_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_template_id_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.DependencyDescriptorsWireInfo.template_id_deltas)
  return _s;
}
inline const std::string& DependencyDescriptorsWireInfo::_internal_template_id_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.template_id_deltas_.Get();
}
inline void DependencyDescriptorsWireInfo::_internal_set_template_id_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.template_id_deltas_.Set(value, GetArena());
}
inline std::string* DependencyDescriptorsWireInfo::_internal_mutable_template_id_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.template_id_deltas_.Mutable( GetArena());
}
inline std::string* DependencyDescriptorsWireInfo::release_template_id_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.DependencyDescriptorsWireInfo.template_id_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.template_id_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.template_id_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DependencyDescriptorsWireInfo::set_allocated_template_id_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.template_id_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.template_id_deltas_.IsDefault()) {
          _impl_.template_id_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.DependencyDescriptorsWireInfo.template_id_deltas)
}

// optional uint32 frame_id = 5;
inline bool DependencyDescriptorsWireInfo::has_frame_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void DependencyDescriptorsWireInfo::clear_frame_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t DependencyDescriptorsWireInfo::frame_id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DependencyDescriptorsWireInfo.frame_id)
  return _internal_frame_id();
}
inline void DependencyDescriptorsWireInfo::set_frame_id(::uint32_t value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DependencyDescriptorsWireInfo.frame_id)
}
inline ::uint32_t DependencyDescriptorsWireInfo::_internal_frame_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_id_;
}
inline void DependencyDescriptorsWireInfo::_internal_set_frame_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.frame_id_ = value;
}

// optional bytes frame_id_deltas = 6;
inline bool DependencyDescriptorsWireInfo::has_frame_id_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DependencyDescriptorsWireInfo::clear_frame_id_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_id_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DependencyDescriptorsWireInfo::frame_id_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DependencyDescriptorsWireInfo.frame_id_deltas)
  return _internal_frame_id_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DependencyDescriptorsWireInfo::set_frame_id_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.frame_id_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DependencyDescriptorsWireInfo.frame_id_deltas)
}
inline std::string* DependencyDescriptorsWireInfo::mutable_frame_id_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_frame_id_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.DependencyDescriptorsWireInfo.frame_id_deltas)
  return _s;
}
inline const std::string& DependencyDescriptorsWireInfo::_internal_frame_id_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_id_deltas_.Get();
}
inline void DependencyDescriptorsWireInfo::_internal_set_frame_id_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.frame_id_deltas_.Set(value, GetArena());
}
inline std::string* DependencyDescriptorsWireInfo::_internal_mutable_frame_id_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.frame_id_deltas_.Mutable( GetArena());
}
inline std::string* DependencyDescriptorsWireInfo::release_frame_id_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.DependencyDescriptorsWireInfo.frame_id_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.frame_id_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.frame_id_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DependencyDescriptorsWireInfo::set_allocated_frame_id_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.frame_id_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.frame_id_deltas_.IsDefault()) {
          _impl_.frame_id_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.DependencyDescriptorsWireInfo.frame_id_deltas)
}

// optional bytes extended_infos = 7;
inline bool DependencyDescriptorsWireInfo::has_extended_infos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DependencyDescriptorsWireInfo::clear_extended_infos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.extended_infos_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DependencyDescriptorsWireInfo::extended_infos() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DependencyDescriptorsWireInfo.extended_infos)
  return _internal_extended_infos();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DependencyDescriptorsWireInfo::set_extended_infos(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.extended_infos_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DependencyDescriptorsWireInfo.extended_infos)
}
inline std::string* DependencyDescriptorsWireInfo::mutable_extended_infos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_extended_infos();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.DependencyDescriptorsWireInfo.extended_infos)
  return _s;
}
inline const std::string& DependencyDescriptorsWireInfo::_internal_extended_infos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.extended_infos_.Get();
}
inline void DependencyDescriptorsWireInfo::_internal_set_extended_infos(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.extended_infos_.Set(value, GetArena());
}
inline std::string* DependencyDescriptorsWireInfo::_internal_mutable_extended_infos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.extended_infos_.Mutable( GetArena());
}
inline std::string* DependencyDescriptorsWireInfo::release_extended_infos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.DependencyDescriptorsWireInfo.extended_infos)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.extended_infos_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.extended_infos_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DependencyDescriptorsWireInfo::set_allocated_extended_infos(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.extended_infos_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.extended_infos_.IsDefault()) {
          _impl_.extended_infos_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.DependencyDescriptorsWireInfo.extended_infos)
}

// -------------------------------------------------------------------

// IncomingRtpPackets

// optional int64 timestamp_ms = 1;
inline bool IncomingRtpPackets::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::int64_t IncomingRtpPackets::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void IncomingRtpPackets::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.timestamp_ms)
}
inline ::int64_t IncomingRtpPackets::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void IncomingRtpPackets::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.timestamp_ms_ = value;
}

// optional bool marker = 2;
inline bool IncomingRtpPackets::has_marker() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_marker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.marker_ = false;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline bool IncomingRtpPackets::marker() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.marker)
  return _internal_marker();
}
inline void IncomingRtpPackets::set_marker(bool value) {
  _internal_set_marker(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.marker)
}
inline bool IncomingRtpPackets::_internal_marker() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.marker_;
}
inline void IncomingRtpPackets::_internal_set_marker(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.marker_ = value;
}

// optional uint32 payload_type = 3;
inline bool IncomingRtpPackets::has_payload_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_payload_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::uint32_t IncomingRtpPackets::payload_type() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.payload_type)
  return _internal_payload_type();
}
inline void IncomingRtpPackets::set_payload_type(::uint32_t value) {
  _internal_set_payload_type(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.payload_type)
}
inline ::uint32_t IncomingRtpPackets::_internal_payload_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_type_;
}
inline void IncomingRtpPackets::_internal_set_payload_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.payload_type_ = value;
}

// optional uint32 sequence_number = 4;
inline bool IncomingRtpPackets::has_sequence_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_sequence_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::uint32_t IncomingRtpPackets::sequence_number() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.sequence_number)
  return _internal_sequence_number();
}
inline void IncomingRtpPackets::set_sequence_number(::uint32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.sequence_number)
}
inline ::uint32_t IncomingRtpPackets::_internal_sequence_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_number_;
}
inline void IncomingRtpPackets::_internal_set_sequence_number(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.sequence_number_ = value;
}

// optional fixed32 rtp_timestamp = 5;
inline bool IncomingRtpPackets::has_rtp_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_rtp_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rtp_timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::uint32_t IncomingRtpPackets::rtp_timestamp() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.rtp_timestamp)
  return _internal_rtp_timestamp();
}
inline void IncomingRtpPackets::set_rtp_timestamp(::uint32_t value) {
  _internal_set_rtp_timestamp(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.rtp_timestamp)
}
inline ::uint32_t IncomingRtpPackets::_internal_rtp_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rtp_timestamp_;
}
inline void IncomingRtpPackets::_internal_set_rtp_timestamp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.rtp_timestamp_ = value;
}

// optional fixed32 ssrc = 6;
inline bool IncomingRtpPackets::has_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::uint32_t IncomingRtpPackets::ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.ssrc)
  return _internal_ssrc();
}
inline void IncomingRtpPackets::set_ssrc(::uint32_t value) {
  _internal_set_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.ssrc)
}
inline ::uint32_t IncomingRtpPackets::_internal_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssrc_;
}
inline void IncomingRtpPackets::_internal_set_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.ssrc_ = value;
}

// optional uint32 payload_size = 8;
inline bool IncomingRtpPackets::has_payload_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_payload_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::uint32_t IncomingRtpPackets::payload_size() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.payload_size)
  return _internal_payload_size();
}
inline void IncomingRtpPackets::set_payload_size(::uint32_t value) {
  _internal_set_payload_size(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.payload_size)
}
inline ::uint32_t IncomingRtpPackets::_internal_payload_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_size_;
}
inline void IncomingRtpPackets::_internal_set_payload_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.payload_size_ = value;
}

// optional uint32 header_size = 9;
inline bool IncomingRtpPackets::has_header_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_header_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.header_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::uint32_t IncomingRtpPackets::header_size() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.header_size)
  return _internal_header_size();
}
inline void IncomingRtpPackets::set_header_size(::uint32_t value) {
  _internal_set_header_size(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.header_size)
}
inline ::uint32_t IncomingRtpPackets::_internal_header_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.header_size_;
}
inline void IncomingRtpPackets::_internal_set_header_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.header_size_ = value;
}

// optional uint32 padding_size = 10;
inline bool IncomingRtpPackets::has_padding_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_padding_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.padding_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::uint32_t IncomingRtpPackets::padding_size() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.padding_size)
  return _internal_padding_size();
}
inline void IncomingRtpPackets::set_padding_size(::uint32_t value) {
  _internal_set_padding_size(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.padding_size)
}
inline ::uint32_t IncomingRtpPackets::_internal_padding_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.padding_size_;
}
inline void IncomingRtpPackets::_internal_set_padding_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.padding_size_ = value;
}

// optional uint32 number_of_deltas = 11;
inline bool IncomingRtpPackets::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::uint32_t IncomingRtpPackets::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void IncomingRtpPackets::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.number_of_deltas)
}
inline ::uint32_t IncomingRtpPackets::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void IncomingRtpPackets::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.number_of_deltas_ = value;
}

// optional uint32 transport_sequence_number = 15;
inline bool IncomingRtpPackets::has_transport_sequence_number() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_transport_sequence_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transport_sequence_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline ::uint32_t IncomingRtpPackets::transport_sequence_number() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.transport_sequence_number)
  return _internal_transport_sequence_number();
}
inline void IncomingRtpPackets::set_transport_sequence_number(::uint32_t value) {
  _internal_set_transport_sequence_number(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.transport_sequence_number)
}
inline ::uint32_t IncomingRtpPackets::_internal_transport_sequence_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transport_sequence_number_;
}
inline void IncomingRtpPackets::_internal_set_transport_sequence_number(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.transport_sequence_number_ = value;
}

// optional int32 transmission_time_offset = 16;
inline bool IncomingRtpPackets::has_transmission_time_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_transmission_time_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transmission_time_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline ::int32_t IncomingRtpPackets::transmission_time_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.transmission_time_offset)
  return _internal_transmission_time_offset();
}
inline void IncomingRtpPackets::set_transmission_time_offset(::int32_t value) {
  _internal_set_transmission_time_offset(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.transmission_time_offset)
}
inline ::int32_t IncomingRtpPackets::_internal_transmission_time_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transmission_time_offset_;
}
inline void IncomingRtpPackets::_internal_set_transmission_time_offset(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.transmission_time_offset_ = value;
}

// optional uint32 absolute_send_time = 17;
inline bool IncomingRtpPackets::has_absolute_send_time() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_absolute_send_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absolute_send_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline ::uint32_t IncomingRtpPackets::absolute_send_time() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.absolute_send_time)
  return _internal_absolute_send_time();
}
inline void IncomingRtpPackets::set_absolute_send_time(::uint32_t value) {
  _internal_set_absolute_send_time(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.absolute_send_time)
}
inline ::uint32_t IncomingRtpPackets::_internal_absolute_send_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.absolute_send_time_;
}
inline void IncomingRtpPackets::_internal_set_absolute_send_time(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.absolute_send_time_ = value;
}

// optional uint32 video_rotation = 18;
inline bool IncomingRtpPackets::has_video_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_video_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.video_rotation_ = 0u;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline ::uint32_t IncomingRtpPackets::video_rotation() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.video_rotation)
  return _internal_video_rotation();
}
inline void IncomingRtpPackets::set_video_rotation(::uint32_t value) {
  _internal_set_video_rotation(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.video_rotation)
}
inline ::uint32_t IncomingRtpPackets::_internal_video_rotation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.video_rotation_;
}
inline void IncomingRtpPackets::_internal_set_video_rotation(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.video_rotation_ = value;
}

// optional uint32 audio_level = 19;
inline bool IncomingRtpPackets::has_audio_level() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_audio_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_level_ = 0u;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline ::uint32_t IncomingRtpPackets::audio_level() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.audio_level)
  return _internal_audio_level();
}
inline void IncomingRtpPackets::set_audio_level(::uint32_t value) {
  _internal_set_audio_level(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.audio_level)
}
inline ::uint32_t IncomingRtpPackets::_internal_audio_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_level_;
}
inline void IncomingRtpPackets::_internal_set_audio_level(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.audio_level_ = value;
}

// optional bool voice_activity = 20;
inline bool IncomingRtpPackets::has_voice_activity() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_voice_activity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.voice_activity_ = false;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline bool IncomingRtpPackets::voice_activity() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.voice_activity)
  return _internal_voice_activity();
}
inline void IncomingRtpPackets::set_voice_activity(bool value) {
  _internal_set_voice_activity(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.voice_activity)
}
inline bool IncomingRtpPackets::_internal_voice_activity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.voice_activity_;
}
inline void IncomingRtpPackets::_internal_set_voice_activity(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.voice_activity_ = value;
}

// optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
inline bool IncomingRtpPackets::has_dependency_descriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dependency_descriptor_ != nullptr);
  return value;
}
inline void IncomingRtpPackets::clear_dependency_descriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dependency_descriptor_ != nullptr) _impl_.dependency_descriptor_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& IncomingRtpPackets::_internal_dependency_descriptor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::webrtc::rtclog2::DependencyDescriptorsWireInfo* p = _impl_.dependency_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::rtclog2::DependencyDescriptorsWireInfo&>(::webrtc::rtclog2::_DependencyDescriptorsWireInfo_default_instance_);
}
inline const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& IncomingRtpPackets::dependency_descriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.dependency_descriptor)
  return _internal_dependency_descriptor();
}
inline void IncomingRtpPackets::unsafe_arena_set_allocated_dependency_descriptor(::webrtc::rtclog2::DependencyDescriptorsWireInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dependency_descriptor_);
  }
  _impl_.dependency_descriptor_ = reinterpret_cast<::webrtc::rtclog2::DependencyDescriptorsWireInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.rtclog2.IncomingRtpPackets.dependency_descriptor)
}
inline ::webrtc::rtclog2::DependencyDescriptorsWireInfo* IncomingRtpPackets::release_dependency_descriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* released = _impl_.dependency_descriptor_;
  _impl_.dependency_descriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::webrtc::rtclog2::DependencyDescriptorsWireInfo* IncomingRtpPackets::unsafe_arena_release_dependency_descriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.dependency_descriptor)

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* temp = _impl_.dependency_descriptor_;
  _impl_.dependency_descriptor_ = nullptr;
  return temp;
}
inline ::webrtc::rtclog2::DependencyDescriptorsWireInfo* IncomingRtpPackets::_internal_mutable_dependency_descriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.dependency_descriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::rtclog2::DependencyDescriptorsWireInfo>(GetArena());
    _impl_.dependency_descriptor_ = reinterpret_cast<::webrtc::rtclog2::DependencyDescriptorsWireInfo*>(p);
  }
  return _impl_.dependency_descriptor_;
}
inline ::webrtc::rtclog2::DependencyDescriptorsWireInfo* IncomingRtpPackets::mutable_dependency_descriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* _msg = _internal_mutable_dependency_descriptor();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.dependency_descriptor)
  return _msg;
}
inline void IncomingRtpPackets::set_allocated_dependency_descriptor(::webrtc::rtclog2::DependencyDescriptorsWireInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::webrtc::rtclog2::DependencyDescriptorsWireInfo*>(_impl_.dependency_descriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::webrtc::rtclog2::DependencyDescriptorsWireInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }

  _impl_.dependency_descriptor_ = reinterpret_cast<::webrtc::rtclog2::DependencyDescriptorsWireInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.dependency_descriptor)
}

// optional bytes timestamp_ms_deltas = 101;
inline bool IncomingRtpPackets::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IncomingRtpPackets::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.timestamp_ms_deltas)
}
inline std::string* IncomingRtpPackets::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.timestamp_ms_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.timestamp_ms_deltas)
}

// optional bytes marker_deltas = 102;
inline bool IncomingRtpPackets::has_marker_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_marker_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.marker_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IncomingRtpPackets::marker_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.marker_deltas)
  return _internal_marker_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_marker_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.marker_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.marker_deltas)
}
inline std::string* IncomingRtpPackets::mutable_marker_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_marker_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.marker_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_marker_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.marker_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_marker_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.marker_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_marker_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.marker_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_marker_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.marker_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.marker_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.marker_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_marker_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.marker_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.marker_deltas_.IsDefault()) {
          _impl_.marker_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.marker_deltas)
}

// optional bytes payload_type_deltas = 103;
inline bool IncomingRtpPackets::has_payload_type_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_payload_type_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_type_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& IncomingRtpPackets::payload_type_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.payload_type_deltas)
  return _internal_payload_type_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_payload_type_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.payload_type_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.payload_type_deltas)
}
inline std::string* IncomingRtpPackets::mutable_payload_type_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload_type_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.payload_type_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_payload_type_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_type_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_payload_type_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.payload_type_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_payload_type_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.payload_type_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_payload_type_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.payload_type_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.payload_type_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payload_type_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_payload_type_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.payload_type_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_type_deltas_.IsDefault()) {
          _impl_.payload_type_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.payload_type_deltas)
}

// optional bytes sequence_number_deltas = 104;
inline bool IncomingRtpPackets::has_sequence_number_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_number_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& IncomingRtpPackets::sequence_number_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.sequence_number_deltas)
  return _internal_sequence_number_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_sequence_number_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sequence_number_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.sequence_number_deltas)
}
inline std::string* IncomingRtpPackets::mutable_sequence_number_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sequence_number_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.sequence_number_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_sequence_number_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_number_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_sequence_number_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sequence_number_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.sequence_number_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.sequence_number_deltas)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.sequence_number_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sequence_number_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_sequence_number_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.sequence_number_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sequence_number_deltas_.IsDefault()) {
          _impl_.sequence_number_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.sequence_number_deltas)
}

// optional bytes rtp_timestamp_deltas = 105;
inline bool IncomingRtpPackets::has_rtp_timestamp_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_rtp_timestamp_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rtp_timestamp_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& IncomingRtpPackets::rtp_timestamp_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.rtp_timestamp_deltas)
  return _internal_rtp_timestamp_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_rtp_timestamp_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rtp_timestamp_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.rtp_timestamp_deltas)
}
inline std::string* IncomingRtpPackets::mutable_rtp_timestamp_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rtp_timestamp_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.rtp_timestamp_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_rtp_timestamp_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rtp_timestamp_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_rtp_timestamp_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rtp_timestamp_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_rtp_timestamp_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.rtp_timestamp_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_rtp_timestamp_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.rtp_timestamp_deltas)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.rtp_timestamp_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rtp_timestamp_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_rtp_timestamp_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.rtp_timestamp_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rtp_timestamp_deltas_.IsDefault()) {
          _impl_.rtp_timestamp_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.rtp_timestamp_deltas)
}

// optional bytes ssrc_deltas = 106;
inline bool IncomingRtpPackets::has_ssrc_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssrc_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& IncomingRtpPackets::ssrc_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.ssrc_deltas)
  return _internal_ssrc_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_ssrc_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ssrc_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.ssrc_deltas)
}
inline std::string* IncomingRtpPackets::mutable_ssrc_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ssrc_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.ssrc_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_ssrc_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssrc_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_ssrc_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ssrc_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.ssrc_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.ssrc_deltas)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.ssrc_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ssrc_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_ssrc_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.ssrc_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ssrc_deltas_.IsDefault()) {
          _impl_.ssrc_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.ssrc_deltas)
}

// optional bytes payload_size_deltas = 108;
inline bool IncomingRtpPackets::has_payload_size_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_payload_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_size_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& IncomingRtpPackets::payload_size_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.payload_size_deltas)
  return _internal_payload_size_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_payload_size_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.payload_size_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.payload_size_deltas)
}
inline std::string* IncomingRtpPackets::mutable_payload_size_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload_size_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.payload_size_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_payload_size_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_size_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_payload_size_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.payload_size_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_payload_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.payload_size_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_payload_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.payload_size_deltas)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.payload_size_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payload_size_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_payload_size_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.payload_size_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_size_deltas_.IsDefault()) {
          _impl_.payload_size_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.payload_size_deltas)
}

// optional bytes header_size_deltas = 109;
inline bool IncomingRtpPackets::has_header_size_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_header_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.header_size_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& IncomingRtpPackets::header_size_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.header_size_deltas)
  return _internal_header_size_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_header_size_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.header_size_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.header_size_deltas)
}
inline std::string* IncomingRtpPackets::mutable_header_size_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_header_size_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.header_size_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_header_size_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.header_size_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_header_size_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.header_size_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_header_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.header_size_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_header_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.header_size_deltas)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.header_size_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.header_size_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_header_size_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.header_size_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.header_size_deltas_.IsDefault()) {
          _impl_.header_size_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.header_size_deltas)
}

// optional bytes padding_size_deltas = 110;
inline bool IncomingRtpPackets::has_padding_size_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_padding_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.padding_size_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& IncomingRtpPackets::padding_size_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.padding_size_deltas)
  return _internal_padding_size_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_padding_size_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.padding_size_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.padding_size_deltas)
}
inline std::string* IncomingRtpPackets::mutable_padding_size_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_padding_size_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.padding_size_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_padding_size_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.padding_size_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_padding_size_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.padding_size_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_padding_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.padding_size_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_padding_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.padding_size_deltas)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* released = _impl_.padding_size_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.padding_size_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_padding_size_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.padding_size_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.padding_size_deltas_.IsDefault()) {
          _impl_.padding_size_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.padding_size_deltas)
}

// optional bytes transport_sequence_number_deltas = 115;
inline bool IncomingRtpPackets::has_transport_sequence_number_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_transport_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transport_sequence_number_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& IncomingRtpPackets::transport_sequence_number_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.transport_sequence_number_deltas)
  return _internal_transport_sequence_number_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_transport_sequence_number_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.transport_sequence_number_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.transport_sequence_number_deltas)
}
inline std::string* IncomingRtpPackets::mutable_transport_sequence_number_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transport_sequence_number_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.transport_sequence_number_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_transport_sequence_number_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transport_sequence_number_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_transport_sequence_number_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.transport_sequence_number_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_transport_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.transport_sequence_number_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_transport_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.transport_sequence_number_deltas)
  if ((_impl_._has_bits_[0] & 0x00000200u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* released = _impl_.transport_sequence_number_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.transport_sequence_number_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_transport_sequence_number_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.transport_sequence_number_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transport_sequence_number_deltas_.IsDefault()) {
          _impl_.transport_sequence_number_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.transport_sequence_number_deltas)
}

// optional bytes transmission_time_offset_deltas = 116;
inline bool IncomingRtpPackets::has_transmission_time_offset_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_transmission_time_offset_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transmission_time_offset_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& IncomingRtpPackets::transmission_time_offset_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.transmission_time_offset_deltas)
  return _internal_transmission_time_offset_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_transmission_time_offset_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.transmission_time_offset_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.transmission_time_offset_deltas)
}
inline std::string* IncomingRtpPackets::mutable_transmission_time_offset_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transmission_time_offset_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.transmission_time_offset_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_transmission_time_offset_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transmission_time_offset_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_transmission_time_offset_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.transmission_time_offset_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_transmission_time_offset_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.transmission_time_offset_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_transmission_time_offset_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.transmission_time_offset_deltas)
  if ((_impl_._has_bits_[0] & 0x00000400u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* released = _impl_.transmission_time_offset_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.transmission_time_offset_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_transmission_time_offset_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.transmission_time_offset_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transmission_time_offset_deltas_.IsDefault()) {
          _impl_.transmission_time_offset_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.transmission_time_offset_deltas)
}

// optional bytes absolute_send_time_deltas = 117;
inline bool IncomingRtpPackets::has_absolute_send_time_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_absolute_send_time_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absolute_send_time_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& IncomingRtpPackets::absolute_send_time_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.absolute_send_time_deltas)
  return _internal_absolute_send_time_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_absolute_send_time_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.absolute_send_time_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.absolute_send_time_deltas)
}
inline std::string* IncomingRtpPackets::mutable_absolute_send_time_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_absolute_send_time_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.absolute_send_time_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_absolute_send_time_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.absolute_send_time_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_absolute_send_time_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.absolute_send_time_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_absolute_send_time_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.absolute_send_time_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_absolute_send_time_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.absolute_send_time_deltas)
  if ((_impl_._has_bits_[0] & 0x00000800u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* released = _impl_.absolute_send_time_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.absolute_send_time_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_absolute_send_time_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.absolute_send_time_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.absolute_send_time_deltas_.IsDefault()) {
          _impl_.absolute_send_time_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.absolute_send_time_deltas)
}

// optional bytes video_rotation_deltas = 118;
inline bool IncomingRtpPackets::has_video_rotation_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_video_rotation_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.video_rotation_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& IncomingRtpPackets::video_rotation_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.video_rotation_deltas)
  return _internal_video_rotation_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_video_rotation_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.video_rotation_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.video_rotation_deltas)
}
inline std::string* IncomingRtpPackets::mutable_video_rotation_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_video_rotation_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.video_rotation_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_video_rotation_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.video_rotation_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_video_rotation_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.video_rotation_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_video_rotation_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.video_rotation_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_video_rotation_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.video_rotation_deltas)
  if ((_impl_._has_bits_[0] & 0x00001000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* released = _impl_.video_rotation_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.video_rotation_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_video_rotation_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.video_rotation_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.video_rotation_deltas_.IsDefault()) {
          _impl_.video_rotation_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.video_rotation_deltas)
}

// optional bytes audio_level_deltas = 119;
inline bool IncomingRtpPackets::has_audio_level_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_audio_level_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_level_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& IncomingRtpPackets::audio_level_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.audio_level_deltas)
  return _internal_audio_level_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_audio_level_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.audio_level_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.audio_level_deltas)
}
inline std::string* IncomingRtpPackets::mutable_audio_level_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio_level_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.audio_level_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_audio_level_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_level_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_audio_level_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.audio_level_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_audio_level_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.audio_level_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_audio_level_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.audio_level_deltas)
  if ((_impl_._has_bits_[0] & 0x00002000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* released = _impl_.audio_level_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.audio_level_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_audio_level_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.audio_level_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.audio_level_deltas_.IsDefault()) {
          _impl_.audio_level_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.audio_level_deltas)
}

// optional bytes voice_activity_deltas = 120;
inline bool IncomingRtpPackets::has_voice_activity_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void IncomingRtpPackets::clear_voice_activity_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.voice_activity_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& IncomingRtpPackets::voice_activity_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtpPackets.voice_activity_deltas)
  return _internal_voice_activity_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtpPackets::set_voice_activity_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.voice_activity_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtpPackets.voice_activity_deltas)
}
inline std::string* IncomingRtpPackets::mutable_voice_activity_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_voice_activity_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtpPackets.voice_activity_deltas)
  return _s;
}
inline const std::string& IncomingRtpPackets::_internal_voice_activity_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.voice_activity_deltas_.Get();
}
inline void IncomingRtpPackets::_internal_set_voice_activity_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.voice_activity_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtpPackets::_internal_mutable_voice_activity_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.voice_activity_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtpPackets::release_voice_activity_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtpPackets.voice_activity_deltas)
  if ((_impl_._has_bits_[0] & 0x00004000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* released = _impl_.voice_activity_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.voice_activity_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtpPackets::set_allocated_voice_activity_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.voice_activity_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.voice_activity_deltas_.IsDefault()) {
          _impl_.voice_activity_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtpPackets.voice_activity_deltas)
}

// -------------------------------------------------------------------

// OutgoingRtpPackets

// optional int64 timestamp_ms = 1;
inline bool OutgoingRtpPackets::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::int64_t OutgoingRtpPackets::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void OutgoingRtpPackets::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.timestamp_ms)
}
inline ::int64_t OutgoingRtpPackets::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void OutgoingRtpPackets::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.timestamp_ms_ = value;
}

// optional bool marker = 2;
inline bool OutgoingRtpPackets::has_marker() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_marker() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.marker_ = false;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline bool OutgoingRtpPackets::marker() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.marker)
  return _internal_marker();
}
inline void OutgoingRtpPackets::set_marker(bool value) {
  _internal_set_marker(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.marker)
}
inline bool OutgoingRtpPackets::_internal_marker() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.marker_;
}
inline void OutgoingRtpPackets::_internal_set_marker(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.marker_ = value;
}

// optional uint32 payload_type = 3;
inline bool OutgoingRtpPackets::has_payload_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_payload_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::uint32_t OutgoingRtpPackets::payload_type() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.payload_type)
  return _internal_payload_type();
}
inline void OutgoingRtpPackets::set_payload_type(::uint32_t value) {
  _internal_set_payload_type(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.payload_type)
}
inline ::uint32_t OutgoingRtpPackets::_internal_payload_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_type_;
}
inline void OutgoingRtpPackets::_internal_set_payload_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.payload_type_ = value;
}

// optional uint32 sequence_number = 4;
inline bool OutgoingRtpPackets::has_sequence_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_sequence_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::uint32_t OutgoingRtpPackets::sequence_number() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.sequence_number)
  return _internal_sequence_number();
}
inline void OutgoingRtpPackets::set_sequence_number(::uint32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.sequence_number)
}
inline ::uint32_t OutgoingRtpPackets::_internal_sequence_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_number_;
}
inline void OutgoingRtpPackets::_internal_set_sequence_number(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.sequence_number_ = value;
}

// optional fixed32 rtp_timestamp = 5;
inline bool OutgoingRtpPackets::has_rtp_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_rtp_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rtp_timestamp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::uint32_t OutgoingRtpPackets::rtp_timestamp() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.rtp_timestamp)
  return _internal_rtp_timestamp();
}
inline void OutgoingRtpPackets::set_rtp_timestamp(::uint32_t value) {
  _internal_set_rtp_timestamp(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.rtp_timestamp)
}
inline ::uint32_t OutgoingRtpPackets::_internal_rtp_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rtp_timestamp_;
}
inline void OutgoingRtpPackets::_internal_set_rtp_timestamp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.rtp_timestamp_ = value;
}

// optional fixed32 ssrc = 6;
inline bool OutgoingRtpPackets::has_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::uint32_t OutgoingRtpPackets::ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.ssrc)
  return _internal_ssrc();
}
inline void OutgoingRtpPackets::set_ssrc(::uint32_t value) {
  _internal_set_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.ssrc)
}
inline ::uint32_t OutgoingRtpPackets::_internal_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssrc_;
}
inline void OutgoingRtpPackets::_internal_set_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.ssrc_ = value;
}

// optional uint32 payload_size = 8;
inline bool OutgoingRtpPackets::has_payload_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_payload_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::uint32_t OutgoingRtpPackets::payload_size() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.payload_size)
  return _internal_payload_size();
}
inline void OutgoingRtpPackets::set_payload_size(::uint32_t value) {
  _internal_set_payload_size(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.payload_size)
}
inline ::uint32_t OutgoingRtpPackets::_internal_payload_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_size_;
}
inline void OutgoingRtpPackets::_internal_set_payload_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.payload_size_ = value;
}

// optional uint32 header_size = 9;
inline bool OutgoingRtpPackets::has_header_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_header_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.header_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::uint32_t OutgoingRtpPackets::header_size() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.header_size)
  return _internal_header_size();
}
inline void OutgoingRtpPackets::set_header_size(::uint32_t value) {
  _internal_set_header_size(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.header_size)
}
inline ::uint32_t OutgoingRtpPackets::_internal_header_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.header_size_;
}
inline void OutgoingRtpPackets::_internal_set_header_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.header_size_ = value;
}

// optional uint32 padding_size = 10;
inline bool OutgoingRtpPackets::has_padding_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_padding_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.padding_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::uint32_t OutgoingRtpPackets::padding_size() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.padding_size)
  return _internal_padding_size();
}
inline void OutgoingRtpPackets::set_padding_size(::uint32_t value) {
  _internal_set_padding_size(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.padding_size)
}
inline ::uint32_t OutgoingRtpPackets::_internal_padding_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.padding_size_;
}
inline void OutgoingRtpPackets::_internal_set_padding_size(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.padding_size_ = value;
}

// optional uint32 number_of_deltas = 11;
inline bool OutgoingRtpPackets::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::uint32_t OutgoingRtpPackets::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void OutgoingRtpPackets::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.number_of_deltas)
}
inline ::uint32_t OutgoingRtpPackets::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void OutgoingRtpPackets::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.number_of_deltas_ = value;
}

// optional uint32 transport_sequence_number = 15;
inline bool OutgoingRtpPackets::has_transport_sequence_number() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_transport_sequence_number() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transport_sequence_number_ = 0u;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline ::uint32_t OutgoingRtpPackets::transport_sequence_number() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.transport_sequence_number)
  return _internal_transport_sequence_number();
}
inline void OutgoingRtpPackets::set_transport_sequence_number(::uint32_t value) {
  _internal_set_transport_sequence_number(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.transport_sequence_number)
}
inline ::uint32_t OutgoingRtpPackets::_internal_transport_sequence_number() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transport_sequence_number_;
}
inline void OutgoingRtpPackets::_internal_set_transport_sequence_number(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.transport_sequence_number_ = value;
}

// optional int32 transmission_time_offset = 16;
inline bool OutgoingRtpPackets::has_transmission_time_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_transmission_time_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transmission_time_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline ::int32_t OutgoingRtpPackets::transmission_time_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.transmission_time_offset)
  return _internal_transmission_time_offset();
}
inline void OutgoingRtpPackets::set_transmission_time_offset(::int32_t value) {
  _internal_set_transmission_time_offset(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.transmission_time_offset)
}
inline ::int32_t OutgoingRtpPackets::_internal_transmission_time_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transmission_time_offset_;
}
inline void OutgoingRtpPackets::_internal_set_transmission_time_offset(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.transmission_time_offset_ = value;
}

// optional uint32 absolute_send_time = 17;
inline bool OutgoingRtpPackets::has_absolute_send_time() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_absolute_send_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absolute_send_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline ::uint32_t OutgoingRtpPackets::absolute_send_time() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.absolute_send_time)
  return _internal_absolute_send_time();
}
inline void OutgoingRtpPackets::set_absolute_send_time(::uint32_t value) {
  _internal_set_absolute_send_time(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.absolute_send_time)
}
inline ::uint32_t OutgoingRtpPackets::_internal_absolute_send_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.absolute_send_time_;
}
inline void OutgoingRtpPackets::_internal_set_absolute_send_time(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.absolute_send_time_ = value;
}

// optional uint32 video_rotation = 18;
inline bool OutgoingRtpPackets::has_video_rotation() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_video_rotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.video_rotation_ = 0u;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline ::uint32_t OutgoingRtpPackets::video_rotation() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.video_rotation)
  return _internal_video_rotation();
}
inline void OutgoingRtpPackets::set_video_rotation(::uint32_t value) {
  _internal_set_video_rotation(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.video_rotation)
}
inline ::uint32_t OutgoingRtpPackets::_internal_video_rotation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.video_rotation_;
}
inline void OutgoingRtpPackets::_internal_set_video_rotation(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.video_rotation_ = value;
}

// optional uint32 audio_level = 19;
inline bool OutgoingRtpPackets::has_audio_level() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_audio_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_level_ = 0u;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline ::uint32_t OutgoingRtpPackets::audio_level() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.audio_level)
  return _internal_audio_level();
}
inline void OutgoingRtpPackets::set_audio_level(::uint32_t value) {
  _internal_set_audio_level(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.audio_level)
}
inline ::uint32_t OutgoingRtpPackets::_internal_audio_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_level_;
}
inline void OutgoingRtpPackets::_internal_set_audio_level(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.audio_level_ = value;
}

// optional bool voice_activity = 20;
inline bool OutgoingRtpPackets::has_voice_activity() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_voice_activity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.voice_activity_ = false;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline bool OutgoingRtpPackets::voice_activity() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.voice_activity)
  return _internal_voice_activity();
}
inline void OutgoingRtpPackets::set_voice_activity(bool value) {
  _internal_set_voice_activity(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.voice_activity)
}
inline bool OutgoingRtpPackets::_internal_voice_activity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.voice_activity_;
}
inline void OutgoingRtpPackets::_internal_set_voice_activity(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.voice_activity_ = value;
}

// optional .webrtc.rtclog2.DependencyDescriptorsWireInfo dependency_descriptor = 21;
inline bool OutgoingRtpPackets::has_dependency_descriptor() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dependency_descriptor_ != nullptr);
  return value;
}
inline void OutgoingRtpPackets::clear_dependency_descriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dependency_descriptor_ != nullptr) _impl_.dependency_descriptor_->Clear();
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& OutgoingRtpPackets::_internal_dependency_descriptor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::webrtc::rtclog2::DependencyDescriptorsWireInfo* p = _impl_.dependency_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::rtclog2::DependencyDescriptorsWireInfo&>(::webrtc::rtclog2::_DependencyDescriptorsWireInfo_default_instance_);
}
inline const ::webrtc::rtclog2::DependencyDescriptorsWireInfo& OutgoingRtpPackets::dependency_descriptor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.dependency_descriptor)
  return _internal_dependency_descriptor();
}
inline void OutgoingRtpPackets::unsafe_arena_set_allocated_dependency_descriptor(::webrtc::rtclog2::DependencyDescriptorsWireInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dependency_descriptor_);
  }
  _impl_.dependency_descriptor_ = reinterpret_cast<::webrtc::rtclog2::DependencyDescriptorsWireInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.dependency_descriptor)
}
inline ::webrtc::rtclog2::DependencyDescriptorsWireInfo* OutgoingRtpPackets::release_dependency_descriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* released = _impl_.dependency_descriptor_;
  _impl_.dependency_descriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::webrtc::rtclog2::DependencyDescriptorsWireInfo* OutgoingRtpPackets::unsafe_arena_release_dependency_descriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.dependency_descriptor)

  _impl_._has_bits_[0] &= ~0x00008000u;
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* temp = _impl_.dependency_descriptor_;
  _impl_.dependency_descriptor_ = nullptr;
  return temp;
}
inline ::webrtc::rtclog2::DependencyDescriptorsWireInfo* OutgoingRtpPackets::_internal_mutable_dependency_descriptor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00008000u;
  if (_impl_.dependency_descriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::rtclog2::DependencyDescriptorsWireInfo>(GetArena());
    _impl_.dependency_descriptor_ = reinterpret_cast<::webrtc::rtclog2::DependencyDescriptorsWireInfo*>(p);
  }
  return _impl_.dependency_descriptor_;
}
inline ::webrtc::rtclog2::DependencyDescriptorsWireInfo* OutgoingRtpPackets::mutable_dependency_descriptor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::rtclog2::DependencyDescriptorsWireInfo* _msg = _internal_mutable_dependency_descriptor();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.dependency_descriptor)
  return _msg;
}
inline void OutgoingRtpPackets::set_allocated_dependency_descriptor(::webrtc::rtclog2::DependencyDescriptorsWireInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::webrtc::rtclog2::DependencyDescriptorsWireInfo*>(_impl_.dependency_descriptor_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::webrtc::rtclog2::DependencyDescriptorsWireInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00008000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00008000u;
  }

  _impl_.dependency_descriptor_ = reinterpret_cast<::webrtc::rtclog2::DependencyDescriptorsWireInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.dependency_descriptor)
}

// optional bytes timestamp_ms_deltas = 101;
inline bool OutgoingRtpPackets::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OutgoingRtpPackets::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.timestamp_ms_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.timestamp_ms_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.timestamp_ms_deltas)
}

// optional bytes marker_deltas = 102;
inline bool OutgoingRtpPackets::has_marker_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_marker_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.marker_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OutgoingRtpPackets::marker_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.marker_deltas)
  return _internal_marker_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_marker_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.marker_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.marker_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_marker_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_marker_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.marker_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_marker_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.marker_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_marker_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.marker_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_marker_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.marker_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_marker_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.marker_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.marker_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.marker_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_marker_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.marker_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.marker_deltas_.IsDefault()) {
          _impl_.marker_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.marker_deltas)
}

// optional bytes payload_type_deltas = 103;
inline bool OutgoingRtpPackets::has_payload_type_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_payload_type_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_type_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OutgoingRtpPackets::payload_type_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.payload_type_deltas)
  return _internal_payload_type_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_payload_type_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.payload_type_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.payload_type_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_payload_type_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload_type_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.payload_type_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_payload_type_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_type_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_payload_type_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.payload_type_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_payload_type_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.payload_type_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_payload_type_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.payload_type_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.payload_type_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payload_type_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_payload_type_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.payload_type_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_type_deltas_.IsDefault()) {
          _impl_.payload_type_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.payload_type_deltas)
}

// optional bytes sequence_number_deltas = 104;
inline bool OutgoingRtpPackets::has_sequence_number_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_number_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& OutgoingRtpPackets::sequence_number_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.sequence_number_deltas)
  return _internal_sequence_number_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_sequence_number_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sequence_number_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.sequence_number_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_sequence_number_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sequence_number_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.sequence_number_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_sequence_number_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_number_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_sequence_number_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sequence_number_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.sequence_number_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.sequence_number_deltas)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.sequence_number_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sequence_number_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_sequence_number_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.sequence_number_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sequence_number_deltas_.IsDefault()) {
          _impl_.sequence_number_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.sequence_number_deltas)
}

// optional bytes rtp_timestamp_deltas = 105;
inline bool OutgoingRtpPackets::has_rtp_timestamp_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_rtp_timestamp_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rtp_timestamp_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& OutgoingRtpPackets::rtp_timestamp_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.rtp_timestamp_deltas)
  return _internal_rtp_timestamp_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_rtp_timestamp_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rtp_timestamp_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.rtp_timestamp_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_rtp_timestamp_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_rtp_timestamp_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.rtp_timestamp_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_rtp_timestamp_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rtp_timestamp_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_rtp_timestamp_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rtp_timestamp_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_rtp_timestamp_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.rtp_timestamp_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_rtp_timestamp_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.rtp_timestamp_deltas)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.rtp_timestamp_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.rtp_timestamp_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_rtp_timestamp_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.rtp_timestamp_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.rtp_timestamp_deltas_.IsDefault()) {
          _impl_.rtp_timestamp_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.rtp_timestamp_deltas)
}

// optional bytes ssrc_deltas = 106;
inline bool OutgoingRtpPackets::has_ssrc_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssrc_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& OutgoingRtpPackets::ssrc_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.ssrc_deltas)
  return _internal_ssrc_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_ssrc_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ssrc_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.ssrc_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_ssrc_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ssrc_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.ssrc_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_ssrc_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssrc_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_ssrc_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ssrc_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.ssrc_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.ssrc_deltas)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.ssrc_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ssrc_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_ssrc_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.ssrc_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ssrc_deltas_.IsDefault()) {
          _impl_.ssrc_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.ssrc_deltas)
}

// optional bytes payload_size_deltas = 108;
inline bool OutgoingRtpPackets::has_payload_size_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_payload_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.payload_size_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& OutgoingRtpPackets::payload_size_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.payload_size_deltas)
  return _internal_payload_size_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_payload_size_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.payload_size_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.payload_size_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_payload_size_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload_size_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.payload_size_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_payload_size_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.payload_size_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_payload_size_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.payload_size_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_payload_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.payload_size_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_payload_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.payload_size_deltas)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.payload_size_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.payload_size_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_payload_size_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.payload_size_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_size_deltas_.IsDefault()) {
          _impl_.payload_size_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.payload_size_deltas)
}

// optional bytes header_size_deltas = 109;
inline bool OutgoingRtpPackets::has_header_size_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_header_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.header_size_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& OutgoingRtpPackets::header_size_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.header_size_deltas)
  return _internal_header_size_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_header_size_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.header_size_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.header_size_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_header_size_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_header_size_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.header_size_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_header_size_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.header_size_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_header_size_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.header_size_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_header_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.header_size_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_header_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.header_size_deltas)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.header_size_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.header_size_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_header_size_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.header_size_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.header_size_deltas_.IsDefault()) {
          _impl_.header_size_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.header_size_deltas)
}

// optional bytes padding_size_deltas = 110;
inline bool OutgoingRtpPackets::has_padding_size_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_padding_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.padding_size_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& OutgoingRtpPackets::padding_size_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.padding_size_deltas)
  return _internal_padding_size_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_padding_size_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.padding_size_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.padding_size_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_padding_size_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_padding_size_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.padding_size_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_padding_size_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.padding_size_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_padding_size_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.padding_size_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_padding_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.padding_size_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_padding_size_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.padding_size_deltas)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* released = _impl_.padding_size_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.padding_size_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_padding_size_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.padding_size_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.padding_size_deltas_.IsDefault()) {
          _impl_.padding_size_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.padding_size_deltas)
}

// optional bytes transport_sequence_number_deltas = 115;
inline bool OutgoingRtpPackets::has_transport_sequence_number_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_transport_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transport_sequence_number_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& OutgoingRtpPackets::transport_sequence_number_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.transport_sequence_number_deltas)
  return _internal_transport_sequence_number_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_transport_sequence_number_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.transport_sequence_number_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.transport_sequence_number_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_transport_sequence_number_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transport_sequence_number_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.transport_sequence_number_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_transport_sequence_number_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transport_sequence_number_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_transport_sequence_number_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.transport_sequence_number_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_transport_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.transport_sequence_number_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_transport_sequence_number_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.transport_sequence_number_deltas)
  if ((_impl_._has_bits_[0] & 0x00000200u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* released = _impl_.transport_sequence_number_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.transport_sequence_number_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_transport_sequence_number_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.transport_sequence_number_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transport_sequence_number_deltas_.IsDefault()) {
          _impl_.transport_sequence_number_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.transport_sequence_number_deltas)
}

// optional bytes transmission_time_offset_deltas = 116;
inline bool OutgoingRtpPackets::has_transmission_time_offset_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_transmission_time_offset_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transmission_time_offset_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const std::string& OutgoingRtpPackets::transmission_time_offset_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.transmission_time_offset_deltas)
  return _internal_transmission_time_offset_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_transmission_time_offset_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.transmission_time_offset_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.transmission_time_offset_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_transmission_time_offset_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_transmission_time_offset_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.transmission_time_offset_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_transmission_time_offset_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transmission_time_offset_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_transmission_time_offset_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.transmission_time_offset_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_transmission_time_offset_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.transmission_time_offset_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_transmission_time_offset_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.transmission_time_offset_deltas)
  if ((_impl_._has_bits_[0] & 0x00000400u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* released = _impl_.transmission_time_offset_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.transmission_time_offset_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_transmission_time_offset_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.transmission_time_offset_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.transmission_time_offset_deltas_.IsDefault()) {
          _impl_.transmission_time_offset_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.transmission_time_offset_deltas)
}

// optional bytes absolute_send_time_deltas = 117;
inline bool OutgoingRtpPackets::has_absolute_send_time_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_absolute_send_time_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absolute_send_time_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const std::string& OutgoingRtpPackets::absolute_send_time_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.absolute_send_time_deltas)
  return _internal_absolute_send_time_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_absolute_send_time_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.absolute_send_time_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.absolute_send_time_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_absolute_send_time_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_absolute_send_time_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.absolute_send_time_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_absolute_send_time_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.absolute_send_time_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_absolute_send_time_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.absolute_send_time_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_absolute_send_time_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.absolute_send_time_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_absolute_send_time_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.absolute_send_time_deltas)
  if ((_impl_._has_bits_[0] & 0x00000800u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* released = _impl_.absolute_send_time_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.absolute_send_time_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_absolute_send_time_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.absolute_send_time_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.absolute_send_time_deltas_.IsDefault()) {
          _impl_.absolute_send_time_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.absolute_send_time_deltas)
}

// optional bytes video_rotation_deltas = 118;
inline bool OutgoingRtpPackets::has_video_rotation_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_video_rotation_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.video_rotation_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const std::string& OutgoingRtpPackets::video_rotation_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.video_rotation_deltas)
  return _internal_video_rotation_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_video_rotation_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.video_rotation_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.video_rotation_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_video_rotation_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_video_rotation_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.video_rotation_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_video_rotation_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.video_rotation_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_video_rotation_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.video_rotation_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_video_rotation_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.video_rotation_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_video_rotation_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.video_rotation_deltas)
  if ((_impl_._has_bits_[0] & 0x00001000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* released = _impl_.video_rotation_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.video_rotation_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_video_rotation_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.video_rotation_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.video_rotation_deltas_.IsDefault()) {
          _impl_.video_rotation_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.video_rotation_deltas)
}

// optional bytes audio_level_deltas = 119;
inline bool OutgoingRtpPackets::has_audio_level_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_audio_level_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_level_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline const std::string& OutgoingRtpPackets::audio_level_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.audio_level_deltas)
  return _internal_audio_level_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_audio_level_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.audio_level_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.audio_level_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_audio_level_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio_level_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.audio_level_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_audio_level_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_level_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_audio_level_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.audio_level_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_audio_level_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  return _impl_.audio_level_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_audio_level_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.audio_level_deltas)
  if ((_impl_._has_bits_[0] & 0x00002000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00002000u;
  auto* released = _impl_.audio_level_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.audio_level_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_audio_level_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00002000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00002000u;
  }
  _impl_.audio_level_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.audio_level_deltas_.IsDefault()) {
          _impl_.audio_level_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.audio_level_deltas)
}

// optional bytes voice_activity_deltas = 120;
inline bool OutgoingRtpPackets::has_voice_activity_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void OutgoingRtpPackets::clear_voice_activity_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.voice_activity_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline const std::string& OutgoingRtpPackets::voice_activity_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtpPackets.voice_activity_deltas)
  return _internal_voice_activity_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtpPackets::set_voice_activity_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.voice_activity_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtpPackets.voice_activity_deltas)
}
inline std::string* OutgoingRtpPackets::mutable_voice_activity_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_voice_activity_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtpPackets.voice_activity_deltas)
  return _s;
}
inline const std::string& OutgoingRtpPackets::_internal_voice_activity_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.voice_activity_deltas_.Get();
}
inline void OutgoingRtpPackets::_internal_set_voice_activity_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.voice_activity_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtpPackets::_internal_mutable_voice_activity_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  return _impl_.voice_activity_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtpPackets::release_voice_activity_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtpPackets.voice_activity_deltas)
  if ((_impl_._has_bits_[0] & 0x00004000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00004000u;
  auto* released = _impl_.voice_activity_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.voice_activity_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtpPackets::set_allocated_voice_activity_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00004000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00004000u;
  }
  _impl_.voice_activity_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.voice_activity_deltas_.IsDefault()) {
          _impl_.voice_activity_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtpPackets.voice_activity_deltas)
}

// -------------------------------------------------------------------

// IncomingRtcpPackets

// optional int64 timestamp_ms = 1;
inline bool IncomingRtcpPackets::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IncomingRtcpPackets::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t IncomingRtcpPackets::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtcpPackets.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void IncomingRtcpPackets::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtcpPackets.timestamp_ms)
}
inline ::int64_t IncomingRtcpPackets::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void IncomingRtcpPackets::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timestamp_ms_ = value;
}

// optional bytes raw_packet = 2;
inline bool IncomingRtcpPackets::has_raw_packet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IncomingRtcpPackets::clear_raw_packet() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.raw_packet_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IncomingRtcpPackets::raw_packet() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtcpPackets.raw_packet)
  return _internal_raw_packet();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtcpPackets::set_raw_packet(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.raw_packet_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtcpPackets.raw_packet)
}
inline std::string* IncomingRtcpPackets::mutable_raw_packet() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_raw_packet();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtcpPackets.raw_packet)
  return _s;
}
inline const std::string& IncomingRtcpPackets::_internal_raw_packet() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.raw_packet_.Get();
}
inline void IncomingRtcpPackets::_internal_set_raw_packet(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.raw_packet_.Set(value, GetArena());
}
inline std::string* IncomingRtcpPackets::_internal_mutable_raw_packet() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.raw_packet_.Mutable( GetArena());
}
inline std::string* IncomingRtcpPackets::release_raw_packet() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtcpPackets.raw_packet)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.raw_packet_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.raw_packet_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtcpPackets::set_allocated_raw_packet(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.raw_packet_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.raw_packet_.IsDefault()) {
          _impl_.raw_packet_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtcpPackets.raw_packet)
}

// optional uint32 number_of_deltas = 3;
inline bool IncomingRtcpPackets::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void IncomingRtcpPackets::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t IncomingRtcpPackets::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtcpPackets.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void IncomingRtcpPackets::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtcpPackets.number_of_deltas)
}
inline ::uint32_t IncomingRtcpPackets::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void IncomingRtcpPackets::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 101;
inline bool IncomingRtcpPackets::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IncomingRtcpPackets::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IncomingRtcpPackets::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtcpPackets.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtcpPackets::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtcpPackets.timestamp_ms_deltas)
}
inline std::string* IncomingRtcpPackets::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtcpPackets.timestamp_ms_deltas)
  return _s;
}
inline const std::string& IncomingRtcpPackets::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void IncomingRtcpPackets::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* IncomingRtcpPackets::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* IncomingRtcpPackets::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtcpPackets.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtcpPackets::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtcpPackets.timestamp_ms_deltas)
}

// optional bytes raw_packet_blobs = 102;
inline bool IncomingRtcpPackets::has_raw_packet_blobs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IncomingRtcpPackets::clear_raw_packet_blobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.raw_packet_blobs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& IncomingRtcpPackets::raw_packet_blobs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IncomingRtcpPackets.raw_packet_blobs)
  return _internal_raw_packet_blobs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void IncomingRtcpPackets::set_raw_packet_blobs(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.raw_packet_blobs_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IncomingRtcpPackets.raw_packet_blobs)
}
inline std::string* IncomingRtcpPackets::mutable_raw_packet_blobs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_raw_packet_blobs();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.IncomingRtcpPackets.raw_packet_blobs)
  return _s;
}
inline const std::string& IncomingRtcpPackets::_internal_raw_packet_blobs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.raw_packet_blobs_.Get();
}
inline void IncomingRtcpPackets::_internal_set_raw_packet_blobs(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.raw_packet_blobs_.Set(value, GetArena());
}
inline std::string* IncomingRtcpPackets::_internal_mutable_raw_packet_blobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.raw_packet_blobs_.Mutable( GetArena());
}
inline std::string* IncomingRtcpPackets::release_raw_packet_blobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.IncomingRtcpPackets.raw_packet_blobs)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.raw_packet_blobs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.raw_packet_blobs_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void IncomingRtcpPackets::set_allocated_raw_packet_blobs(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.raw_packet_blobs_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.raw_packet_blobs_.IsDefault()) {
          _impl_.raw_packet_blobs_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.IncomingRtcpPackets.raw_packet_blobs)
}

// -------------------------------------------------------------------

// OutgoingRtcpPackets

// optional int64 timestamp_ms = 1;
inline bool OutgoingRtcpPackets::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void OutgoingRtcpPackets::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t OutgoingRtcpPackets::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtcpPackets.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void OutgoingRtcpPackets::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtcpPackets.timestamp_ms)
}
inline ::int64_t OutgoingRtcpPackets::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void OutgoingRtcpPackets::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timestamp_ms_ = value;
}

// optional bytes raw_packet = 2;
inline bool OutgoingRtcpPackets::has_raw_packet() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void OutgoingRtcpPackets::clear_raw_packet() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.raw_packet_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OutgoingRtcpPackets::raw_packet() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtcpPackets.raw_packet)
  return _internal_raw_packet();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtcpPackets::set_raw_packet(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.raw_packet_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtcpPackets.raw_packet)
}
inline std::string* OutgoingRtcpPackets::mutable_raw_packet() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_raw_packet();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtcpPackets.raw_packet)
  return _s;
}
inline const std::string& OutgoingRtcpPackets::_internal_raw_packet() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.raw_packet_.Get();
}
inline void OutgoingRtcpPackets::_internal_set_raw_packet(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.raw_packet_.Set(value, GetArena());
}
inline std::string* OutgoingRtcpPackets::_internal_mutable_raw_packet() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.raw_packet_.Mutable( GetArena());
}
inline std::string* OutgoingRtcpPackets::release_raw_packet() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtcpPackets.raw_packet)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.raw_packet_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.raw_packet_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtcpPackets::set_allocated_raw_packet(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.raw_packet_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.raw_packet_.IsDefault()) {
          _impl_.raw_packet_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtcpPackets.raw_packet)
}

// optional uint32 number_of_deltas = 3;
inline bool OutgoingRtcpPackets::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void OutgoingRtcpPackets::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t OutgoingRtcpPackets::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtcpPackets.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void OutgoingRtcpPackets::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtcpPackets.number_of_deltas)
}
inline ::uint32_t OutgoingRtcpPackets::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void OutgoingRtcpPackets::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 101;
inline bool OutgoingRtcpPackets::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void OutgoingRtcpPackets::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OutgoingRtcpPackets::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtcpPackets.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtcpPackets::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtcpPackets.timestamp_ms_deltas)
}
inline std::string* OutgoingRtcpPackets::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtcpPackets.timestamp_ms_deltas)
  return _s;
}
inline const std::string& OutgoingRtcpPackets::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void OutgoingRtcpPackets::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* OutgoingRtcpPackets::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* OutgoingRtcpPackets::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtcpPackets.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtcpPackets::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtcpPackets.timestamp_ms_deltas)
}

// optional bytes raw_packet_blobs = 102;
inline bool OutgoingRtcpPackets::has_raw_packet_blobs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void OutgoingRtcpPackets::clear_raw_packet_blobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.raw_packet_blobs_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OutgoingRtcpPackets::raw_packet_blobs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.OutgoingRtcpPackets.raw_packet_blobs)
  return _internal_raw_packet_blobs();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OutgoingRtcpPackets::set_raw_packet_blobs(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.raw_packet_blobs_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.OutgoingRtcpPackets.raw_packet_blobs)
}
inline std::string* OutgoingRtcpPackets::mutable_raw_packet_blobs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_raw_packet_blobs();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.OutgoingRtcpPackets.raw_packet_blobs)
  return _s;
}
inline const std::string& OutgoingRtcpPackets::_internal_raw_packet_blobs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.raw_packet_blobs_.Get();
}
inline void OutgoingRtcpPackets::_internal_set_raw_packet_blobs(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.raw_packet_blobs_.Set(value, GetArena());
}
inline std::string* OutgoingRtcpPackets::_internal_mutable_raw_packet_blobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.raw_packet_blobs_.Mutable( GetArena());
}
inline std::string* OutgoingRtcpPackets::release_raw_packet_blobs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.OutgoingRtcpPackets.raw_packet_blobs)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.raw_packet_blobs_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.raw_packet_blobs_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OutgoingRtcpPackets::set_allocated_raw_packet_blobs(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.raw_packet_blobs_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.raw_packet_blobs_.IsDefault()) {
          _impl_.raw_packet_blobs_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.OutgoingRtcpPackets.raw_packet_blobs)
}

// -------------------------------------------------------------------

// AudioPlayoutEvents

// optional int64 timestamp_ms = 1;
inline bool AudioPlayoutEvents::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AudioPlayoutEvents::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t AudioPlayoutEvents::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioPlayoutEvents.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void AudioPlayoutEvents::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioPlayoutEvents.timestamp_ms)
}
inline ::int64_t AudioPlayoutEvents::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void AudioPlayoutEvents::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 local_ssrc = 2;
inline bool AudioPlayoutEvents::has_local_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AudioPlayoutEvents::clear_local_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t AudioPlayoutEvents::local_ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioPlayoutEvents.local_ssrc)
  return _internal_local_ssrc();
}
inline void AudioPlayoutEvents::set_local_ssrc(::uint32_t value) {
  _internal_set_local_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioPlayoutEvents.local_ssrc)
}
inline ::uint32_t AudioPlayoutEvents::_internal_local_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.local_ssrc_;
}
inline void AudioPlayoutEvents::_internal_set_local_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.local_ssrc_ = value;
}

// optional uint32 number_of_deltas = 3;
inline bool AudioPlayoutEvents::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void AudioPlayoutEvents::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t AudioPlayoutEvents::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioPlayoutEvents.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void AudioPlayoutEvents::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioPlayoutEvents.number_of_deltas)
}
inline ::uint32_t AudioPlayoutEvents::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void AudioPlayoutEvents::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 101;
inline bool AudioPlayoutEvents::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AudioPlayoutEvents::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioPlayoutEvents::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioPlayoutEvents.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AudioPlayoutEvents::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioPlayoutEvents.timestamp_ms_deltas)
}
inline std::string* AudioPlayoutEvents::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.AudioPlayoutEvents.timestamp_ms_deltas)
  return _s;
}
inline const std::string& AudioPlayoutEvents::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void AudioPlayoutEvents::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* AudioPlayoutEvents::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* AudioPlayoutEvents::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.AudioPlayoutEvents.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AudioPlayoutEvents::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.AudioPlayoutEvents.timestamp_ms_deltas)
}

// optional bytes local_ssrc_deltas = 102;
inline bool AudioPlayoutEvents::has_local_ssrc_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AudioPlayoutEvents::clear_local_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_ssrc_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AudioPlayoutEvents::local_ssrc_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioPlayoutEvents.local_ssrc_deltas)
  return _internal_local_ssrc_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AudioPlayoutEvents::set_local_ssrc_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.local_ssrc_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioPlayoutEvents.local_ssrc_deltas)
}
inline std::string* AudioPlayoutEvents::mutable_local_ssrc_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_local_ssrc_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.AudioPlayoutEvents.local_ssrc_deltas)
  return _s;
}
inline const std::string& AudioPlayoutEvents::_internal_local_ssrc_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.local_ssrc_deltas_.Get();
}
inline void AudioPlayoutEvents::_internal_set_local_ssrc_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.local_ssrc_deltas_.Set(value, GetArena());
}
inline std::string* AudioPlayoutEvents::_internal_mutable_local_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.local_ssrc_deltas_.Mutable( GetArena());
}
inline std::string* AudioPlayoutEvents::release_local_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.AudioPlayoutEvents.local_ssrc_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.local_ssrc_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.local_ssrc_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AudioPlayoutEvents::set_allocated_local_ssrc_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.local_ssrc_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.local_ssrc_deltas_.IsDefault()) {
          _impl_.local_ssrc_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.AudioPlayoutEvents.local_ssrc_deltas)
}

// -------------------------------------------------------------------

// NetEqSetMinimumDelay

// optional int64 timestamp_ms = 1;
inline bool NetEqSetMinimumDelay::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NetEqSetMinimumDelay::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t NetEqSetMinimumDelay::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.NetEqSetMinimumDelay.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void NetEqSetMinimumDelay::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.NetEqSetMinimumDelay.timestamp_ms)
}
inline ::int64_t NetEqSetMinimumDelay::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void NetEqSetMinimumDelay::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timestamp_ms_ = value;
}

// optional fixed32 remote_ssrc = 2;
inline bool NetEqSetMinimumDelay::has_remote_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NetEqSetMinimumDelay::clear_remote_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remote_ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t NetEqSetMinimumDelay::remote_ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.NetEqSetMinimumDelay.remote_ssrc)
  return _internal_remote_ssrc();
}
inline void NetEqSetMinimumDelay::set_remote_ssrc(::uint32_t value) {
  _internal_set_remote_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.NetEqSetMinimumDelay.remote_ssrc)
}
inline ::uint32_t NetEqSetMinimumDelay::_internal_remote_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.remote_ssrc_;
}
inline void NetEqSetMinimumDelay::_internal_set_remote_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.remote_ssrc_ = value;
}

// optional int32 minimum_delay_ms = 3;
inline bool NetEqSetMinimumDelay::has_minimum_delay_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NetEqSetMinimumDelay::clear_minimum_delay_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minimum_delay_ms_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t NetEqSetMinimumDelay::minimum_delay_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.NetEqSetMinimumDelay.minimum_delay_ms)
  return _internal_minimum_delay_ms();
}
inline void NetEqSetMinimumDelay::set_minimum_delay_ms(::int32_t value) {
  _internal_set_minimum_delay_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.NetEqSetMinimumDelay.minimum_delay_ms)
}
inline ::int32_t NetEqSetMinimumDelay::_internal_minimum_delay_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minimum_delay_ms_;
}
inline void NetEqSetMinimumDelay::_internal_set_minimum_delay_ms(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.minimum_delay_ms_ = value;
}

// optional uint32 number_of_deltas = 4;
inline bool NetEqSetMinimumDelay::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void NetEqSetMinimumDelay::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t NetEqSetMinimumDelay::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.NetEqSetMinimumDelay.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void NetEqSetMinimumDelay::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.NetEqSetMinimumDelay.number_of_deltas)
}
inline ::uint32_t NetEqSetMinimumDelay::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void NetEqSetMinimumDelay::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 101;
inline bool NetEqSetMinimumDelay::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NetEqSetMinimumDelay::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetEqSetMinimumDelay::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.NetEqSetMinimumDelay.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetEqSetMinimumDelay::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.NetEqSetMinimumDelay.timestamp_ms_deltas)
}
inline std::string* NetEqSetMinimumDelay::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.NetEqSetMinimumDelay.timestamp_ms_deltas)
  return _s;
}
inline const std::string& NetEqSetMinimumDelay::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void NetEqSetMinimumDelay::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* NetEqSetMinimumDelay::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* NetEqSetMinimumDelay::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.NetEqSetMinimumDelay.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetEqSetMinimumDelay::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.NetEqSetMinimumDelay.timestamp_ms_deltas)
}

// optional bytes remote_ssrc_deltas = 102;
inline bool NetEqSetMinimumDelay::has_remote_ssrc_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NetEqSetMinimumDelay::clear_remote_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remote_ssrc_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetEqSetMinimumDelay::remote_ssrc_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.NetEqSetMinimumDelay.remote_ssrc_deltas)
  return _internal_remote_ssrc_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetEqSetMinimumDelay::set_remote_ssrc_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.remote_ssrc_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.NetEqSetMinimumDelay.remote_ssrc_deltas)
}
inline std::string* NetEqSetMinimumDelay::mutable_remote_ssrc_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_remote_ssrc_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.NetEqSetMinimumDelay.remote_ssrc_deltas)
  return _s;
}
inline const std::string& NetEqSetMinimumDelay::_internal_remote_ssrc_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.remote_ssrc_deltas_.Get();
}
inline void NetEqSetMinimumDelay::_internal_set_remote_ssrc_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.remote_ssrc_deltas_.Set(value, GetArena());
}
inline std::string* NetEqSetMinimumDelay::_internal_mutable_remote_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.remote_ssrc_deltas_.Mutable( GetArena());
}
inline std::string* NetEqSetMinimumDelay::release_remote_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.NetEqSetMinimumDelay.remote_ssrc_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.remote_ssrc_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.remote_ssrc_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetEqSetMinimumDelay::set_allocated_remote_ssrc_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.remote_ssrc_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.remote_ssrc_deltas_.IsDefault()) {
          _impl_.remote_ssrc_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.NetEqSetMinimumDelay.remote_ssrc_deltas)
}

// optional bytes minimum_delay_ms_deltas = 103;
inline bool NetEqSetMinimumDelay::has_minimum_delay_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NetEqSetMinimumDelay::clear_minimum_delay_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.minimum_delay_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NetEqSetMinimumDelay::minimum_delay_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.NetEqSetMinimumDelay.minimum_delay_ms_deltas)
  return _internal_minimum_delay_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NetEqSetMinimumDelay::set_minimum_delay_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.minimum_delay_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.NetEqSetMinimumDelay.minimum_delay_ms_deltas)
}
inline std::string* NetEqSetMinimumDelay::mutable_minimum_delay_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_minimum_delay_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.NetEqSetMinimumDelay.minimum_delay_ms_deltas)
  return _s;
}
inline const std::string& NetEqSetMinimumDelay::_internal_minimum_delay_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.minimum_delay_ms_deltas_.Get();
}
inline void NetEqSetMinimumDelay::_internal_set_minimum_delay_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.minimum_delay_ms_deltas_.Set(value, GetArena());
}
inline std::string* NetEqSetMinimumDelay::_internal_mutable_minimum_delay_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.minimum_delay_ms_deltas_.Mutable( GetArena());
}
inline std::string* NetEqSetMinimumDelay::release_minimum_delay_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.NetEqSetMinimumDelay.minimum_delay_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.minimum_delay_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.minimum_delay_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NetEqSetMinimumDelay::set_allocated_minimum_delay_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.minimum_delay_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.minimum_delay_ms_deltas_.IsDefault()) {
          _impl_.minimum_delay_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.NetEqSetMinimumDelay.minimum_delay_ms_deltas)
}

// -------------------------------------------------------------------

// FrameDecodedEvents

// optional int64 timestamp_ms = 1;
inline bool FrameDecodedEvents::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int64_t FrameDecodedEvents::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void FrameDecodedEvents::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.timestamp_ms)
}
inline ::int64_t FrameDecodedEvents::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void FrameDecodedEvents::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.timestamp_ms_ = value;
}

// optional fixed32 ssrc = 2;
inline bool FrameDecodedEvents::has_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t FrameDecodedEvents::ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.ssrc)
  return _internal_ssrc();
}
inline void FrameDecodedEvents::set_ssrc(::uint32_t value) {
  _internal_set_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.ssrc)
}
inline ::uint32_t FrameDecodedEvents::_internal_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssrc_;
}
inline void FrameDecodedEvents::_internal_set_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.ssrc_ = value;
}

// optional int64 render_time_ms = 3;
inline bool FrameDecodedEvents::has_render_time_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_render_time_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.render_time_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int64_t FrameDecodedEvents::render_time_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.render_time_ms)
  return _internal_render_time_ms();
}
inline void FrameDecodedEvents::set_render_time_ms(::int64_t value) {
  _internal_set_render_time_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.render_time_ms)
}
inline ::int64_t FrameDecodedEvents::_internal_render_time_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.render_time_ms_;
}
inline void FrameDecodedEvents::_internal_set_render_time_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.render_time_ms_ = value;
}

// optional int32 width = 4;
inline bool FrameDecodedEvents::has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_width() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t FrameDecodedEvents::width() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.width)
  return _internal_width();
}
inline void FrameDecodedEvents::set_width(::int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.width)
}
inline ::int32_t FrameDecodedEvents::_internal_width() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_;
}
inline void FrameDecodedEvents::_internal_set_width(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.width_ = value;
}

// optional int32 height = 5;
inline bool FrameDecodedEvents::has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_height() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t FrameDecodedEvents::height() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.height)
  return _internal_height();
}
inline void FrameDecodedEvents::set_height(::int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.height)
}
inline ::int32_t FrameDecodedEvents::_internal_height() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_;
}
inline void FrameDecodedEvents::_internal_set_height(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.height_ = value;
}

// optional .webrtc.rtclog2.FrameDecodedEvents.Codec codec = 6;
inline bool FrameDecodedEvents::has_codec() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_codec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.codec_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::webrtc::rtclog2::FrameDecodedEvents_Codec FrameDecodedEvents::codec() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.codec)
  return _internal_codec();
}
inline void FrameDecodedEvents::set_codec(::webrtc::rtclog2::FrameDecodedEvents_Codec value) {
  _internal_set_codec(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.codec)
}
inline ::webrtc::rtclog2::FrameDecodedEvents_Codec FrameDecodedEvents::_internal_codec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::FrameDecodedEvents_Codec>(_impl_.codec_);
}
inline void FrameDecodedEvents::_internal_set_codec(::webrtc::rtclog2::FrameDecodedEvents_Codec value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::FrameDecodedEvents_Codec_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.codec_ = value;
}

// optional uint32 qp = 7;
inline bool FrameDecodedEvents::has_qp() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_qp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.qp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint32_t FrameDecodedEvents::qp() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.qp)
  return _internal_qp();
}
inline void FrameDecodedEvents::set_qp(::uint32_t value) {
  _internal_set_qp(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.qp)
}
inline ::uint32_t FrameDecodedEvents::_internal_qp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.qp_;
}
inline void FrameDecodedEvents::_internal_set_qp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.qp_ = value;
}

// optional uint32 number_of_deltas = 15;
inline bool FrameDecodedEvents::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::uint32_t FrameDecodedEvents::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void FrameDecodedEvents::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.number_of_deltas)
}
inline ::uint32_t FrameDecodedEvents::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void FrameDecodedEvents::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 101;
inline bool FrameDecodedEvents::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FrameDecodedEvents::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FrameDecodedEvents::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.timestamp_ms_deltas)
}
inline std::string* FrameDecodedEvents::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.FrameDecodedEvents.timestamp_ms_deltas)
  return _s;
}
inline const std::string& FrameDecodedEvents::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void FrameDecodedEvents::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* FrameDecodedEvents::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* FrameDecodedEvents::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.FrameDecodedEvents.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FrameDecodedEvents::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.FrameDecodedEvents.timestamp_ms_deltas)
}

// optional bytes ssrc_deltas = 102;
inline bool FrameDecodedEvents::has_ssrc_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssrc_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FrameDecodedEvents::ssrc_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.ssrc_deltas)
  return _internal_ssrc_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FrameDecodedEvents::set_ssrc_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ssrc_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.ssrc_deltas)
}
inline std::string* FrameDecodedEvents::mutable_ssrc_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ssrc_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.FrameDecodedEvents.ssrc_deltas)
  return _s;
}
inline const std::string& FrameDecodedEvents::_internal_ssrc_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssrc_deltas_.Get();
}
inline void FrameDecodedEvents::_internal_set_ssrc_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ssrc_deltas_.Set(value, GetArena());
}
inline std::string* FrameDecodedEvents::_internal_mutable_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ssrc_deltas_.Mutable( GetArena());
}
inline std::string* FrameDecodedEvents::release_ssrc_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.FrameDecodedEvents.ssrc_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.ssrc_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ssrc_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FrameDecodedEvents::set_allocated_ssrc_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ssrc_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ssrc_deltas_.IsDefault()) {
          _impl_.ssrc_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.FrameDecodedEvents.ssrc_deltas)
}

// optional bytes render_time_ms_deltas = 103;
inline bool FrameDecodedEvents::has_render_time_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_render_time_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.render_time_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FrameDecodedEvents::render_time_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.render_time_ms_deltas)
  return _internal_render_time_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FrameDecodedEvents::set_render_time_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.render_time_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.render_time_ms_deltas)
}
inline std::string* FrameDecodedEvents::mutable_render_time_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_render_time_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.FrameDecodedEvents.render_time_ms_deltas)
  return _s;
}
inline const std::string& FrameDecodedEvents::_internal_render_time_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.render_time_ms_deltas_.Get();
}
inline void FrameDecodedEvents::_internal_set_render_time_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.render_time_ms_deltas_.Set(value, GetArena());
}
inline std::string* FrameDecodedEvents::_internal_mutable_render_time_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.render_time_ms_deltas_.Mutable( GetArena());
}
inline std::string* FrameDecodedEvents::release_render_time_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.FrameDecodedEvents.render_time_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.render_time_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.render_time_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FrameDecodedEvents::set_allocated_render_time_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.render_time_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.render_time_ms_deltas_.IsDefault()) {
          _impl_.render_time_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.FrameDecodedEvents.render_time_ms_deltas)
}

// optional bytes width_deltas = 104;
inline bool FrameDecodedEvents::has_width_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_width_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.width_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& FrameDecodedEvents::width_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.width_deltas)
  return _internal_width_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FrameDecodedEvents::set_width_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.width_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.width_deltas)
}
inline std::string* FrameDecodedEvents::mutable_width_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_width_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.FrameDecodedEvents.width_deltas)
  return _s;
}
inline const std::string& FrameDecodedEvents::_internal_width_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.width_deltas_.Get();
}
inline void FrameDecodedEvents::_internal_set_width_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.width_deltas_.Set(value, GetArena());
}
inline std::string* FrameDecodedEvents::_internal_mutable_width_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.width_deltas_.Mutable( GetArena());
}
inline std::string* FrameDecodedEvents::release_width_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.FrameDecodedEvents.width_deltas)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.width_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.width_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FrameDecodedEvents::set_allocated_width_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.width_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.width_deltas_.IsDefault()) {
          _impl_.width_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.FrameDecodedEvents.width_deltas)
}

// optional bytes height_deltas = 105;
inline bool FrameDecodedEvents::has_height_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_height_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.height_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& FrameDecodedEvents::height_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.height_deltas)
  return _internal_height_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FrameDecodedEvents::set_height_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.height_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.height_deltas)
}
inline std::string* FrameDecodedEvents::mutable_height_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_height_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.FrameDecodedEvents.height_deltas)
  return _s;
}
inline const std::string& FrameDecodedEvents::_internal_height_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.height_deltas_.Get();
}
inline void FrameDecodedEvents::_internal_set_height_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.height_deltas_.Set(value, GetArena());
}
inline std::string* FrameDecodedEvents::_internal_mutable_height_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.height_deltas_.Mutable( GetArena());
}
inline std::string* FrameDecodedEvents::release_height_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.FrameDecodedEvents.height_deltas)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.height_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.height_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FrameDecodedEvents::set_allocated_height_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.height_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.height_deltas_.IsDefault()) {
          _impl_.height_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.FrameDecodedEvents.height_deltas)
}

// optional bytes codec_deltas = 106;
inline bool FrameDecodedEvents::has_codec_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_codec_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.codec_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& FrameDecodedEvents::codec_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.codec_deltas)
  return _internal_codec_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FrameDecodedEvents::set_codec_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.codec_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.codec_deltas)
}
inline std::string* FrameDecodedEvents::mutable_codec_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_codec_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.FrameDecodedEvents.codec_deltas)
  return _s;
}
inline const std::string& FrameDecodedEvents::_internal_codec_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.codec_deltas_.Get();
}
inline void FrameDecodedEvents::_internal_set_codec_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.codec_deltas_.Set(value, GetArena());
}
inline std::string* FrameDecodedEvents::_internal_mutable_codec_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.codec_deltas_.Mutable( GetArena());
}
inline std::string* FrameDecodedEvents::release_codec_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.FrameDecodedEvents.codec_deltas)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.codec_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.codec_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FrameDecodedEvents::set_allocated_codec_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.codec_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.codec_deltas_.IsDefault()) {
          _impl_.codec_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.FrameDecodedEvents.codec_deltas)
}

// optional bytes qp_deltas = 107;
inline bool FrameDecodedEvents::has_qp_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void FrameDecodedEvents::clear_qp_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.qp_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& FrameDecodedEvents::qp_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.FrameDecodedEvents.qp_deltas)
  return _internal_qp_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FrameDecodedEvents::set_qp_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.qp_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.FrameDecodedEvents.qp_deltas)
}
inline std::string* FrameDecodedEvents::mutable_qp_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_qp_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.FrameDecodedEvents.qp_deltas)
  return _s;
}
inline const std::string& FrameDecodedEvents::_internal_qp_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.qp_deltas_.Get();
}
inline void FrameDecodedEvents::_internal_set_qp_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.qp_deltas_.Set(value, GetArena());
}
inline std::string* FrameDecodedEvents::_internal_mutable_qp_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.qp_deltas_.Mutable( GetArena());
}
inline std::string* FrameDecodedEvents::release_qp_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.FrameDecodedEvents.qp_deltas)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.qp_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.qp_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FrameDecodedEvents::set_allocated_qp_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.qp_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.qp_deltas_.IsDefault()) {
          _impl_.qp_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.FrameDecodedEvents.qp_deltas)
}

// -------------------------------------------------------------------

// BeginLogEvent

// optional int64 timestamp_ms = 1;
inline bool BeginLogEvent::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BeginLogEvent::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t BeginLogEvent::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BeginLogEvent.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void BeginLogEvent::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BeginLogEvent.timestamp_ms)
}
inline ::int64_t BeginLogEvent::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void BeginLogEvent::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 version = 2;
inline bool BeginLogEvent::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BeginLogEvent::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t BeginLogEvent::version() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BeginLogEvent.version)
  return _internal_version();
}
inline void BeginLogEvent::set_version(::uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BeginLogEvent.version)
}
inline ::uint32_t BeginLogEvent::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_;
}
inline void BeginLogEvent::_internal_set_version(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.version_ = value;
}

// optional int64 utc_time_ms = 3;
inline bool BeginLogEvent::has_utc_time_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BeginLogEvent::clear_utc_time_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.utc_time_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t BeginLogEvent::utc_time_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BeginLogEvent.utc_time_ms)
  return _internal_utc_time_ms();
}
inline void BeginLogEvent::set_utc_time_ms(::int64_t value) {
  _internal_set_utc_time_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BeginLogEvent.utc_time_ms)
}
inline ::int64_t BeginLogEvent::_internal_utc_time_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.utc_time_ms_;
}
inline void BeginLogEvent::_internal_set_utc_time_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.utc_time_ms_ = value;
}

// -------------------------------------------------------------------

// EndLogEvent

// optional int64 timestamp_ms = 1;
inline bool EndLogEvent::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EndLogEvent::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t EndLogEvent::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.EndLogEvent.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void EndLogEvent::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.EndLogEvent.timestamp_ms)
}
inline ::int64_t EndLogEvent::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void EndLogEvent::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_ = value;
}

// -------------------------------------------------------------------

// LossBasedBweUpdates

// optional int64 timestamp_ms = 1;
inline bool LossBasedBweUpdates::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void LossBasedBweUpdates::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t LossBasedBweUpdates::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.LossBasedBweUpdates.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void LossBasedBweUpdates::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.LossBasedBweUpdates.timestamp_ms)
}
inline ::int64_t LossBasedBweUpdates::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void LossBasedBweUpdates::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 bitrate_bps = 2;
inline bool LossBasedBweUpdates::has_bitrate_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void LossBasedBweUpdates::clear_bitrate_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bitrate_bps_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t LossBasedBweUpdates::bitrate_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.LossBasedBweUpdates.bitrate_bps)
  return _internal_bitrate_bps();
}
inline void LossBasedBweUpdates::set_bitrate_bps(::uint32_t value) {
  _internal_set_bitrate_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.LossBasedBweUpdates.bitrate_bps)
}
inline ::uint32_t LossBasedBweUpdates::_internal_bitrate_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bitrate_bps_;
}
inline void LossBasedBweUpdates::_internal_set_bitrate_bps(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.bitrate_bps_ = value;
}

// optional uint32 fraction_loss = 3;
inline bool LossBasedBweUpdates::has_fraction_loss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void LossBasedBweUpdates::clear_fraction_loss() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fraction_loss_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t LossBasedBweUpdates::fraction_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.LossBasedBweUpdates.fraction_loss)
  return _internal_fraction_loss();
}
inline void LossBasedBweUpdates::set_fraction_loss(::uint32_t value) {
  _internal_set_fraction_loss(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.LossBasedBweUpdates.fraction_loss)
}
inline ::uint32_t LossBasedBweUpdates::_internal_fraction_loss() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fraction_loss_;
}
inline void LossBasedBweUpdates::_internal_set_fraction_loss(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.fraction_loss_ = value;
}

// optional uint32 total_packets = 4;
inline bool LossBasedBweUpdates::has_total_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void LossBasedBweUpdates::clear_total_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t LossBasedBweUpdates::total_packets() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.LossBasedBweUpdates.total_packets)
  return _internal_total_packets();
}
inline void LossBasedBweUpdates::set_total_packets(::uint32_t value) {
  _internal_set_total_packets(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.LossBasedBweUpdates.total_packets)
}
inline ::uint32_t LossBasedBweUpdates::_internal_total_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_packets_;
}
inline void LossBasedBweUpdates::_internal_set_total_packets(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.total_packets_ = value;
}

// optional uint32 number_of_deltas = 5;
inline bool LossBasedBweUpdates::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void LossBasedBweUpdates::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t LossBasedBweUpdates::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.LossBasedBweUpdates.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void LossBasedBweUpdates::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.LossBasedBweUpdates.number_of_deltas)
}
inline ::uint32_t LossBasedBweUpdates::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void LossBasedBweUpdates::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 101;
inline bool LossBasedBweUpdates::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LossBasedBweUpdates::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LossBasedBweUpdates::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.LossBasedBweUpdates.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LossBasedBweUpdates::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.LossBasedBweUpdates.timestamp_ms_deltas)
}
inline std::string* LossBasedBweUpdates::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.LossBasedBweUpdates.timestamp_ms_deltas)
  return _s;
}
inline const std::string& LossBasedBweUpdates::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void LossBasedBweUpdates::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* LossBasedBweUpdates::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* LossBasedBweUpdates::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.LossBasedBweUpdates.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LossBasedBweUpdates::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.LossBasedBweUpdates.timestamp_ms_deltas)
}

// optional bytes bitrate_bps_deltas = 102;
inline bool LossBasedBweUpdates::has_bitrate_bps_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LossBasedBweUpdates::clear_bitrate_bps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bitrate_bps_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LossBasedBweUpdates::bitrate_bps_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.LossBasedBweUpdates.bitrate_bps_deltas)
  return _internal_bitrate_bps_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LossBasedBweUpdates::set_bitrate_bps_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bitrate_bps_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.LossBasedBweUpdates.bitrate_bps_deltas)
}
inline std::string* LossBasedBweUpdates::mutable_bitrate_bps_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bitrate_bps_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.LossBasedBweUpdates.bitrate_bps_deltas)
  return _s;
}
inline const std::string& LossBasedBweUpdates::_internal_bitrate_bps_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bitrate_bps_deltas_.Get();
}
inline void LossBasedBweUpdates::_internal_set_bitrate_bps_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bitrate_bps_deltas_.Set(value, GetArena());
}
inline std::string* LossBasedBweUpdates::_internal_mutable_bitrate_bps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.bitrate_bps_deltas_.Mutable( GetArena());
}
inline std::string* LossBasedBweUpdates::release_bitrate_bps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.LossBasedBweUpdates.bitrate_bps_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.bitrate_bps_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bitrate_bps_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LossBasedBweUpdates::set_allocated_bitrate_bps_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.bitrate_bps_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bitrate_bps_deltas_.IsDefault()) {
          _impl_.bitrate_bps_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.LossBasedBweUpdates.bitrate_bps_deltas)
}

// optional bytes fraction_loss_deltas = 103;
inline bool LossBasedBweUpdates::has_fraction_loss_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void LossBasedBweUpdates::clear_fraction_loss_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fraction_loss_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LossBasedBweUpdates::fraction_loss_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.LossBasedBweUpdates.fraction_loss_deltas)
  return _internal_fraction_loss_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LossBasedBweUpdates::set_fraction_loss_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fraction_loss_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.LossBasedBweUpdates.fraction_loss_deltas)
}
inline std::string* LossBasedBweUpdates::mutable_fraction_loss_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fraction_loss_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.LossBasedBweUpdates.fraction_loss_deltas)
  return _s;
}
inline const std::string& LossBasedBweUpdates::_internal_fraction_loss_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fraction_loss_deltas_.Get();
}
inline void LossBasedBweUpdates::_internal_set_fraction_loss_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fraction_loss_deltas_.Set(value, GetArena());
}
inline std::string* LossBasedBweUpdates::_internal_mutable_fraction_loss_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.fraction_loss_deltas_.Mutable( GetArena());
}
inline std::string* LossBasedBweUpdates::release_fraction_loss_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.LossBasedBweUpdates.fraction_loss_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.fraction_loss_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fraction_loss_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LossBasedBweUpdates::set_allocated_fraction_loss_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.fraction_loss_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fraction_loss_deltas_.IsDefault()) {
          _impl_.fraction_loss_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.LossBasedBweUpdates.fraction_loss_deltas)
}

// optional bytes total_packets_deltas = 104;
inline bool LossBasedBweUpdates::has_total_packets_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void LossBasedBweUpdates::clear_total_packets_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_packets_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LossBasedBweUpdates::total_packets_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.LossBasedBweUpdates.total_packets_deltas)
  return _internal_total_packets_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LossBasedBweUpdates::set_total_packets_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.total_packets_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.LossBasedBweUpdates.total_packets_deltas)
}
inline std::string* LossBasedBweUpdates::mutable_total_packets_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_total_packets_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.LossBasedBweUpdates.total_packets_deltas)
  return _s;
}
inline const std::string& LossBasedBweUpdates::_internal_total_packets_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_packets_deltas_.Get();
}
inline void LossBasedBweUpdates::_internal_set_total_packets_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.total_packets_deltas_.Set(value, GetArena());
}
inline std::string* LossBasedBweUpdates::_internal_mutable_total_packets_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.total_packets_deltas_.Mutable( GetArena());
}
inline std::string* LossBasedBweUpdates::release_total_packets_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.LossBasedBweUpdates.total_packets_deltas)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.total_packets_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.total_packets_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LossBasedBweUpdates::set_allocated_total_packets_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.total_packets_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.total_packets_deltas_.IsDefault()) {
          _impl_.total_packets_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.LossBasedBweUpdates.total_packets_deltas)
}

// -------------------------------------------------------------------

// DelayBasedBweUpdates

// optional int64 timestamp_ms = 1;
inline bool DelayBasedBweUpdates::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DelayBasedBweUpdates::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t DelayBasedBweUpdates::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DelayBasedBweUpdates.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void DelayBasedBweUpdates::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DelayBasedBweUpdates.timestamp_ms)
}
inline ::int64_t DelayBasedBweUpdates::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void DelayBasedBweUpdates::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 bitrate_bps = 2;
inline bool DelayBasedBweUpdates::has_bitrate_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void DelayBasedBweUpdates::clear_bitrate_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bitrate_bps_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t DelayBasedBweUpdates::bitrate_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DelayBasedBweUpdates.bitrate_bps)
  return _internal_bitrate_bps();
}
inline void DelayBasedBweUpdates::set_bitrate_bps(::uint32_t value) {
  _internal_set_bitrate_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DelayBasedBweUpdates.bitrate_bps)
}
inline ::uint32_t DelayBasedBweUpdates::_internal_bitrate_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bitrate_bps_;
}
inline void DelayBasedBweUpdates::_internal_set_bitrate_bps(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.bitrate_bps_ = value;
}

// optional .webrtc.rtclog2.DelayBasedBweUpdates.DetectorState detector_state = 3;
inline bool DelayBasedBweUpdates::has_detector_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void DelayBasedBweUpdates::clear_detector_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.detector_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::detector_state() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DelayBasedBweUpdates.detector_state)
  return _internal_detector_state();
}
inline void DelayBasedBweUpdates::set_detector_state(::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState value) {
  _internal_set_detector_state(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DelayBasedBweUpdates.detector_state)
}
inline ::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState DelayBasedBweUpdates::_internal_detector_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState>(_impl_.detector_state_);
}
inline void DelayBasedBweUpdates::_internal_set_detector_state(::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.detector_state_ = value;
}

// optional uint32 number_of_deltas = 4;
inline bool DelayBasedBweUpdates::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void DelayBasedBweUpdates::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t DelayBasedBweUpdates::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DelayBasedBweUpdates.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void DelayBasedBweUpdates::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DelayBasedBweUpdates.number_of_deltas)
}
inline ::uint32_t DelayBasedBweUpdates::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void DelayBasedBweUpdates::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 101;
inline bool DelayBasedBweUpdates::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DelayBasedBweUpdates::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DelayBasedBweUpdates::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DelayBasedBweUpdates.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DelayBasedBweUpdates::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DelayBasedBweUpdates.timestamp_ms_deltas)
}
inline std::string* DelayBasedBweUpdates::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.DelayBasedBweUpdates.timestamp_ms_deltas)
  return _s;
}
inline const std::string& DelayBasedBweUpdates::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void DelayBasedBweUpdates::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* DelayBasedBweUpdates::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* DelayBasedBweUpdates::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.DelayBasedBweUpdates.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DelayBasedBweUpdates::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.DelayBasedBweUpdates.timestamp_ms_deltas)
}

// optional bytes bitrate_bps_deltas = 102;
inline bool DelayBasedBweUpdates::has_bitrate_bps_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DelayBasedBweUpdates::clear_bitrate_bps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bitrate_bps_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DelayBasedBweUpdates::bitrate_bps_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DelayBasedBweUpdates.bitrate_bps_deltas)
  return _internal_bitrate_bps_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DelayBasedBweUpdates::set_bitrate_bps_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bitrate_bps_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DelayBasedBweUpdates.bitrate_bps_deltas)
}
inline std::string* DelayBasedBweUpdates::mutable_bitrate_bps_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bitrate_bps_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.DelayBasedBweUpdates.bitrate_bps_deltas)
  return _s;
}
inline const std::string& DelayBasedBweUpdates::_internal_bitrate_bps_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bitrate_bps_deltas_.Get();
}
inline void DelayBasedBweUpdates::_internal_set_bitrate_bps_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bitrate_bps_deltas_.Set(value, GetArena());
}
inline std::string* DelayBasedBweUpdates::_internal_mutable_bitrate_bps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.bitrate_bps_deltas_.Mutable( GetArena());
}
inline std::string* DelayBasedBweUpdates::release_bitrate_bps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.DelayBasedBweUpdates.bitrate_bps_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.bitrate_bps_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bitrate_bps_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DelayBasedBweUpdates::set_allocated_bitrate_bps_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.bitrate_bps_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bitrate_bps_deltas_.IsDefault()) {
          _impl_.bitrate_bps_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.DelayBasedBweUpdates.bitrate_bps_deltas)
}

// optional bytes detector_state_deltas = 103;
inline bool DelayBasedBweUpdates::has_detector_state_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DelayBasedBweUpdates::clear_detector_state_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.detector_state_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DelayBasedBweUpdates::detector_state_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DelayBasedBweUpdates.detector_state_deltas)
  return _internal_detector_state_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DelayBasedBweUpdates::set_detector_state_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.detector_state_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DelayBasedBweUpdates.detector_state_deltas)
}
inline std::string* DelayBasedBweUpdates::mutable_detector_state_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_detector_state_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.DelayBasedBweUpdates.detector_state_deltas)
  return _s;
}
inline const std::string& DelayBasedBweUpdates::_internal_detector_state_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.detector_state_deltas_.Get();
}
inline void DelayBasedBweUpdates::_internal_set_detector_state_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.detector_state_deltas_.Set(value, GetArena());
}
inline std::string* DelayBasedBweUpdates::_internal_mutable_detector_state_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.detector_state_deltas_.Mutable( GetArena());
}
inline std::string* DelayBasedBweUpdates::release_detector_state_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.DelayBasedBweUpdates.detector_state_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.detector_state_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.detector_state_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DelayBasedBweUpdates::set_allocated_detector_state_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.detector_state_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.detector_state_deltas_.IsDefault()) {
          _impl_.detector_state_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.DelayBasedBweUpdates.detector_state_deltas)
}

// -------------------------------------------------------------------

// RtpHeaderExtensionConfig

// optional int32 transmission_time_offset_id = 1;
inline bool RtpHeaderExtensionConfig::has_transmission_time_offset_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RtpHeaderExtensionConfig::clear_transmission_time_offset_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transmission_time_offset_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t RtpHeaderExtensionConfig::transmission_time_offset_id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RtpHeaderExtensionConfig.transmission_time_offset_id)
  return _internal_transmission_time_offset_id();
}
inline void RtpHeaderExtensionConfig::set_transmission_time_offset_id(::int32_t value) {
  _internal_set_transmission_time_offset_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RtpHeaderExtensionConfig.transmission_time_offset_id)
}
inline ::int32_t RtpHeaderExtensionConfig::_internal_transmission_time_offset_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transmission_time_offset_id_;
}
inline void RtpHeaderExtensionConfig::_internal_set_transmission_time_offset_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.transmission_time_offset_id_ = value;
}

// optional int32 absolute_send_time_id = 2;
inline bool RtpHeaderExtensionConfig::has_absolute_send_time_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RtpHeaderExtensionConfig::clear_absolute_send_time_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absolute_send_time_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t RtpHeaderExtensionConfig::absolute_send_time_id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RtpHeaderExtensionConfig.absolute_send_time_id)
  return _internal_absolute_send_time_id();
}
inline void RtpHeaderExtensionConfig::set_absolute_send_time_id(::int32_t value) {
  _internal_set_absolute_send_time_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RtpHeaderExtensionConfig.absolute_send_time_id)
}
inline ::int32_t RtpHeaderExtensionConfig::_internal_absolute_send_time_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.absolute_send_time_id_;
}
inline void RtpHeaderExtensionConfig::_internal_set_absolute_send_time_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.absolute_send_time_id_ = value;
}

// optional int32 transport_sequence_number_id = 3;
inline bool RtpHeaderExtensionConfig::has_transport_sequence_number_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RtpHeaderExtensionConfig::clear_transport_sequence_number_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transport_sequence_number_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t RtpHeaderExtensionConfig::transport_sequence_number_id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RtpHeaderExtensionConfig.transport_sequence_number_id)
  return _internal_transport_sequence_number_id();
}
inline void RtpHeaderExtensionConfig::set_transport_sequence_number_id(::int32_t value) {
  _internal_set_transport_sequence_number_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RtpHeaderExtensionConfig.transport_sequence_number_id)
}
inline ::int32_t RtpHeaderExtensionConfig::_internal_transport_sequence_number_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transport_sequence_number_id_;
}
inline void RtpHeaderExtensionConfig::_internal_set_transport_sequence_number_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.transport_sequence_number_id_ = value;
}

// optional int32 video_rotation_id = 4;
inline bool RtpHeaderExtensionConfig::has_video_rotation_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RtpHeaderExtensionConfig::clear_video_rotation_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.video_rotation_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t RtpHeaderExtensionConfig::video_rotation_id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RtpHeaderExtensionConfig.video_rotation_id)
  return _internal_video_rotation_id();
}
inline void RtpHeaderExtensionConfig::set_video_rotation_id(::int32_t value) {
  _internal_set_video_rotation_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RtpHeaderExtensionConfig.video_rotation_id)
}
inline ::int32_t RtpHeaderExtensionConfig::_internal_video_rotation_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.video_rotation_id_;
}
inline void RtpHeaderExtensionConfig::_internal_set_video_rotation_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.video_rotation_id_ = value;
}

// optional int32 audio_level_id = 5;
inline bool RtpHeaderExtensionConfig::has_audio_level_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RtpHeaderExtensionConfig::clear_audio_level_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.audio_level_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t RtpHeaderExtensionConfig::audio_level_id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RtpHeaderExtensionConfig.audio_level_id)
  return _internal_audio_level_id();
}
inline void RtpHeaderExtensionConfig::set_audio_level_id(::int32_t value) {
  _internal_set_audio_level_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RtpHeaderExtensionConfig.audio_level_id)
}
inline ::int32_t RtpHeaderExtensionConfig::_internal_audio_level_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.audio_level_id_;
}
inline void RtpHeaderExtensionConfig::_internal_set_audio_level_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.audio_level_id_ = value;
}

// optional int32 dependency_descriptor_id = 6;
inline bool RtpHeaderExtensionConfig::has_dependency_descriptor_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RtpHeaderExtensionConfig::clear_dependency_descriptor_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dependency_descriptor_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t RtpHeaderExtensionConfig::dependency_descriptor_id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RtpHeaderExtensionConfig.dependency_descriptor_id)
  return _internal_dependency_descriptor_id();
}
inline void RtpHeaderExtensionConfig::set_dependency_descriptor_id(::int32_t value) {
  _internal_set_dependency_descriptor_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RtpHeaderExtensionConfig.dependency_descriptor_id)
}
inline ::int32_t RtpHeaderExtensionConfig::_internal_dependency_descriptor_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dependency_descriptor_id_;
}
inline void RtpHeaderExtensionConfig::_internal_set_dependency_descriptor_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.dependency_descriptor_id_ = value;
}

// -------------------------------------------------------------------

// VideoRecvStreamConfig

// optional int64 timestamp_ms = 1;
inline bool VideoRecvStreamConfig::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VideoRecvStreamConfig::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t VideoRecvStreamConfig::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.VideoRecvStreamConfig.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void VideoRecvStreamConfig::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.VideoRecvStreamConfig.timestamp_ms)
}
inline ::int64_t VideoRecvStreamConfig::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void VideoRecvStreamConfig::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 remote_ssrc = 2;
inline bool VideoRecvStreamConfig::has_remote_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VideoRecvStreamConfig::clear_remote_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remote_ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t VideoRecvStreamConfig::remote_ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.VideoRecvStreamConfig.remote_ssrc)
  return _internal_remote_ssrc();
}
inline void VideoRecvStreamConfig::set_remote_ssrc(::uint32_t value) {
  _internal_set_remote_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.VideoRecvStreamConfig.remote_ssrc)
}
inline ::uint32_t VideoRecvStreamConfig::_internal_remote_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.remote_ssrc_;
}
inline void VideoRecvStreamConfig::_internal_set_remote_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.remote_ssrc_ = value;
}

// optional uint32 local_ssrc = 3;
inline bool VideoRecvStreamConfig::has_local_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void VideoRecvStreamConfig::clear_local_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t VideoRecvStreamConfig::local_ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.VideoRecvStreamConfig.local_ssrc)
  return _internal_local_ssrc();
}
inline void VideoRecvStreamConfig::set_local_ssrc(::uint32_t value) {
  _internal_set_local_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.VideoRecvStreamConfig.local_ssrc)
}
inline ::uint32_t VideoRecvStreamConfig::_internal_local_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.local_ssrc_;
}
inline void VideoRecvStreamConfig::_internal_set_local_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.local_ssrc_ = value;
}

// optional uint32 rtx_ssrc = 4;
inline bool VideoRecvStreamConfig::has_rtx_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void VideoRecvStreamConfig::clear_rtx_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rtx_ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t VideoRecvStreamConfig::rtx_ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.VideoRecvStreamConfig.rtx_ssrc)
  return _internal_rtx_ssrc();
}
inline void VideoRecvStreamConfig::set_rtx_ssrc(::uint32_t value) {
  _internal_set_rtx_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.VideoRecvStreamConfig.rtx_ssrc)
}
inline ::uint32_t VideoRecvStreamConfig::_internal_rtx_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rtx_ssrc_;
}
inline void VideoRecvStreamConfig::_internal_set_rtx_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.rtx_ssrc_ = value;
}

// optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
inline bool VideoRecvStreamConfig::has_header_extensions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_extensions_ != nullptr);
  return value;
}
inline void VideoRecvStreamConfig::clear_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_extensions_ != nullptr) _impl_.header_extensions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::rtclog2::RtpHeaderExtensionConfig& VideoRecvStreamConfig::_internal_header_extensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig* p = _impl_.header_extensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::rtclog2::RtpHeaderExtensionConfig&>(::webrtc::rtclog2::_RtpHeaderExtensionConfig_default_instance_);
}
inline const ::webrtc::rtclog2::RtpHeaderExtensionConfig& VideoRecvStreamConfig::header_extensions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.VideoRecvStreamConfig.header_extensions)
  return _internal_header_extensions();
}
inline void VideoRecvStreamConfig::unsafe_arena_set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_extensions_);
  }
  _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.rtclog2.VideoRecvStreamConfig.header_extensions)
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* VideoRecvStreamConfig::release_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* released = _impl_.header_extensions_;
  _impl_.header_extensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* VideoRecvStreamConfig::unsafe_arena_release_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.VideoRecvStreamConfig.header_extensions)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* temp = _impl_.header_extensions_;
  _impl_.header_extensions_ = nullptr;
  return temp;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* VideoRecvStreamConfig::_internal_mutable_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_extensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::rtclog2::RtpHeaderExtensionConfig>(GetArena());
    _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(p);
  }
  return _impl_.header_extensions_;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* VideoRecvStreamConfig::mutable_header_extensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* _msg = _internal_mutable_header_extensions();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.VideoRecvStreamConfig.header_extensions)
  return _msg;
}
inline void VideoRecvStreamConfig::set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(_impl_.header_extensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.VideoRecvStreamConfig.header_extensions)
}

// -------------------------------------------------------------------

// VideoSendStreamConfig

// optional int64 timestamp_ms = 1;
inline bool VideoSendStreamConfig::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VideoSendStreamConfig::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t VideoSendStreamConfig::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.VideoSendStreamConfig.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void VideoSendStreamConfig::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.VideoSendStreamConfig.timestamp_ms)
}
inline ::int64_t VideoSendStreamConfig::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void VideoSendStreamConfig::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 ssrc = 2;
inline bool VideoSendStreamConfig::has_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VideoSendStreamConfig::clear_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t VideoSendStreamConfig::ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.VideoSendStreamConfig.ssrc)
  return _internal_ssrc();
}
inline void VideoSendStreamConfig::set_ssrc(::uint32_t value) {
  _internal_set_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.VideoSendStreamConfig.ssrc)
}
inline ::uint32_t VideoSendStreamConfig::_internal_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssrc_;
}
inline void VideoSendStreamConfig::_internal_set_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ssrc_ = value;
}

// optional uint32 rtx_ssrc = 3;
inline bool VideoSendStreamConfig::has_rtx_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void VideoSendStreamConfig::clear_rtx_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rtx_ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t VideoSendStreamConfig::rtx_ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.VideoSendStreamConfig.rtx_ssrc)
  return _internal_rtx_ssrc();
}
inline void VideoSendStreamConfig::set_rtx_ssrc(::uint32_t value) {
  _internal_set_rtx_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.VideoSendStreamConfig.rtx_ssrc)
}
inline ::uint32_t VideoSendStreamConfig::_internal_rtx_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rtx_ssrc_;
}
inline void VideoSendStreamConfig::_internal_set_rtx_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rtx_ssrc_ = value;
}

// optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
inline bool VideoSendStreamConfig::has_header_extensions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_extensions_ != nullptr);
  return value;
}
inline void VideoSendStreamConfig::clear_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_extensions_ != nullptr) _impl_.header_extensions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::rtclog2::RtpHeaderExtensionConfig& VideoSendStreamConfig::_internal_header_extensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig* p = _impl_.header_extensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::rtclog2::RtpHeaderExtensionConfig&>(::webrtc::rtclog2::_RtpHeaderExtensionConfig_default_instance_);
}
inline const ::webrtc::rtclog2::RtpHeaderExtensionConfig& VideoSendStreamConfig::header_extensions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.VideoSendStreamConfig.header_extensions)
  return _internal_header_extensions();
}
inline void VideoSendStreamConfig::unsafe_arena_set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_extensions_);
  }
  _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.rtclog2.VideoSendStreamConfig.header_extensions)
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* VideoSendStreamConfig::release_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* released = _impl_.header_extensions_;
  _impl_.header_extensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* VideoSendStreamConfig::unsafe_arena_release_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.VideoSendStreamConfig.header_extensions)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* temp = _impl_.header_extensions_;
  _impl_.header_extensions_ = nullptr;
  return temp;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* VideoSendStreamConfig::_internal_mutable_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_extensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::rtclog2::RtpHeaderExtensionConfig>(GetArena());
    _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(p);
  }
  return _impl_.header_extensions_;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* VideoSendStreamConfig::mutable_header_extensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* _msg = _internal_mutable_header_extensions();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.VideoSendStreamConfig.header_extensions)
  return _msg;
}
inline void VideoSendStreamConfig::set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(_impl_.header_extensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.VideoSendStreamConfig.header_extensions)
}

// -------------------------------------------------------------------

// AudioRecvStreamConfig

// optional int64 timestamp_ms = 1;
inline bool AudioRecvStreamConfig::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AudioRecvStreamConfig::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t AudioRecvStreamConfig::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioRecvStreamConfig.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void AudioRecvStreamConfig::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioRecvStreamConfig.timestamp_ms)
}
inline ::int64_t AudioRecvStreamConfig::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void AudioRecvStreamConfig::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 remote_ssrc = 2;
inline bool AudioRecvStreamConfig::has_remote_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AudioRecvStreamConfig::clear_remote_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remote_ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t AudioRecvStreamConfig::remote_ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioRecvStreamConfig.remote_ssrc)
  return _internal_remote_ssrc();
}
inline void AudioRecvStreamConfig::set_remote_ssrc(::uint32_t value) {
  _internal_set_remote_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioRecvStreamConfig.remote_ssrc)
}
inline ::uint32_t AudioRecvStreamConfig::_internal_remote_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.remote_ssrc_;
}
inline void AudioRecvStreamConfig::_internal_set_remote_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.remote_ssrc_ = value;
}

// optional uint32 local_ssrc = 3;
inline bool AudioRecvStreamConfig::has_local_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AudioRecvStreamConfig::clear_local_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t AudioRecvStreamConfig::local_ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioRecvStreamConfig.local_ssrc)
  return _internal_local_ssrc();
}
inline void AudioRecvStreamConfig::set_local_ssrc(::uint32_t value) {
  _internal_set_local_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioRecvStreamConfig.local_ssrc)
}
inline ::uint32_t AudioRecvStreamConfig::_internal_local_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.local_ssrc_;
}
inline void AudioRecvStreamConfig::_internal_set_local_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.local_ssrc_ = value;
}

// optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 5;
inline bool AudioRecvStreamConfig::has_header_extensions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_extensions_ != nullptr);
  return value;
}
inline void AudioRecvStreamConfig::clear_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_extensions_ != nullptr) _impl_.header_extensions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::rtclog2::RtpHeaderExtensionConfig& AudioRecvStreamConfig::_internal_header_extensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig* p = _impl_.header_extensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::rtclog2::RtpHeaderExtensionConfig&>(::webrtc::rtclog2::_RtpHeaderExtensionConfig_default_instance_);
}
inline const ::webrtc::rtclog2::RtpHeaderExtensionConfig& AudioRecvStreamConfig::header_extensions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioRecvStreamConfig.header_extensions)
  return _internal_header_extensions();
}
inline void AudioRecvStreamConfig::unsafe_arena_set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_extensions_);
  }
  _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.rtclog2.AudioRecvStreamConfig.header_extensions)
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* AudioRecvStreamConfig::release_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* released = _impl_.header_extensions_;
  _impl_.header_extensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* AudioRecvStreamConfig::unsafe_arena_release_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.AudioRecvStreamConfig.header_extensions)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* temp = _impl_.header_extensions_;
  _impl_.header_extensions_ = nullptr;
  return temp;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* AudioRecvStreamConfig::_internal_mutable_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_extensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::rtclog2::RtpHeaderExtensionConfig>(GetArena());
    _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(p);
  }
  return _impl_.header_extensions_;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* AudioRecvStreamConfig::mutable_header_extensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* _msg = _internal_mutable_header_extensions();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.AudioRecvStreamConfig.header_extensions)
  return _msg;
}
inline void AudioRecvStreamConfig::set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(_impl_.header_extensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.AudioRecvStreamConfig.header_extensions)
}

// -------------------------------------------------------------------

// AudioSendStreamConfig

// optional int64 timestamp_ms = 1;
inline bool AudioSendStreamConfig::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AudioSendStreamConfig::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t AudioSendStreamConfig::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioSendStreamConfig.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void AudioSendStreamConfig::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioSendStreamConfig.timestamp_ms)
}
inline ::int64_t AudioSendStreamConfig::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void AudioSendStreamConfig::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 ssrc = 2;
inline bool AudioSendStreamConfig::has_ssrc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AudioSendStreamConfig::clear_ssrc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssrc_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t AudioSendStreamConfig::ssrc() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioSendStreamConfig.ssrc)
  return _internal_ssrc();
}
inline void AudioSendStreamConfig::set_ssrc(::uint32_t value) {
  _internal_set_ssrc(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioSendStreamConfig.ssrc)
}
inline ::uint32_t AudioSendStreamConfig::_internal_ssrc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssrc_;
}
inline void AudioSendStreamConfig::_internal_set_ssrc(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ssrc_ = value;
}

// optional .webrtc.rtclog2.RtpHeaderExtensionConfig header_extensions = 4;
inline bool AudioSendStreamConfig::has_header_extensions() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_extensions_ != nullptr);
  return value;
}
inline void AudioSendStreamConfig::clear_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_extensions_ != nullptr) _impl_.header_extensions_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::rtclog2::RtpHeaderExtensionConfig& AudioSendStreamConfig::_internal_header_extensions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::webrtc::rtclog2::RtpHeaderExtensionConfig* p = _impl_.header_extensions_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::rtclog2::RtpHeaderExtensionConfig&>(::webrtc::rtclog2::_RtpHeaderExtensionConfig_default_instance_);
}
inline const ::webrtc::rtclog2::RtpHeaderExtensionConfig& AudioSendStreamConfig::header_extensions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioSendStreamConfig.header_extensions)
  return _internal_header_extensions();
}
inline void AudioSendStreamConfig::unsafe_arena_set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_extensions_);
  }
  _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.rtclog2.AudioSendStreamConfig.header_extensions)
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* AudioSendStreamConfig::release_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* released = _impl_.header_extensions_;
  _impl_.header_extensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* AudioSendStreamConfig::unsafe_arena_release_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.AudioSendStreamConfig.header_extensions)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* temp = _impl_.header_extensions_;
  _impl_.header_extensions_ = nullptr;
  return temp;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* AudioSendStreamConfig::_internal_mutable_header_extensions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_extensions_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::rtclog2::RtpHeaderExtensionConfig>(GetArena());
    _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(p);
  }
  return _impl_.header_extensions_;
}
inline ::webrtc::rtclog2::RtpHeaderExtensionConfig* AudioSendStreamConfig::mutable_header_extensions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::rtclog2::RtpHeaderExtensionConfig* _msg = _internal_mutable_header_extensions();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.AudioSendStreamConfig.header_extensions)
  return _msg;
}
inline void AudioSendStreamConfig::set_allocated_header_extensions(::webrtc::rtclog2::RtpHeaderExtensionConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(_impl_.header_extensions_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_extensions_ = reinterpret_cast<::webrtc::rtclog2::RtpHeaderExtensionConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.AudioSendStreamConfig.header_extensions)
}

// -------------------------------------------------------------------

// AudioNetworkAdaptations

// optional int64 timestamp_ms = 1;
inline bool AudioNetworkAdaptations::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int64_t AudioNetworkAdaptations::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void AudioNetworkAdaptations::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.timestamp_ms)
}
inline ::int64_t AudioNetworkAdaptations::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void AudioNetworkAdaptations::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.timestamp_ms_ = value;
}

// optional int32 bitrate_bps = 2;
inline bool AudioNetworkAdaptations::has_bitrate_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_bitrate_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bitrate_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t AudioNetworkAdaptations::bitrate_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.bitrate_bps)
  return _internal_bitrate_bps();
}
inline void AudioNetworkAdaptations::set_bitrate_bps(::int32_t value) {
  _internal_set_bitrate_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.bitrate_bps)
}
inline ::int32_t AudioNetworkAdaptations::_internal_bitrate_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bitrate_bps_;
}
inline void AudioNetworkAdaptations::_internal_set_bitrate_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.bitrate_bps_ = value;
}

// optional int32 frame_length_ms = 3;
inline bool AudioNetworkAdaptations::has_frame_length_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_frame_length_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_length_ms_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t AudioNetworkAdaptations::frame_length_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.frame_length_ms)
  return _internal_frame_length_ms();
}
inline void AudioNetworkAdaptations::set_frame_length_ms(::int32_t value) {
  _internal_set_frame_length_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.frame_length_ms)
}
inline ::int32_t AudioNetworkAdaptations::_internal_frame_length_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_length_ms_;
}
inline void AudioNetworkAdaptations::_internal_set_frame_length_ms(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.frame_length_ms_ = value;
}

// optional uint32 uplink_packet_loss_fraction = 4;
inline bool AudioNetworkAdaptations::has_uplink_packet_loss_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_uplink_packet_loss_fraction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uplink_packet_loss_fraction_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint32_t AudioNetworkAdaptations::uplink_packet_loss_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.uplink_packet_loss_fraction)
  return _internal_uplink_packet_loss_fraction();
}
inline void AudioNetworkAdaptations::set_uplink_packet_loss_fraction(::uint32_t value) {
  _internal_set_uplink_packet_loss_fraction(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.uplink_packet_loss_fraction)
}
inline ::uint32_t AudioNetworkAdaptations::_internal_uplink_packet_loss_fraction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uplink_packet_loss_fraction_;
}
inline void AudioNetworkAdaptations::_internal_set_uplink_packet_loss_fraction(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.uplink_packet_loss_fraction_ = value;
}

// optional bool enable_fec = 5;
inline bool AudioNetworkAdaptations::has_enable_fec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_enable_fec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_fec_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool AudioNetworkAdaptations::enable_fec() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.enable_fec)
  return _internal_enable_fec();
}
inline void AudioNetworkAdaptations::set_enable_fec(bool value) {
  _internal_set_enable_fec(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.enable_fec)
}
inline bool AudioNetworkAdaptations::_internal_enable_fec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_fec_;
}
inline void AudioNetworkAdaptations::_internal_set_enable_fec(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.enable_fec_ = value;
}

// optional bool enable_dtx = 6;
inline bool AudioNetworkAdaptations::has_enable_dtx() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_enable_dtx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_dtx_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool AudioNetworkAdaptations::enable_dtx() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.enable_dtx)
  return _internal_enable_dtx();
}
inline void AudioNetworkAdaptations::set_enable_dtx(bool value) {
  _internal_set_enable_dtx(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.enable_dtx)
}
inline bool AudioNetworkAdaptations::_internal_enable_dtx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_dtx_;
}
inline void AudioNetworkAdaptations::_internal_set_enable_dtx(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.enable_dtx_ = value;
}

// optional uint32 num_channels = 7;
inline bool AudioNetworkAdaptations::has_num_channels() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_num_channels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_channels_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint32_t AudioNetworkAdaptations::num_channels() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.num_channels)
  return _internal_num_channels();
}
inline void AudioNetworkAdaptations::set_num_channels(::uint32_t value) {
  _internal_set_num_channels(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.num_channels)
}
inline ::uint32_t AudioNetworkAdaptations::_internal_num_channels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_channels_;
}
inline void AudioNetworkAdaptations::_internal_set_num_channels(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.num_channels_ = value;
}

// optional uint32 number_of_deltas = 8;
inline bool AudioNetworkAdaptations::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::uint32_t AudioNetworkAdaptations::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void AudioNetworkAdaptations::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.number_of_deltas)
}
inline ::uint32_t AudioNetworkAdaptations::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void AudioNetworkAdaptations::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 101;
inline bool AudioNetworkAdaptations::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioNetworkAdaptations::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AudioNetworkAdaptations::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.timestamp_ms_deltas)
}
inline std::string* AudioNetworkAdaptations::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.AudioNetworkAdaptations.timestamp_ms_deltas)
  return _s;
}
inline const std::string& AudioNetworkAdaptations::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void AudioNetworkAdaptations::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* AudioNetworkAdaptations::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* AudioNetworkAdaptations::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.AudioNetworkAdaptations.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AudioNetworkAdaptations::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.AudioNetworkAdaptations.timestamp_ms_deltas)
}

// optional bytes bitrate_bps_deltas = 102;
inline bool AudioNetworkAdaptations::has_bitrate_bps_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_bitrate_bps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bitrate_bps_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AudioNetworkAdaptations::bitrate_bps_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.bitrate_bps_deltas)
  return _internal_bitrate_bps_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AudioNetworkAdaptations::set_bitrate_bps_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bitrate_bps_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.bitrate_bps_deltas)
}
inline std::string* AudioNetworkAdaptations::mutable_bitrate_bps_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bitrate_bps_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.AudioNetworkAdaptations.bitrate_bps_deltas)
  return _s;
}
inline const std::string& AudioNetworkAdaptations::_internal_bitrate_bps_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bitrate_bps_deltas_.Get();
}
inline void AudioNetworkAdaptations::_internal_set_bitrate_bps_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.bitrate_bps_deltas_.Set(value, GetArena());
}
inline std::string* AudioNetworkAdaptations::_internal_mutable_bitrate_bps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.bitrate_bps_deltas_.Mutable( GetArena());
}
inline std::string* AudioNetworkAdaptations::release_bitrate_bps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.AudioNetworkAdaptations.bitrate_bps_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.bitrate_bps_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bitrate_bps_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AudioNetworkAdaptations::set_allocated_bitrate_bps_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.bitrate_bps_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bitrate_bps_deltas_.IsDefault()) {
          _impl_.bitrate_bps_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.AudioNetworkAdaptations.bitrate_bps_deltas)
}

// optional bytes frame_length_ms_deltas = 103;
inline bool AudioNetworkAdaptations::has_frame_length_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_frame_length_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frame_length_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AudioNetworkAdaptations::frame_length_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.frame_length_ms_deltas)
  return _internal_frame_length_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AudioNetworkAdaptations::set_frame_length_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.frame_length_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.frame_length_ms_deltas)
}
inline std::string* AudioNetworkAdaptations::mutable_frame_length_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_frame_length_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.AudioNetworkAdaptations.frame_length_ms_deltas)
  return _s;
}
inline const std::string& AudioNetworkAdaptations::_internal_frame_length_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frame_length_ms_deltas_.Get();
}
inline void AudioNetworkAdaptations::_internal_set_frame_length_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.frame_length_ms_deltas_.Set(value, GetArena());
}
inline std::string* AudioNetworkAdaptations::_internal_mutable_frame_length_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.frame_length_ms_deltas_.Mutable( GetArena());
}
inline std::string* AudioNetworkAdaptations::release_frame_length_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.AudioNetworkAdaptations.frame_length_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.frame_length_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.frame_length_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AudioNetworkAdaptations::set_allocated_frame_length_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.frame_length_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.frame_length_ms_deltas_.IsDefault()) {
          _impl_.frame_length_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.AudioNetworkAdaptations.frame_length_ms_deltas)
}

// optional bytes uplink_packet_loss_fraction_deltas = 104;
inline bool AudioNetworkAdaptations::has_uplink_packet_loss_fraction_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_uplink_packet_loss_fraction_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uplink_packet_loss_fraction_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AudioNetworkAdaptations::uplink_packet_loss_fraction_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.uplink_packet_loss_fraction_deltas)
  return _internal_uplink_packet_loss_fraction_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AudioNetworkAdaptations::set_uplink_packet_loss_fraction_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.uplink_packet_loss_fraction_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.uplink_packet_loss_fraction_deltas)
}
inline std::string* AudioNetworkAdaptations::mutable_uplink_packet_loss_fraction_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uplink_packet_loss_fraction_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.AudioNetworkAdaptations.uplink_packet_loss_fraction_deltas)
  return _s;
}
inline const std::string& AudioNetworkAdaptations::_internal_uplink_packet_loss_fraction_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uplink_packet_loss_fraction_deltas_.Get();
}
inline void AudioNetworkAdaptations::_internal_set_uplink_packet_loss_fraction_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.uplink_packet_loss_fraction_deltas_.Set(value, GetArena());
}
inline std::string* AudioNetworkAdaptations::_internal_mutable_uplink_packet_loss_fraction_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.uplink_packet_loss_fraction_deltas_.Mutable( GetArena());
}
inline std::string* AudioNetworkAdaptations::release_uplink_packet_loss_fraction_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.AudioNetworkAdaptations.uplink_packet_loss_fraction_deltas)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.uplink_packet_loss_fraction_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uplink_packet_loss_fraction_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AudioNetworkAdaptations::set_allocated_uplink_packet_loss_fraction_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.uplink_packet_loss_fraction_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uplink_packet_loss_fraction_deltas_.IsDefault()) {
          _impl_.uplink_packet_loss_fraction_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.AudioNetworkAdaptations.uplink_packet_loss_fraction_deltas)
}

// optional bytes enable_fec_deltas = 105;
inline bool AudioNetworkAdaptations::has_enable_fec_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_enable_fec_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_fec_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AudioNetworkAdaptations::enable_fec_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.enable_fec_deltas)
  return _internal_enable_fec_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AudioNetworkAdaptations::set_enable_fec_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.enable_fec_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.enable_fec_deltas)
}
inline std::string* AudioNetworkAdaptations::mutable_enable_fec_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_enable_fec_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.AudioNetworkAdaptations.enable_fec_deltas)
  return _s;
}
inline const std::string& AudioNetworkAdaptations::_internal_enable_fec_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_fec_deltas_.Get();
}
inline void AudioNetworkAdaptations::_internal_set_enable_fec_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.enable_fec_deltas_.Set(value, GetArena());
}
inline std::string* AudioNetworkAdaptations::_internal_mutable_enable_fec_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.enable_fec_deltas_.Mutable( GetArena());
}
inline std::string* AudioNetworkAdaptations::release_enable_fec_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.AudioNetworkAdaptations.enable_fec_deltas)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.enable_fec_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.enable_fec_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AudioNetworkAdaptations::set_allocated_enable_fec_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.enable_fec_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.enable_fec_deltas_.IsDefault()) {
          _impl_.enable_fec_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.AudioNetworkAdaptations.enable_fec_deltas)
}

// optional bytes enable_dtx_deltas = 106;
inline bool AudioNetworkAdaptations::has_enable_dtx_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_enable_dtx_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enable_dtx_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& AudioNetworkAdaptations::enable_dtx_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.enable_dtx_deltas)
  return _internal_enable_dtx_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AudioNetworkAdaptations::set_enable_dtx_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.enable_dtx_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.enable_dtx_deltas)
}
inline std::string* AudioNetworkAdaptations::mutable_enable_dtx_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_enable_dtx_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.AudioNetworkAdaptations.enable_dtx_deltas)
  return _s;
}
inline const std::string& AudioNetworkAdaptations::_internal_enable_dtx_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enable_dtx_deltas_.Get();
}
inline void AudioNetworkAdaptations::_internal_set_enable_dtx_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.enable_dtx_deltas_.Set(value, GetArena());
}
inline std::string* AudioNetworkAdaptations::_internal_mutable_enable_dtx_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.enable_dtx_deltas_.Mutable( GetArena());
}
inline std::string* AudioNetworkAdaptations::release_enable_dtx_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.AudioNetworkAdaptations.enable_dtx_deltas)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.enable_dtx_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.enable_dtx_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AudioNetworkAdaptations::set_allocated_enable_dtx_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.enable_dtx_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.enable_dtx_deltas_.IsDefault()) {
          _impl_.enable_dtx_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.AudioNetworkAdaptations.enable_dtx_deltas)
}

// optional bytes num_channels_deltas = 107;
inline bool AudioNetworkAdaptations::has_num_channels_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void AudioNetworkAdaptations::clear_num_channels_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_channels_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& AudioNetworkAdaptations::num_channels_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AudioNetworkAdaptations.num_channels_deltas)
  return _internal_num_channels_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AudioNetworkAdaptations::set_num_channels_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.num_channels_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AudioNetworkAdaptations.num_channels_deltas)
}
inline std::string* AudioNetworkAdaptations::mutable_num_channels_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_num_channels_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.AudioNetworkAdaptations.num_channels_deltas)
  return _s;
}
inline const std::string& AudioNetworkAdaptations::_internal_num_channels_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_channels_deltas_.Get();
}
inline void AudioNetworkAdaptations::_internal_set_num_channels_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.num_channels_deltas_.Set(value, GetArena());
}
inline std::string* AudioNetworkAdaptations::_internal_mutable_num_channels_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.num_channels_deltas_.Mutable( GetArena());
}
inline std::string* AudioNetworkAdaptations::release_num_channels_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.AudioNetworkAdaptations.num_channels_deltas)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.num_channels_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.num_channels_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AudioNetworkAdaptations::set_allocated_num_channels_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.num_channels_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.num_channels_deltas_.IsDefault()) {
          _impl_.num_channels_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.AudioNetworkAdaptations.num_channels_deltas)
}

// -------------------------------------------------------------------

// BweProbeCluster

// optional int64 timestamp_ms = 1;
inline bool BweProbeCluster::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BweProbeCluster::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t BweProbeCluster::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BweProbeCluster.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void BweProbeCluster::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BweProbeCluster.timestamp_ms)
}
inline ::int64_t BweProbeCluster::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void BweProbeCluster::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 id = 2;
inline bool BweProbeCluster::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BweProbeCluster::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t BweProbeCluster::id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BweProbeCluster.id)
  return _internal_id();
}
inline void BweProbeCluster::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BweProbeCluster.id)
}
inline ::uint32_t BweProbeCluster::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void BweProbeCluster::_internal_set_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}

// optional uint32 bitrate_bps = 3;
inline bool BweProbeCluster::has_bitrate_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BweProbeCluster::clear_bitrate_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bitrate_bps_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t BweProbeCluster::bitrate_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BweProbeCluster.bitrate_bps)
  return _internal_bitrate_bps();
}
inline void BweProbeCluster::set_bitrate_bps(::uint32_t value) {
  _internal_set_bitrate_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BweProbeCluster.bitrate_bps)
}
inline ::uint32_t BweProbeCluster::_internal_bitrate_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bitrate_bps_;
}
inline void BweProbeCluster::_internal_set_bitrate_bps(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.bitrate_bps_ = value;
}

// optional uint32 min_packets = 4;
inline bool BweProbeCluster::has_min_packets() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BweProbeCluster::clear_min_packets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_packets_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t BweProbeCluster::min_packets() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BweProbeCluster.min_packets)
  return _internal_min_packets();
}
inline void BweProbeCluster::set_min_packets(::uint32_t value) {
  _internal_set_min_packets(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BweProbeCluster.min_packets)
}
inline ::uint32_t BweProbeCluster::_internal_min_packets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_packets_;
}
inline void BweProbeCluster::_internal_set_min_packets(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.min_packets_ = value;
}

// optional uint32 min_bytes = 5;
inline bool BweProbeCluster::has_min_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BweProbeCluster::clear_min_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_bytes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t BweProbeCluster::min_bytes() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BweProbeCluster.min_bytes)
  return _internal_min_bytes();
}
inline void BweProbeCluster::set_min_bytes(::uint32_t value) {
  _internal_set_min_bytes(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BweProbeCluster.min_bytes)
}
inline ::uint32_t BweProbeCluster::_internal_min_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_bytes_;
}
inline void BweProbeCluster::_internal_set_min_bytes(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.min_bytes_ = value;
}

// -------------------------------------------------------------------

// BweProbeResultSuccess

// optional int64 timestamp_ms = 1;
inline bool BweProbeResultSuccess::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BweProbeResultSuccess::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t BweProbeResultSuccess::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BweProbeResultSuccess.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void BweProbeResultSuccess::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BweProbeResultSuccess.timestamp_ms)
}
inline ::int64_t BweProbeResultSuccess::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void BweProbeResultSuccess::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 id = 2;
inline bool BweProbeResultSuccess::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BweProbeResultSuccess::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t BweProbeResultSuccess::id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BweProbeResultSuccess.id)
  return _internal_id();
}
inline void BweProbeResultSuccess::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BweProbeResultSuccess.id)
}
inline ::uint32_t BweProbeResultSuccess::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void BweProbeResultSuccess::_internal_set_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}

// optional uint32 bitrate_bps = 3;
inline bool BweProbeResultSuccess::has_bitrate_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BweProbeResultSuccess::clear_bitrate_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bitrate_bps_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t BweProbeResultSuccess::bitrate_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BweProbeResultSuccess.bitrate_bps)
  return _internal_bitrate_bps();
}
inline void BweProbeResultSuccess::set_bitrate_bps(::uint32_t value) {
  _internal_set_bitrate_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BweProbeResultSuccess.bitrate_bps)
}
inline ::uint32_t BweProbeResultSuccess::_internal_bitrate_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bitrate_bps_;
}
inline void BweProbeResultSuccess::_internal_set_bitrate_bps(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.bitrate_bps_ = value;
}

// -------------------------------------------------------------------

// BweProbeResultFailure

// optional int64 timestamp_ms = 1;
inline bool BweProbeResultFailure::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BweProbeResultFailure::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t BweProbeResultFailure::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BweProbeResultFailure.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void BweProbeResultFailure::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BweProbeResultFailure.timestamp_ms)
}
inline ::int64_t BweProbeResultFailure::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void BweProbeResultFailure::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 id = 2;
inline bool BweProbeResultFailure::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BweProbeResultFailure::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t BweProbeResultFailure::id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BweProbeResultFailure.id)
  return _internal_id();
}
inline void BweProbeResultFailure::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BweProbeResultFailure.id)
}
inline ::uint32_t BweProbeResultFailure::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void BweProbeResultFailure::_internal_set_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}

// optional .webrtc.rtclog2.BweProbeResultFailure.FailureReason failure = 3;
inline bool BweProbeResultFailure::has_failure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BweProbeResultFailure::clear_failure() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.failure_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::webrtc::rtclog2::BweProbeResultFailure_FailureReason BweProbeResultFailure::failure() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.BweProbeResultFailure.failure)
  return _internal_failure();
}
inline void BweProbeResultFailure::set_failure(::webrtc::rtclog2::BweProbeResultFailure_FailureReason value) {
  _internal_set_failure(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.BweProbeResultFailure.failure)
}
inline ::webrtc::rtclog2::BweProbeResultFailure_FailureReason BweProbeResultFailure::_internal_failure() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::BweProbeResultFailure_FailureReason>(_impl_.failure_);
}
inline void BweProbeResultFailure::_internal_set_failure(::webrtc::rtclog2::BweProbeResultFailure_FailureReason value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::BweProbeResultFailure_FailureReason_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.failure_ = value;
}

// -------------------------------------------------------------------

// AlrState

// optional int64 timestamp_ms = 1;
inline bool AlrState::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AlrState::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t AlrState::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AlrState.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void AlrState::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AlrState.timestamp_ms)
}
inline ::int64_t AlrState::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void AlrState::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_ = value;
}

// optional bool in_alr = 2;
inline bool AlrState::has_in_alr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AlrState::clear_in_alr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.in_alr_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool AlrState::in_alr() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.AlrState.in_alr)
  return _internal_in_alr();
}
inline void AlrState::set_in_alr(bool value) {
  _internal_set_in_alr(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.AlrState.in_alr)
}
inline bool AlrState::_internal_in_alr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_alr_;
}
inline void AlrState::_internal_set_in_alr(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.in_alr_ = value;
}

// -------------------------------------------------------------------

// IceCandidatePairConfig

// optional int64 timestamp_ms = 1;
inline bool IceCandidatePairConfig::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IceCandidatePairConfig::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t IceCandidatePairConfig::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairConfig.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void IceCandidatePairConfig::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairConfig.timestamp_ms)
}
inline ::int64_t IceCandidatePairConfig::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void IceCandidatePairConfig::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_ = value;
}

// optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidatePairConfigType config_type = 2;
inline bool IceCandidatePairConfig::has_config_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IceCandidatePairConfig::clear_config_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.config_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::config_type() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairConfig.config_type)
  return _internal_config_type();
}
inline void IceCandidatePairConfig::set_config_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType value) {
  _internal_set_config_type(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairConfig.config_type)
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType IceCandidatePairConfig::_internal_config_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType>(_impl_.config_type_);
}
inline void IceCandidatePairConfig::_internal_set_config_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.config_type_ = value;
}

// optional uint32 candidate_pair_id = 3;
inline bool IceCandidatePairConfig::has_candidate_pair_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IceCandidatePairConfig::clear_candidate_pair_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.candidate_pair_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t IceCandidatePairConfig::candidate_pair_id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairConfig.candidate_pair_id)
  return _internal_candidate_pair_id();
}
inline void IceCandidatePairConfig::set_candidate_pair_id(::uint32_t value) {
  _internal_set_candidate_pair_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairConfig.candidate_pair_id)
}
inline ::uint32_t IceCandidatePairConfig::_internal_candidate_pair_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.candidate_pair_id_;
}
inline void IceCandidatePairConfig::_internal_set_candidate_pair_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.candidate_pair_id_ = value;
}

// optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType local_candidate_type = 4;
inline bool IceCandidatePairConfig::has_local_candidate_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IceCandidatePairConfig::clear_local_candidate_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_candidate_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::local_candidate_type() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairConfig.local_candidate_type)
  return _internal_local_candidate_type();
}
inline void IceCandidatePairConfig::set_local_candidate_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType value) {
  _internal_set_local_candidate_type(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairConfig.local_candidate_type)
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::_internal_local_candidate_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType>(_impl_.local_candidate_type_);
}
inline void IceCandidatePairConfig::_internal_set_local_candidate_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.local_candidate_type_ = value;
}

// optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol local_relay_protocol = 5;
inline bool IceCandidatePairConfig::has_local_relay_protocol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void IceCandidatePairConfig::clear_local_relay_protocol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_relay_protocol_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_Protocol IceCandidatePairConfig::local_relay_protocol() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairConfig.local_relay_protocol)
  return _internal_local_relay_protocol();
}
inline void IceCandidatePairConfig::set_local_relay_protocol(::webrtc::rtclog2::IceCandidatePairConfig_Protocol value) {
  _internal_set_local_relay_protocol(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairConfig.local_relay_protocol)
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_Protocol IceCandidatePairConfig::_internal_local_relay_protocol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::IceCandidatePairConfig_Protocol>(_impl_.local_relay_protocol_);
}
inline void IceCandidatePairConfig::_internal_set_local_relay_protocol(::webrtc::rtclog2::IceCandidatePairConfig_Protocol value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::IceCandidatePairConfig_Protocol_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.local_relay_protocol_ = value;
}

// optional .webrtc.rtclog2.IceCandidatePairConfig.NetworkType local_network_type = 6;
inline bool IceCandidatePairConfig::has_local_network_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void IceCandidatePairConfig::clear_local_network_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_network_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_NetworkType IceCandidatePairConfig::local_network_type() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairConfig.local_network_type)
  return _internal_local_network_type();
}
inline void IceCandidatePairConfig::set_local_network_type(::webrtc::rtclog2::IceCandidatePairConfig_NetworkType value) {
  _internal_set_local_network_type(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairConfig.local_network_type)
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_NetworkType IceCandidatePairConfig::_internal_local_network_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::IceCandidatePairConfig_NetworkType>(_impl_.local_network_type_);
}
inline void IceCandidatePairConfig::_internal_set_local_network_type(::webrtc::rtclog2::IceCandidatePairConfig_NetworkType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::IceCandidatePairConfig_NetworkType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.local_network_type_ = value;
}

// optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily local_address_family = 7;
inline bool IceCandidatePairConfig::has_local_address_family() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void IceCandidatePairConfig::clear_local_address_family() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.local_address_family_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::local_address_family() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairConfig.local_address_family)
  return _internal_local_address_family();
}
inline void IceCandidatePairConfig::set_local_address_family(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily value) {
  _internal_set_local_address_family(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairConfig.local_address_family)
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::_internal_local_address_family() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily>(_impl_.local_address_family_);
}
inline void IceCandidatePairConfig::_internal_set_local_address_family(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.local_address_family_ = value;
}

// optional .webrtc.rtclog2.IceCandidatePairConfig.IceCandidateType remote_candidate_type = 8;
inline bool IceCandidatePairConfig::has_remote_candidate_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void IceCandidatePairConfig::clear_remote_candidate_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remote_candidate_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::remote_candidate_type() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairConfig.remote_candidate_type)
  return _internal_remote_candidate_type();
}
inline void IceCandidatePairConfig::set_remote_candidate_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType value) {
  _internal_set_remote_candidate_type(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairConfig.remote_candidate_type)
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType IceCandidatePairConfig::_internal_remote_candidate_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType>(_impl_.remote_candidate_type_);
}
inline void IceCandidatePairConfig::_internal_set_remote_candidate_type(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.remote_candidate_type_ = value;
}

// optional .webrtc.rtclog2.IceCandidatePairConfig.AddressFamily remote_address_family = 9;
inline bool IceCandidatePairConfig::has_remote_address_family() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void IceCandidatePairConfig::clear_remote_address_family() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remote_address_family_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::remote_address_family() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairConfig.remote_address_family)
  return _internal_remote_address_family();
}
inline void IceCandidatePairConfig::set_remote_address_family(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily value) {
  _internal_set_remote_address_family(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairConfig.remote_address_family)
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily IceCandidatePairConfig::_internal_remote_address_family() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily>(_impl_.remote_address_family_);
}
inline void IceCandidatePairConfig::_internal_set_remote_address_family(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.remote_address_family_ = value;
}

// optional .webrtc.rtclog2.IceCandidatePairConfig.Protocol candidate_pair_protocol = 10;
inline bool IceCandidatePairConfig::has_candidate_pair_protocol() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void IceCandidatePairConfig::clear_candidate_pair_protocol() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.candidate_pair_protocol_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_Protocol IceCandidatePairConfig::candidate_pair_protocol() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairConfig.candidate_pair_protocol)
  return _internal_candidate_pair_protocol();
}
inline void IceCandidatePairConfig::set_candidate_pair_protocol(::webrtc::rtclog2::IceCandidatePairConfig_Protocol value) {
  _internal_set_candidate_pair_protocol(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairConfig.candidate_pair_protocol)
}
inline ::webrtc::rtclog2::IceCandidatePairConfig_Protocol IceCandidatePairConfig::_internal_candidate_pair_protocol() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::IceCandidatePairConfig_Protocol>(_impl_.candidate_pair_protocol_);
}
inline void IceCandidatePairConfig::_internal_set_candidate_pair_protocol(::webrtc::rtclog2::IceCandidatePairConfig_Protocol value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::IceCandidatePairConfig_Protocol_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.candidate_pair_protocol_ = value;
}

// -------------------------------------------------------------------

// IceCandidatePairEvent

// optional int64 timestamp_ms = 1;
inline bool IceCandidatePairEvent::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void IceCandidatePairEvent::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t IceCandidatePairEvent::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairEvent.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void IceCandidatePairEvent::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairEvent.timestamp_ms)
}
inline ::int64_t IceCandidatePairEvent::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void IceCandidatePairEvent::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_ = value;
}

// optional .webrtc.rtclog2.IceCandidatePairEvent.IceCandidatePairEventType event_type = 2;
inline bool IceCandidatePairEvent::has_event_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void IceCandidatePairEvent::clear_event_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.event_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::event_type() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairEvent.event_type)
  return _internal_event_type();
}
inline void IceCandidatePairEvent::set_event_type(::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairEvent.event_type)
}
inline ::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType IceCandidatePairEvent::_internal_event_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType>(_impl_.event_type_);
}
inline void IceCandidatePairEvent::_internal_set_event_type(::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.event_type_ = value;
}

// optional uint32 candidate_pair_id = 3;
inline bool IceCandidatePairEvent::has_candidate_pair_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void IceCandidatePairEvent::clear_candidate_pair_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.candidate_pair_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t IceCandidatePairEvent::candidate_pair_id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairEvent.candidate_pair_id)
  return _internal_candidate_pair_id();
}
inline void IceCandidatePairEvent::set_candidate_pair_id(::uint32_t value) {
  _internal_set_candidate_pair_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairEvent.candidate_pair_id)
}
inline ::uint32_t IceCandidatePairEvent::_internal_candidate_pair_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.candidate_pair_id_;
}
inline void IceCandidatePairEvent::_internal_set_candidate_pair_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.candidate_pair_id_ = value;
}

// optional uint32 transaction_id = 4;
inline bool IceCandidatePairEvent::has_transaction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void IceCandidatePairEvent::clear_transaction_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.transaction_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t IceCandidatePairEvent::transaction_id() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.IceCandidatePairEvent.transaction_id)
  return _internal_transaction_id();
}
inline void IceCandidatePairEvent::set_transaction_id(::uint32_t value) {
  _internal_set_transaction_id(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.IceCandidatePairEvent.transaction_id)
}
inline ::uint32_t IceCandidatePairEvent::_internal_transaction_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.transaction_id_;
}
inline void IceCandidatePairEvent::_internal_set_transaction_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.transaction_id_ = value;
}

// -------------------------------------------------------------------

// DtlsTransportStateEvent

// optional int64 timestamp_ms = 1;
inline bool DtlsTransportStateEvent::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DtlsTransportStateEvent::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t DtlsTransportStateEvent::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DtlsTransportStateEvent.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void DtlsTransportStateEvent::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DtlsTransportStateEvent.timestamp_ms)
}
inline ::int64_t DtlsTransportStateEvent::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void DtlsTransportStateEvent::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_ = value;
}

// optional .webrtc.rtclog2.DtlsTransportStateEvent.DtlsTransportState dtls_transport_state = 2;
inline bool DtlsTransportStateEvent::has_dtls_transport_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DtlsTransportStateEvent::clear_dtls_transport_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dtls_transport_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::dtls_transport_state() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DtlsTransportStateEvent.dtls_transport_state)
  return _internal_dtls_transport_state();
}
inline void DtlsTransportStateEvent::set_dtls_transport_state(::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState value) {
  _internal_set_dtls_transport_state(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DtlsTransportStateEvent.dtls_transport_state)
}
inline ::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState DtlsTransportStateEvent::_internal_dtls_transport_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState>(_impl_.dtls_transport_state_);
}
inline void DtlsTransportStateEvent::_internal_set_dtls_transport_state(::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dtls_transport_state_ = value;
}

// -------------------------------------------------------------------

// DtlsWritableState

// optional int64 timestamp_ms = 1;
inline bool DtlsWritableState::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DtlsWritableState::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t DtlsWritableState::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DtlsWritableState.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void DtlsWritableState::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DtlsWritableState.timestamp_ms)
}
inline ::int64_t DtlsWritableState::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void DtlsWritableState::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_ = value;
}

// optional bool writable = 2;
inline bool DtlsWritableState::has_writable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DtlsWritableState::clear_writable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.writable_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DtlsWritableState::writable() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.DtlsWritableState.writable)
  return _internal_writable();
}
inline void DtlsWritableState::set_writable(bool value) {
  _internal_set_writable(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.DtlsWritableState.writable)
}
inline bool DtlsWritableState::_internal_writable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.writable_;
}
inline void DtlsWritableState::_internal_set_writable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.writable_ = value;
}

// -------------------------------------------------------------------

// RouteChange

// optional int64 timestamp_ms = 1;
inline bool RouteChange::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RouteChange::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t RouteChange::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RouteChange.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void RouteChange::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RouteChange.timestamp_ms)
}
inline ::int64_t RouteChange::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void RouteChange::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_ = value;
}

// optional bool connected = 2;
inline bool RouteChange::has_connected() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RouteChange::clear_connected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connected_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool RouteChange::connected() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RouteChange.connected)
  return _internal_connected();
}
inline void RouteChange::set_connected(bool value) {
  _internal_set_connected(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RouteChange.connected)
}
inline bool RouteChange::_internal_connected() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connected_;
}
inline void RouteChange::_internal_set_connected(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.connected_ = value;
}

// optional uint32 overhead = 3;
inline bool RouteChange::has_overhead() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RouteChange::clear_overhead() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.overhead_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t RouteChange::overhead() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RouteChange.overhead)
  return _internal_overhead();
}
inline void RouteChange::set_overhead(::uint32_t value) {
  _internal_set_overhead(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RouteChange.overhead)
}
inline ::uint32_t RouteChange::_internal_overhead() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.overhead_;
}
inline void RouteChange::_internal_set_overhead(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.overhead_ = value;
}

// -------------------------------------------------------------------

// RemoteEstimates

// optional int64 timestamp_ms = 1;
inline bool RemoteEstimates::has_timestamp_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RemoteEstimates::clear_timestamp_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t RemoteEstimates::timestamp_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RemoteEstimates.timestamp_ms)
  return _internal_timestamp_ms();
}
inline void RemoteEstimates::set_timestamp_ms(::int64_t value) {
  _internal_set_timestamp_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RemoteEstimates.timestamp_ms)
}
inline ::int64_t RemoteEstimates::_internal_timestamp_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_;
}
inline void RemoteEstimates::_internal_set_timestamp_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.timestamp_ms_ = value;
}

// optional uint32 link_capacity_lower_kbps = 2;
inline bool RemoteEstimates::has_link_capacity_lower_kbps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RemoteEstimates::clear_link_capacity_lower_kbps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.link_capacity_lower_kbps_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t RemoteEstimates::link_capacity_lower_kbps() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RemoteEstimates.link_capacity_lower_kbps)
  return _internal_link_capacity_lower_kbps();
}
inline void RemoteEstimates::set_link_capacity_lower_kbps(::uint32_t value) {
  _internal_set_link_capacity_lower_kbps(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RemoteEstimates.link_capacity_lower_kbps)
}
inline ::uint32_t RemoteEstimates::_internal_link_capacity_lower_kbps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.link_capacity_lower_kbps_;
}
inline void RemoteEstimates::_internal_set_link_capacity_lower_kbps(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.link_capacity_lower_kbps_ = value;
}

// optional uint32 link_capacity_upper_kbps = 3;
inline bool RemoteEstimates::has_link_capacity_upper_kbps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RemoteEstimates::clear_link_capacity_upper_kbps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.link_capacity_upper_kbps_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t RemoteEstimates::link_capacity_upper_kbps() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RemoteEstimates.link_capacity_upper_kbps)
  return _internal_link_capacity_upper_kbps();
}
inline void RemoteEstimates::set_link_capacity_upper_kbps(::uint32_t value) {
  _internal_set_link_capacity_upper_kbps(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RemoteEstimates.link_capacity_upper_kbps)
}
inline ::uint32_t RemoteEstimates::_internal_link_capacity_upper_kbps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.link_capacity_upper_kbps_;
}
inline void RemoteEstimates::_internal_set_link_capacity_upper_kbps(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.link_capacity_upper_kbps_ = value;
}

// optional uint32 number_of_deltas = 4;
inline bool RemoteEstimates::has_number_of_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RemoteEstimates::clear_number_of_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.number_of_deltas_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t RemoteEstimates::number_of_deltas() const {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RemoteEstimates.number_of_deltas)
  return _internal_number_of_deltas();
}
inline void RemoteEstimates::set_number_of_deltas(::uint32_t value) {
  _internal_set_number_of_deltas(value);
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RemoteEstimates.number_of_deltas)
}
inline ::uint32_t RemoteEstimates::_internal_number_of_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.number_of_deltas_;
}
inline void RemoteEstimates::_internal_set_number_of_deltas(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.number_of_deltas_ = value;
}

// optional bytes timestamp_ms_deltas = 101;
inline bool RemoteEstimates::has_timestamp_ms_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RemoteEstimates::clear_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_ms_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RemoteEstimates::timestamp_ms_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RemoteEstimates.timestamp_ms_deltas)
  return _internal_timestamp_ms_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteEstimates::set_timestamp_ms_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RemoteEstimates.timestamp_ms_deltas)
}
inline std::string* RemoteEstimates::mutable_timestamp_ms_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp_ms_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.RemoteEstimates.timestamp_ms_deltas)
  return _s;
}
inline const std::string& RemoteEstimates::_internal_timestamp_ms_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_ms_deltas_.Get();
}
inline void RemoteEstimates::_internal_set_timestamp_ms_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.timestamp_ms_deltas_.Set(value, GetArena());
}
inline std::string* RemoteEstimates::_internal_mutable_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.timestamp_ms_deltas_.Mutable( GetArena());
}
inline std::string* RemoteEstimates::release_timestamp_ms_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.RemoteEstimates.timestamp_ms_deltas)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.timestamp_ms_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timestamp_ms_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RemoteEstimates::set_allocated_timestamp_ms_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timestamp_ms_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_ms_deltas_.IsDefault()) {
          _impl_.timestamp_ms_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.RemoteEstimates.timestamp_ms_deltas)
}

// optional bytes link_capacity_lower_kbps_deltas = 102;
inline bool RemoteEstimates::has_link_capacity_lower_kbps_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RemoteEstimates::clear_link_capacity_lower_kbps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.link_capacity_lower_kbps_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RemoteEstimates::link_capacity_lower_kbps_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RemoteEstimates.link_capacity_lower_kbps_deltas)
  return _internal_link_capacity_lower_kbps_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteEstimates::set_link_capacity_lower_kbps_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.link_capacity_lower_kbps_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RemoteEstimates.link_capacity_lower_kbps_deltas)
}
inline std::string* RemoteEstimates::mutable_link_capacity_lower_kbps_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_link_capacity_lower_kbps_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.RemoteEstimates.link_capacity_lower_kbps_deltas)
  return _s;
}
inline const std::string& RemoteEstimates::_internal_link_capacity_lower_kbps_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.link_capacity_lower_kbps_deltas_.Get();
}
inline void RemoteEstimates::_internal_set_link_capacity_lower_kbps_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.link_capacity_lower_kbps_deltas_.Set(value, GetArena());
}
inline std::string* RemoteEstimates::_internal_mutable_link_capacity_lower_kbps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.link_capacity_lower_kbps_deltas_.Mutable( GetArena());
}
inline std::string* RemoteEstimates::release_link_capacity_lower_kbps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.RemoteEstimates.link_capacity_lower_kbps_deltas)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.link_capacity_lower_kbps_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.link_capacity_lower_kbps_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RemoteEstimates::set_allocated_link_capacity_lower_kbps_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.link_capacity_lower_kbps_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_capacity_lower_kbps_deltas_.IsDefault()) {
          _impl_.link_capacity_lower_kbps_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.RemoteEstimates.link_capacity_lower_kbps_deltas)
}

// optional bytes link_capacity_upper_kbps_deltas = 103;
inline bool RemoteEstimates::has_link_capacity_upper_kbps_deltas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RemoteEstimates::clear_link_capacity_upper_kbps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.link_capacity_upper_kbps_deltas_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RemoteEstimates::link_capacity_upper_kbps_deltas() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.rtclog2.RemoteEstimates.link_capacity_upper_kbps_deltas)
  return _internal_link_capacity_upper_kbps_deltas();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RemoteEstimates::set_link_capacity_upper_kbps_deltas(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.link_capacity_upper_kbps_deltas_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:webrtc.rtclog2.RemoteEstimates.link_capacity_upper_kbps_deltas)
}
inline std::string* RemoteEstimates::mutable_link_capacity_upper_kbps_deltas() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_link_capacity_upper_kbps_deltas();
  // @@protoc_insertion_point(field_mutable:webrtc.rtclog2.RemoteEstimates.link_capacity_upper_kbps_deltas)
  return _s;
}
inline const std::string& RemoteEstimates::_internal_link_capacity_upper_kbps_deltas() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.link_capacity_upper_kbps_deltas_.Get();
}
inline void RemoteEstimates::_internal_set_link_capacity_upper_kbps_deltas(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.link_capacity_upper_kbps_deltas_.Set(value, GetArena());
}
inline std::string* RemoteEstimates::_internal_mutable_link_capacity_upper_kbps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.link_capacity_upper_kbps_deltas_.Mutable( GetArena());
}
inline std::string* RemoteEstimates::release_link_capacity_upper_kbps_deltas() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.rtclog2.RemoteEstimates.link_capacity_upper_kbps_deltas)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.link_capacity_upper_kbps_deltas_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.link_capacity_upper_kbps_deltas_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RemoteEstimates::set_allocated_link_capacity_upper_kbps_deltas(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.link_capacity_upper_kbps_deltas_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.link_capacity_upper_kbps_deltas_.IsDefault()) {
          _impl_.link_capacity_upper_kbps_deltas_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:webrtc.rtclog2.RemoteEstimates.link_capacity_upper_kbps_deltas)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace rtclog2
}  // namespace webrtc


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::webrtc::rtclog2::FrameDecodedEvents_Codec> : std::true_type {};
template <>
struct is_proto_enum<::webrtc::rtclog2::DelayBasedBweUpdates_DetectorState> : std::true_type {};
template <>
struct is_proto_enum<::webrtc::rtclog2::BweProbeResultFailure_FailureReason> : std::true_type {};
template <>
struct is_proto_enum<::webrtc::rtclog2::IceCandidatePairConfig_IceCandidatePairConfigType> : std::true_type {};
template <>
struct is_proto_enum<::webrtc::rtclog2::IceCandidatePairConfig_IceCandidateType> : std::true_type {};
template <>
struct is_proto_enum<::webrtc::rtclog2::IceCandidatePairConfig_Protocol> : std::true_type {};
template <>
struct is_proto_enum<::webrtc::rtclog2::IceCandidatePairConfig_AddressFamily> : std::true_type {};
template <>
struct is_proto_enum<::webrtc::rtclog2::IceCandidatePairConfig_NetworkType> : std::true_type {};
template <>
struct is_proto_enum<::webrtc::rtclog2::IceCandidatePairEvent_IceCandidatePairEventType> : std::true_type {};
template <>
struct is_proto_enum<::webrtc::rtclog2::DtlsTransportStateEvent_DtlsTransportState> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_rtc_5fevent_5flog2_2eproto_2epb_2eh
