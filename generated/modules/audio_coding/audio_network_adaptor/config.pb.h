// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_config_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_config_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_config_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_config_2eproto {
  static const ::uint32_t offsets[];
};
namespace webrtc {
namespace audio_network_adaptor {
namespace config {
class BitrateController;
struct BitrateControllerDefaultTypeInternal;
extern BitrateControllerDefaultTypeInternal _BitrateController_default_instance_;
class ChannelController;
struct ChannelControllerDefaultTypeInternal;
extern ChannelControllerDefaultTypeInternal _ChannelController_default_instance_;
class Controller;
struct ControllerDefaultTypeInternal;
extern ControllerDefaultTypeInternal _Controller_default_instance_;
class ControllerManager;
struct ControllerManagerDefaultTypeInternal;
extern ControllerManagerDefaultTypeInternal _ControllerManager_default_instance_;
class Controller_ScoringPoint;
struct Controller_ScoringPointDefaultTypeInternal;
extern Controller_ScoringPointDefaultTypeInternal _Controller_ScoringPoint_default_instance_;
class DtxController;
struct DtxControllerDefaultTypeInternal;
extern DtxControllerDefaultTypeInternal _DtxController_default_instance_;
class FecController;
struct FecControllerDefaultTypeInternal;
extern FecControllerDefaultTypeInternal _FecController_default_instance_;
class FecControllerRplrBased;
struct FecControllerRplrBasedDefaultTypeInternal;
extern FecControllerRplrBasedDefaultTypeInternal _FecControllerRplrBased_default_instance_;
class FecControllerRplrBased_Threshold;
struct FecControllerRplrBased_ThresholdDefaultTypeInternal;
extern FecControllerRplrBased_ThresholdDefaultTypeInternal _FecControllerRplrBased_Threshold_default_instance_;
class FecController_Threshold;
struct FecController_ThresholdDefaultTypeInternal;
extern FecController_ThresholdDefaultTypeInternal _FecController_Threshold_default_instance_;
class FrameLengthController;
struct FrameLengthControllerDefaultTypeInternal;
extern FrameLengthControllerDefaultTypeInternal _FrameLengthController_default_instance_;
class FrameLengthControllerV2;
struct FrameLengthControllerV2DefaultTypeInternal;
extern FrameLengthControllerV2DefaultTypeInternal _FrameLengthControllerV2_default_instance_;
}  // namespace config
}  // namespace audio_network_adaptor
}  // namespace webrtc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace webrtc {
namespace audio_network_adaptor {
namespace config {

// ===================================================================


// -------------------------------------------------------------------

class FrameLengthControllerV2 final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FrameLengthControllerV2) */ {
 public:
  inline FrameLengthControllerV2() : FrameLengthControllerV2(nullptr) {}
  ~FrameLengthControllerV2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FrameLengthControllerV2(::google::protobuf::internal::ConstantInitialized);

  inline FrameLengthControllerV2(const FrameLengthControllerV2& from)
      : FrameLengthControllerV2(nullptr, from) {}
  FrameLengthControllerV2(FrameLengthControllerV2&& from) noexcept
    : FrameLengthControllerV2() {
    *this = ::std::move(from);
  }

  inline FrameLengthControllerV2& operator=(const FrameLengthControllerV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameLengthControllerV2& operator=(FrameLengthControllerV2&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FrameLengthControllerV2& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameLengthControllerV2* internal_default_instance() {
    return reinterpret_cast<const FrameLengthControllerV2*>(
               &_FrameLengthControllerV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FrameLengthControllerV2& a, FrameLengthControllerV2& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameLengthControllerV2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameLengthControllerV2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameLengthControllerV2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameLengthControllerV2>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const FrameLengthControllerV2& from);
  void MergeFrom(const FrameLengthControllerV2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FrameLengthControllerV2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.FrameLengthControllerV2";
  }
  protected:
  explicit FrameLengthControllerV2(::google::protobuf::Arena* arena);
  FrameLengthControllerV2(::google::protobuf::Arena* arena, const FrameLengthControllerV2& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinPayloadBitrateBpsFieldNumber = 1,
    kUseSlowAdaptationFieldNumber = 2,
  };
  // optional int32 min_payload_bitrate_bps = 1;
  bool has_min_payload_bitrate_bps() const;
  void clear_min_payload_bitrate_bps() ;
  ::int32_t min_payload_bitrate_bps() const;
  void set_min_payload_bitrate_bps(::int32_t value);

  private:
  ::int32_t _internal_min_payload_bitrate_bps() const;
  void _internal_set_min_payload_bitrate_bps(::int32_t value);

  public:
  // optional bool use_slow_adaptation = 2;
  bool has_use_slow_adaptation() const;
  void clear_use_slow_adaptation() ;
  bool use_slow_adaptation() const;
  void set_use_slow_adaptation(bool value);

  private:
  bool _internal_use_slow_adaptation() const;
  void _internal_set_use_slow_adaptation(bool value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FrameLengthControllerV2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t min_payload_bitrate_bps_;
    bool use_slow_adaptation_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};// -------------------------------------------------------------------

class FrameLengthController final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FrameLengthController) */ {
 public:
  inline FrameLengthController() : FrameLengthController(nullptr) {}
  ~FrameLengthController() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FrameLengthController(::google::protobuf::internal::ConstantInitialized);

  inline FrameLengthController(const FrameLengthController& from)
      : FrameLengthController(nullptr, from) {}
  FrameLengthController(FrameLengthController&& from) noexcept
    : FrameLengthController() {
    *this = ::std::move(from);
  }

  inline FrameLengthController& operator=(const FrameLengthController& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameLengthController& operator=(FrameLengthController&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FrameLengthController& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameLengthController* internal_default_instance() {
    return reinterpret_cast<const FrameLengthController*>(
               &_FrameLengthController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FrameLengthController& a, FrameLengthController& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameLengthController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameLengthController* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameLengthController* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameLengthController>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const FrameLengthController& from);
  void MergeFrom(const FrameLengthController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FrameLengthController* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.FrameLengthController";
  }
  protected:
  explicit FrameLengthController(::google::protobuf::Arena* arena);
  FrameLengthController(::google::protobuf::Arena* arena, const FrameLengthController& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlIncreasingPacketLossFractionFieldNumber = 1,
    kFlDecreasingPacketLossFractionFieldNumber = 2,
    kFl20MsTo60MsBandwidthBpsFieldNumber = 3,
    kFl60MsTo20MsBandwidthBpsFieldNumber = 4,
    kFl60MsTo120MsBandwidthBpsFieldNumber = 5,
    kFl120MsTo60MsBandwidthBpsFieldNumber = 6,
    kFlIncreaseOverheadOffsetFieldNumber = 7,
    kFlDecreaseOverheadOffsetFieldNumber = 8,
    kFl20MsTo40MsBandwidthBpsFieldNumber = 9,
    kFl40MsTo20MsBandwidthBpsFieldNumber = 10,
    kFl40MsTo60MsBandwidthBpsFieldNumber = 11,
    kFl60MsTo40MsBandwidthBpsFieldNumber = 12,
  };
  // optional float fl_increasing_packet_loss_fraction = 1;
  bool has_fl_increasing_packet_loss_fraction() const;
  void clear_fl_increasing_packet_loss_fraction() ;
  float fl_increasing_packet_loss_fraction() const;
  void set_fl_increasing_packet_loss_fraction(float value);

  private:
  float _internal_fl_increasing_packet_loss_fraction() const;
  void _internal_set_fl_increasing_packet_loss_fraction(float value);

  public:
  // optional float fl_decreasing_packet_loss_fraction = 2;
  bool has_fl_decreasing_packet_loss_fraction() const;
  void clear_fl_decreasing_packet_loss_fraction() ;
  float fl_decreasing_packet_loss_fraction() const;
  void set_fl_decreasing_packet_loss_fraction(float value);

  private:
  float _internal_fl_decreasing_packet_loss_fraction() const;
  void _internal_set_fl_decreasing_packet_loss_fraction(float value);

  public:
  // optional int32 fl_20ms_to_60ms_bandwidth_bps = 3;
  bool has_fl_20ms_to_60ms_bandwidth_bps() const;
  void clear_fl_20ms_to_60ms_bandwidth_bps() ;
  ::int32_t fl_20ms_to_60ms_bandwidth_bps() const;
  void set_fl_20ms_to_60ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_20ms_to_60ms_bandwidth_bps() const;
  void _internal_set_fl_20ms_to_60ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_60ms_to_20ms_bandwidth_bps = 4;
  bool has_fl_60ms_to_20ms_bandwidth_bps() const;
  void clear_fl_60ms_to_20ms_bandwidth_bps() ;
  ::int32_t fl_60ms_to_20ms_bandwidth_bps() const;
  void set_fl_60ms_to_20ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_60ms_to_20ms_bandwidth_bps() const;
  void _internal_set_fl_60ms_to_20ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_60ms_to_120ms_bandwidth_bps = 5;
  bool has_fl_60ms_to_120ms_bandwidth_bps() const;
  void clear_fl_60ms_to_120ms_bandwidth_bps() ;
  ::int32_t fl_60ms_to_120ms_bandwidth_bps() const;
  void set_fl_60ms_to_120ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_60ms_to_120ms_bandwidth_bps() const;
  void _internal_set_fl_60ms_to_120ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_120ms_to_60ms_bandwidth_bps = 6;
  bool has_fl_120ms_to_60ms_bandwidth_bps() const;
  void clear_fl_120ms_to_60ms_bandwidth_bps() ;
  ::int32_t fl_120ms_to_60ms_bandwidth_bps() const;
  void set_fl_120ms_to_60ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_120ms_to_60ms_bandwidth_bps() const;
  void _internal_set_fl_120ms_to_60ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_increase_overhead_offset = 7;
  bool has_fl_increase_overhead_offset() const;
  void clear_fl_increase_overhead_offset() ;
  ::int32_t fl_increase_overhead_offset() const;
  void set_fl_increase_overhead_offset(::int32_t value);

  private:
  ::int32_t _internal_fl_increase_overhead_offset() const;
  void _internal_set_fl_increase_overhead_offset(::int32_t value);

  public:
  // optional int32 fl_decrease_overhead_offset = 8;
  bool has_fl_decrease_overhead_offset() const;
  void clear_fl_decrease_overhead_offset() ;
  ::int32_t fl_decrease_overhead_offset() const;
  void set_fl_decrease_overhead_offset(::int32_t value);

  private:
  ::int32_t _internal_fl_decrease_overhead_offset() const;
  void _internal_set_fl_decrease_overhead_offset(::int32_t value);

  public:
  // optional int32 fl_20ms_to_40ms_bandwidth_bps = 9;
  bool has_fl_20ms_to_40ms_bandwidth_bps() const;
  void clear_fl_20ms_to_40ms_bandwidth_bps() ;
  ::int32_t fl_20ms_to_40ms_bandwidth_bps() const;
  void set_fl_20ms_to_40ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_20ms_to_40ms_bandwidth_bps() const;
  void _internal_set_fl_20ms_to_40ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_40ms_to_20ms_bandwidth_bps = 10;
  bool has_fl_40ms_to_20ms_bandwidth_bps() const;
  void clear_fl_40ms_to_20ms_bandwidth_bps() ;
  ::int32_t fl_40ms_to_20ms_bandwidth_bps() const;
  void set_fl_40ms_to_20ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_40ms_to_20ms_bandwidth_bps() const;
  void _internal_set_fl_40ms_to_20ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_40ms_to_60ms_bandwidth_bps = 11;
  bool has_fl_40ms_to_60ms_bandwidth_bps() const;
  void clear_fl_40ms_to_60ms_bandwidth_bps() ;
  ::int32_t fl_40ms_to_60ms_bandwidth_bps() const;
  void set_fl_40ms_to_60ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_40ms_to_60ms_bandwidth_bps() const;
  void _internal_set_fl_40ms_to_60ms_bandwidth_bps(::int32_t value);

  public:
  // optional int32 fl_60ms_to_40ms_bandwidth_bps = 12;
  bool has_fl_60ms_to_40ms_bandwidth_bps() const;
  void clear_fl_60ms_to_40ms_bandwidth_bps() ;
  ::int32_t fl_60ms_to_40ms_bandwidth_bps() const;
  void set_fl_60ms_to_40ms_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_fl_60ms_to_40ms_bandwidth_bps() const;
  void _internal_set_fl_60ms_to_40ms_bandwidth_bps(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FrameLengthController)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float fl_increasing_packet_loss_fraction_;
    float fl_decreasing_packet_loss_fraction_;
    ::int32_t fl_20ms_to_60ms_bandwidth_bps_;
    ::int32_t fl_60ms_to_20ms_bandwidth_bps_;
    ::int32_t fl_60ms_to_120ms_bandwidth_bps_;
    ::int32_t fl_120ms_to_60ms_bandwidth_bps_;
    ::int32_t fl_increase_overhead_offset_;
    ::int32_t fl_decrease_overhead_offset_;
    ::int32_t fl_20ms_to_40ms_bandwidth_bps_;
    ::int32_t fl_40ms_to_20ms_bandwidth_bps_;
    ::int32_t fl_40ms_to_60ms_bandwidth_bps_;
    ::int32_t fl_60ms_to_40ms_bandwidth_bps_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};// -------------------------------------------------------------------

class FecControllerRplrBased_Threshold final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold) */ {
 public:
  inline FecControllerRplrBased_Threshold() : FecControllerRplrBased_Threshold(nullptr) {}
  ~FecControllerRplrBased_Threshold() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FecControllerRplrBased_Threshold(::google::protobuf::internal::ConstantInitialized);

  inline FecControllerRplrBased_Threshold(const FecControllerRplrBased_Threshold& from)
      : FecControllerRplrBased_Threshold(nullptr, from) {}
  FecControllerRplrBased_Threshold(FecControllerRplrBased_Threshold&& from) noexcept
    : FecControllerRplrBased_Threshold() {
    *this = ::std::move(from);
  }

  inline FecControllerRplrBased_Threshold& operator=(const FecControllerRplrBased_Threshold& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecControllerRplrBased_Threshold& operator=(FecControllerRplrBased_Threshold&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FecControllerRplrBased_Threshold& default_instance() {
    return *internal_default_instance();
  }
  static inline const FecControllerRplrBased_Threshold* internal_default_instance() {
    return reinterpret_cast<const FecControllerRplrBased_Threshold*>(
               &_FecControllerRplrBased_Threshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FecControllerRplrBased_Threshold& a, FecControllerRplrBased_Threshold& b) {
    a.Swap(&b);
  }
  inline void Swap(FecControllerRplrBased_Threshold* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FecControllerRplrBased_Threshold* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FecControllerRplrBased_Threshold* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FecControllerRplrBased_Threshold>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const FecControllerRplrBased_Threshold& from);
  void MergeFrom(const FecControllerRplrBased_Threshold& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FecControllerRplrBased_Threshold* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold";
  }
  protected:
  explicit FecControllerRplrBased_Threshold(::google::protobuf::Arena* arena);
  FecControllerRplrBased_Threshold(::google::protobuf::Arena* arena, const FecControllerRplrBased_Threshold& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowBandwidthBpsFieldNumber = 1,
    kLowBandwidthRecoverablePacketLossFieldNumber = 2,
    kHighBandwidthBpsFieldNumber = 3,
    kHighBandwidthRecoverablePacketLossFieldNumber = 4,
  };
  // optional int32 low_bandwidth_bps = 1;
  bool has_low_bandwidth_bps() const;
  void clear_low_bandwidth_bps() ;
  ::int32_t low_bandwidth_bps() const;
  void set_low_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_low_bandwidth_bps() const;
  void _internal_set_low_bandwidth_bps(::int32_t value);

  public:
  // optional float low_bandwidth_recoverable_packet_loss = 2;
  bool has_low_bandwidth_recoverable_packet_loss() const;
  void clear_low_bandwidth_recoverable_packet_loss() ;
  float low_bandwidth_recoverable_packet_loss() const;
  void set_low_bandwidth_recoverable_packet_loss(float value);

  private:
  float _internal_low_bandwidth_recoverable_packet_loss() const;
  void _internal_set_low_bandwidth_recoverable_packet_loss(float value);

  public:
  // optional int32 high_bandwidth_bps = 3;
  bool has_high_bandwidth_bps() const;
  void clear_high_bandwidth_bps() ;
  ::int32_t high_bandwidth_bps() const;
  void set_high_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_high_bandwidth_bps() const;
  void _internal_set_high_bandwidth_bps(::int32_t value);

  public:
  // optional float high_bandwidth_recoverable_packet_loss = 4;
  bool has_high_bandwidth_recoverable_packet_loss() const;
  void clear_high_bandwidth_recoverable_packet_loss() ;
  float high_bandwidth_recoverable_packet_loss() const;
  void set_high_bandwidth_recoverable_packet_loss(float value);

  private:
  float _internal_high_bandwidth_recoverable_packet_loss() const;
  void _internal_set_high_bandwidth_recoverable_packet_loss(float value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t low_bandwidth_bps_;
    float low_bandwidth_recoverable_packet_loss_;
    ::int32_t high_bandwidth_bps_;
    float high_bandwidth_recoverable_packet_loss_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};// -------------------------------------------------------------------

class FecController_Threshold final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecController.Threshold) */ {
 public:
  inline FecController_Threshold() : FecController_Threshold(nullptr) {}
  ~FecController_Threshold() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FecController_Threshold(::google::protobuf::internal::ConstantInitialized);

  inline FecController_Threshold(const FecController_Threshold& from)
      : FecController_Threshold(nullptr, from) {}
  FecController_Threshold(FecController_Threshold&& from) noexcept
    : FecController_Threshold() {
    *this = ::std::move(from);
  }

  inline FecController_Threshold& operator=(const FecController_Threshold& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecController_Threshold& operator=(FecController_Threshold&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FecController_Threshold& default_instance() {
    return *internal_default_instance();
  }
  static inline const FecController_Threshold* internal_default_instance() {
    return reinterpret_cast<const FecController_Threshold*>(
               &_FecController_Threshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FecController_Threshold& a, FecController_Threshold& b) {
    a.Swap(&b);
  }
  inline void Swap(FecController_Threshold* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FecController_Threshold* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FecController_Threshold* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FecController_Threshold>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const FecController_Threshold& from);
  void MergeFrom(const FecController_Threshold& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FecController_Threshold* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.FecController.Threshold";
  }
  protected:
  explicit FecController_Threshold(::google::protobuf::Arena* arena);
  FecController_Threshold(::google::protobuf::Arena* arena, const FecController_Threshold& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowBandwidthBpsFieldNumber = 1,
    kLowBandwidthPacketLossFieldNumber = 2,
    kHighBandwidthBpsFieldNumber = 3,
    kHighBandwidthPacketLossFieldNumber = 4,
  };
  // optional int32 low_bandwidth_bps = 1;
  bool has_low_bandwidth_bps() const;
  void clear_low_bandwidth_bps() ;
  ::int32_t low_bandwidth_bps() const;
  void set_low_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_low_bandwidth_bps() const;
  void _internal_set_low_bandwidth_bps(::int32_t value);

  public:
  // optional float low_bandwidth_packet_loss = 2;
  bool has_low_bandwidth_packet_loss() const;
  void clear_low_bandwidth_packet_loss() ;
  float low_bandwidth_packet_loss() const;
  void set_low_bandwidth_packet_loss(float value);

  private:
  float _internal_low_bandwidth_packet_loss() const;
  void _internal_set_low_bandwidth_packet_loss(float value);

  public:
  // optional int32 high_bandwidth_bps = 3;
  bool has_high_bandwidth_bps() const;
  void clear_high_bandwidth_bps() ;
  ::int32_t high_bandwidth_bps() const;
  void set_high_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_high_bandwidth_bps() const;
  void _internal_set_high_bandwidth_bps(::int32_t value);

  public:
  // optional float high_bandwidth_packet_loss = 4;
  bool has_high_bandwidth_packet_loss() const;
  void clear_high_bandwidth_packet_loss() ;
  float high_bandwidth_packet_loss() const;
  void set_high_bandwidth_packet_loss(float value);

  private:
  float _internal_high_bandwidth_packet_loss() const;
  void _internal_set_high_bandwidth_packet_loss(float value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecController.Threshold)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t low_bandwidth_bps_;
    float low_bandwidth_packet_loss_;
    ::int32_t high_bandwidth_bps_;
    float high_bandwidth_packet_loss_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};// -------------------------------------------------------------------

class DtxController final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.DtxController) */ {
 public:
  inline DtxController() : DtxController(nullptr) {}
  ~DtxController() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DtxController(::google::protobuf::internal::ConstantInitialized);

  inline DtxController(const DtxController& from)
      : DtxController(nullptr, from) {}
  DtxController(DtxController&& from) noexcept
    : DtxController() {
    *this = ::std::move(from);
  }

  inline DtxController& operator=(const DtxController& from) {
    CopyFrom(from);
    return *this;
  }
  inline DtxController& operator=(DtxController&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DtxController& default_instance() {
    return *internal_default_instance();
  }
  static inline const DtxController* internal_default_instance() {
    return reinterpret_cast<const DtxController*>(
               &_DtxController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DtxController& a, DtxController& b) {
    a.Swap(&b);
  }
  inline void Swap(DtxController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DtxController* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DtxController* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DtxController>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const DtxController& from);
  void MergeFrom(const DtxController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DtxController* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.DtxController";
  }
  protected:
  explicit DtxController(::google::protobuf::Arena* arena);
  DtxController(::google::protobuf::Arena* arena, const DtxController& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDtxEnablingBandwidthBpsFieldNumber = 1,
    kDtxDisablingBandwidthBpsFieldNumber = 2,
  };
  // optional int32 dtx_enabling_bandwidth_bps = 1;
  bool has_dtx_enabling_bandwidth_bps() const;
  void clear_dtx_enabling_bandwidth_bps() ;
  ::int32_t dtx_enabling_bandwidth_bps() const;
  void set_dtx_enabling_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_dtx_enabling_bandwidth_bps() const;
  void _internal_set_dtx_enabling_bandwidth_bps(::int32_t value);

  public:
  // optional int32 dtx_disabling_bandwidth_bps = 2;
  bool has_dtx_disabling_bandwidth_bps() const;
  void clear_dtx_disabling_bandwidth_bps() ;
  ::int32_t dtx_disabling_bandwidth_bps() const;
  void set_dtx_disabling_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_dtx_disabling_bandwidth_bps() const;
  void _internal_set_dtx_disabling_bandwidth_bps(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.DtxController)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t dtx_enabling_bandwidth_bps_;
    ::int32_t dtx_disabling_bandwidth_bps_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};// -------------------------------------------------------------------

class Controller_ScoringPoint final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.Controller.ScoringPoint) */ {
 public:
  inline Controller_ScoringPoint() : Controller_ScoringPoint(nullptr) {}
  ~Controller_ScoringPoint() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Controller_ScoringPoint(::google::protobuf::internal::ConstantInitialized);

  inline Controller_ScoringPoint(const Controller_ScoringPoint& from)
      : Controller_ScoringPoint(nullptr, from) {}
  Controller_ScoringPoint(Controller_ScoringPoint&& from) noexcept
    : Controller_ScoringPoint() {
    *this = ::std::move(from);
  }

  inline Controller_ScoringPoint& operator=(const Controller_ScoringPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Controller_ScoringPoint& operator=(Controller_ScoringPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Controller_ScoringPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const Controller_ScoringPoint* internal_default_instance() {
    return reinterpret_cast<const Controller_ScoringPoint*>(
               &_Controller_ScoringPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Controller_ScoringPoint& a, Controller_ScoringPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Controller_ScoringPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Controller_ScoringPoint* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Controller_ScoringPoint* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Controller_ScoringPoint>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Controller_ScoringPoint& from);
  void MergeFrom(const Controller_ScoringPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Controller_ScoringPoint* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.Controller.ScoringPoint";
  }
  protected:
  explicit Controller_ScoringPoint(::google::protobuf::Arena* arena);
  Controller_ScoringPoint(::google::protobuf::Arena* arena, const Controller_ScoringPoint& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUplinkBandwidthBpsFieldNumber = 1,
    kUplinkPacketLossFractionFieldNumber = 2,
  };
  // optional int32 uplink_bandwidth_bps = 1;
  bool has_uplink_bandwidth_bps() const;
  void clear_uplink_bandwidth_bps() ;
  ::int32_t uplink_bandwidth_bps() const;
  void set_uplink_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_uplink_bandwidth_bps() const;
  void _internal_set_uplink_bandwidth_bps(::int32_t value);

  public:
  // optional float uplink_packet_loss_fraction = 2;
  bool has_uplink_packet_loss_fraction() const;
  void clear_uplink_packet_loss_fraction() ;
  float uplink_packet_loss_fraction() const;
  void set_uplink_packet_loss_fraction(float value);

  private:
  float _internal_uplink_packet_loss_fraction() const;
  void _internal_set_uplink_packet_loss_fraction(float value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.Controller.ScoringPoint)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t uplink_bandwidth_bps_;
    float uplink_packet_loss_fraction_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};// -------------------------------------------------------------------

class ChannelController final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.ChannelController) */ {
 public:
  inline ChannelController() : ChannelController(nullptr) {}
  ~ChannelController() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelController(::google::protobuf::internal::ConstantInitialized);

  inline ChannelController(const ChannelController& from)
      : ChannelController(nullptr, from) {}
  ChannelController(ChannelController&& from) noexcept
    : ChannelController() {
    *this = ::std::move(from);
  }

  inline ChannelController& operator=(const ChannelController& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelController& operator=(ChannelController&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChannelController& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelController* internal_default_instance() {
    return reinterpret_cast<const ChannelController*>(
               &_ChannelController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ChannelController& a, ChannelController& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelController* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelController* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelController>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const ChannelController& from);
  void MergeFrom(const ChannelController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelController* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.ChannelController";
  }
  protected:
  explicit ChannelController(::google::protobuf::Arena* arena);
  ChannelController(::google::protobuf::Arena* arena, const ChannelController& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannel1To2BandwidthBpsFieldNumber = 1,
    kChannel2To1BandwidthBpsFieldNumber = 2,
  };
  // optional int32 channel_1_to_2_bandwidth_bps = 1;
  bool has_channel_1_to_2_bandwidth_bps() const;
  void clear_channel_1_to_2_bandwidth_bps() ;
  ::int32_t channel_1_to_2_bandwidth_bps() const;
  void set_channel_1_to_2_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_channel_1_to_2_bandwidth_bps() const;
  void _internal_set_channel_1_to_2_bandwidth_bps(::int32_t value);

  public:
  // optional int32 channel_2_to_1_bandwidth_bps = 2;
  bool has_channel_2_to_1_bandwidth_bps() const;
  void clear_channel_2_to_1_bandwidth_bps() ;
  ::int32_t channel_2_to_1_bandwidth_bps() const;
  void set_channel_2_to_1_bandwidth_bps(::int32_t value);

  private:
  ::int32_t _internal_channel_2_to_1_bandwidth_bps() const;
  void _internal_set_channel_2_to_1_bandwidth_bps(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.ChannelController)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t channel_1_to_2_bandwidth_bps_;
    ::int32_t channel_2_to_1_bandwidth_bps_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};// -------------------------------------------------------------------

class BitrateController final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.BitrateController) */ {
 public:
  inline BitrateController() : BitrateController(nullptr) {}
  ~BitrateController() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BitrateController(::google::protobuf::internal::ConstantInitialized);

  inline BitrateController(const BitrateController& from)
      : BitrateController(nullptr, from) {}
  BitrateController(BitrateController&& from) noexcept
    : BitrateController() {
    *this = ::std::move(from);
  }

  inline BitrateController& operator=(const BitrateController& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitrateController& operator=(BitrateController&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BitrateController& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitrateController* internal_default_instance() {
    return reinterpret_cast<const BitrateController*>(
               &_BitrateController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BitrateController& a, BitrateController& b) {
    a.Swap(&b);
  }
  inline void Swap(BitrateController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitrateController* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitrateController* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitrateController>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const BitrateController& from);
  void MergeFrom(const BitrateController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BitrateController* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.BitrateController";
  }
  protected:
  explicit BitrateController(::google::protobuf::Arena* arena);
  BitrateController(::google::protobuf::Arena* arena, const BitrateController& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlIncreaseOverheadOffsetFieldNumber = 1,
    kFlDecreaseOverheadOffsetFieldNumber = 2,
  };
  // optional int32 fl_increase_overhead_offset = 1;
  bool has_fl_increase_overhead_offset() const;
  void clear_fl_increase_overhead_offset() ;
  ::int32_t fl_increase_overhead_offset() const;
  void set_fl_increase_overhead_offset(::int32_t value);

  private:
  ::int32_t _internal_fl_increase_overhead_offset() const;
  void _internal_set_fl_increase_overhead_offset(::int32_t value);

  public:
  // optional int32 fl_decrease_overhead_offset = 2;
  bool has_fl_decrease_overhead_offset() const;
  void clear_fl_decrease_overhead_offset() ;
  ::int32_t fl_decrease_overhead_offset() const;
  void set_fl_decrease_overhead_offset(::int32_t value);

  private:
  ::int32_t _internal_fl_decrease_overhead_offset() const;
  void _internal_set_fl_decrease_overhead_offset(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.BitrateController)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t fl_increase_overhead_offset_;
    ::int32_t fl_decrease_overhead_offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};// -------------------------------------------------------------------

class FecControllerRplrBased final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecControllerRplrBased) */ {
 public:
  inline FecControllerRplrBased() : FecControllerRplrBased(nullptr) {}
  ~FecControllerRplrBased() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FecControllerRplrBased(::google::protobuf::internal::ConstantInitialized);

  inline FecControllerRplrBased(const FecControllerRplrBased& from)
      : FecControllerRplrBased(nullptr, from) {}
  FecControllerRplrBased(FecControllerRplrBased&& from) noexcept
    : FecControllerRplrBased() {
    *this = ::std::move(from);
  }

  inline FecControllerRplrBased& operator=(const FecControllerRplrBased& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecControllerRplrBased& operator=(FecControllerRplrBased&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FecControllerRplrBased& default_instance() {
    return *internal_default_instance();
  }
  static inline const FecControllerRplrBased* internal_default_instance() {
    return reinterpret_cast<const FecControllerRplrBased*>(
               &_FecControllerRplrBased_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FecControllerRplrBased& a, FecControllerRplrBased& b) {
    a.Swap(&b);
  }
  inline void Swap(FecControllerRplrBased* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FecControllerRplrBased* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FecControllerRplrBased* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FecControllerRplrBased>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const FecControllerRplrBased& from);
  void MergeFrom(const FecControllerRplrBased& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FecControllerRplrBased* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.FecControllerRplrBased";
  }
  protected:
  explicit FecControllerRplrBased(::google::protobuf::Arena* arena);
  FecControllerRplrBased(::google::protobuf::Arena* arena, const FecControllerRplrBased& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Threshold = FecControllerRplrBased_Threshold;

  // accessors -------------------------------------------------------

  enum : int {
    kFecEnablingThresholdFieldNumber = 1,
    kFecDisablingThresholdFieldNumber = 2,
  };
  // optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_enabling_threshold = 1;
  bool has_fec_enabling_threshold() const;
  void clear_fec_enabling_threshold() ;
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& fec_enabling_threshold() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* release_fec_enabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* mutable_fec_enabling_threshold();
  void set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* value);
  void unsafe_arena_set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* value);
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* unsafe_arena_release_fec_enabling_threshold();

  private:
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& _internal_fec_enabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* _internal_mutable_fec_enabling_threshold();

  public:
  // optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_disabling_threshold = 2;
  bool has_fec_disabling_threshold() const;
  void clear_fec_disabling_threshold() ;
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& fec_disabling_threshold() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* release_fec_disabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* mutable_fec_disabling_threshold();
  void set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* value);
  void unsafe_arena_set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* value);
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* unsafe_arena_release_fec_disabling_threshold();

  private:
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& _internal_fec_disabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* _internal_mutable_fec_disabling_threshold();

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecControllerRplrBased)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* fec_enabling_threshold_;
    ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* fec_disabling_threshold_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};// -------------------------------------------------------------------

class FecController final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.FecController) */ {
 public:
  inline FecController() : FecController(nullptr) {}
  ~FecController() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FecController(::google::protobuf::internal::ConstantInitialized);

  inline FecController(const FecController& from)
      : FecController(nullptr, from) {}
  FecController(FecController&& from) noexcept
    : FecController() {
    *this = ::std::move(from);
  }

  inline FecController& operator=(const FecController& from) {
    CopyFrom(from);
    return *this;
  }
  inline FecController& operator=(FecController&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FecController& default_instance() {
    return *internal_default_instance();
  }
  static inline const FecController* internal_default_instance() {
    return reinterpret_cast<const FecController*>(
               &_FecController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FecController& a, FecController& b) {
    a.Swap(&b);
  }
  inline void Swap(FecController* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FecController* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FecController* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FecController>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const FecController& from);
  void MergeFrom(const FecController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FecController* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.FecController";
  }
  protected:
  explicit FecController(::google::protobuf::Arena* arena);
  FecController(::google::protobuf::Arena* arena, const FecController& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using Threshold = FecController_Threshold;

  // accessors -------------------------------------------------------

  enum : int {
    kFecEnablingThresholdFieldNumber = 1,
    kFecDisablingThresholdFieldNumber = 2,
    kTimeConstantMsFieldNumber = 3,
  };
  // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_enabling_threshold = 1;
  bool has_fec_enabling_threshold() const;
  void clear_fec_enabling_threshold() ;
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold& fec_enabling_threshold() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::FecController_Threshold* release_fec_enabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* mutable_fec_enabling_threshold();
  void set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* value);
  void unsafe_arena_set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* value);
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* unsafe_arena_release_fec_enabling_threshold();

  private:
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold& _internal_fec_enabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* _internal_mutable_fec_enabling_threshold();

  public:
  // optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_disabling_threshold = 2;
  bool has_fec_disabling_threshold() const;
  void clear_fec_disabling_threshold() ;
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold& fec_disabling_threshold() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::FecController_Threshold* release_fec_disabling_threshold();
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* mutable_fec_disabling_threshold();
  void set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* value);
  void unsafe_arena_set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* value);
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* unsafe_arena_release_fec_disabling_threshold();

  private:
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold& _internal_fec_disabling_threshold() const;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* _internal_mutable_fec_disabling_threshold();

  public:
  // optional int32 time_constant_ms = 3;
  bool has_time_constant_ms() const;
  void clear_time_constant_ms() ;
  ::int32_t time_constant_ms() const;
  void set_time_constant_ms(::int32_t value);

  private:
  ::int32_t _internal_time_constant_ms() const;
  void _internal_set_time_constant_ms(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.FecController)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::webrtc::audio_network_adaptor::config::FecController_Threshold* fec_enabling_threshold_;
    ::webrtc::audio_network_adaptor::config::FecController_Threshold* fec_disabling_threshold_;
    ::int32_t time_constant_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};// -------------------------------------------------------------------

class Controller final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.Controller) */ {
 public:
  inline Controller() : Controller(nullptr) {}
  ~Controller() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Controller(::google::protobuf::internal::ConstantInitialized);

  inline Controller(const Controller& from)
      : Controller(nullptr, from) {}
  Controller(Controller&& from) noexcept
    : Controller() {
    *this = ::std::move(from);
  }

  inline Controller& operator=(const Controller& from) {
    CopyFrom(from);
    return *this;
  }
  inline Controller& operator=(Controller&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Controller& default_instance() {
    return *internal_default_instance();
  }
  enum ControllerCase {
    kFecController = 21,
    kFrameLengthController = 22,
    kChannelController = 23,
    kDtxController = 24,
    kBitrateController = 25,
    kFecControllerRplrBased = 26,
    kFrameLengthControllerV2 = 27,
    CONTROLLER_NOT_SET = 0,
  };

  static inline const Controller* internal_default_instance() {
    return reinterpret_cast<const Controller*>(
               &_Controller_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Controller& a, Controller& b) {
    a.Swap(&b);
  }
  inline void Swap(Controller* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Controller* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Controller* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Controller>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const Controller& from);
  void MergeFrom(const Controller& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Controller* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.Controller";
  }
  protected:
  explicit Controller(::google::protobuf::Arena* arena);
  Controller(::google::protobuf::Arena* arena, const Controller& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  using ScoringPoint = Controller_ScoringPoint;

  // accessors -------------------------------------------------------

  enum : int {
    kScoringPointFieldNumber = 1,
    kFecControllerFieldNumber = 21,
    kFrameLengthControllerFieldNumber = 22,
    kChannelControllerFieldNumber = 23,
    kDtxControllerFieldNumber = 24,
    kBitrateControllerFieldNumber = 25,
    kFecControllerRplrBasedFieldNumber = 26,
    kFrameLengthControllerV2FieldNumber = 27,
  };
  // optional .webrtc.audio_network_adaptor.config.Controller.ScoringPoint scoring_point = 1;
  bool has_scoring_point() const;
  void clear_scoring_point() ;
  const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint& scoring_point() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* release_scoring_point();
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* mutable_scoring_point();
  void set_allocated_scoring_point(::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* value);
  void unsafe_arena_set_allocated_scoring_point(::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* value);
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* unsafe_arena_release_scoring_point();

  private:
  const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint& _internal_scoring_point() const;
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* _internal_mutable_scoring_point();

  public:
  // .webrtc.audio_network_adaptor.config.FecController fec_controller = 21;
  bool has_fec_controller() const;
  private:
  bool _internal_has_fec_controller() const;

  public:
  void clear_fec_controller() ;
  const ::webrtc::audio_network_adaptor::config::FecController& fec_controller() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::FecController* release_fec_controller();
  ::webrtc::audio_network_adaptor::config::FecController* mutable_fec_controller();
  void set_allocated_fec_controller(::webrtc::audio_network_adaptor::config::FecController* value);
  void unsafe_arena_set_allocated_fec_controller(::webrtc::audio_network_adaptor::config::FecController* value);
  ::webrtc::audio_network_adaptor::config::FecController* unsafe_arena_release_fec_controller();

  private:
  const ::webrtc::audio_network_adaptor::config::FecController& _internal_fec_controller() const;
  ::webrtc::audio_network_adaptor::config::FecController* _internal_mutable_fec_controller();

  public:
  // .webrtc.audio_network_adaptor.config.FrameLengthController frame_length_controller = 22;
  bool has_frame_length_controller() const;
  private:
  bool _internal_has_frame_length_controller() const;

  public:
  void clear_frame_length_controller() ;
  const ::webrtc::audio_network_adaptor::config::FrameLengthController& frame_length_controller() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::FrameLengthController* release_frame_length_controller();
  ::webrtc::audio_network_adaptor::config::FrameLengthController* mutable_frame_length_controller();
  void set_allocated_frame_length_controller(::webrtc::audio_network_adaptor::config::FrameLengthController* value);
  void unsafe_arena_set_allocated_frame_length_controller(::webrtc::audio_network_adaptor::config::FrameLengthController* value);
  ::webrtc::audio_network_adaptor::config::FrameLengthController* unsafe_arena_release_frame_length_controller();

  private:
  const ::webrtc::audio_network_adaptor::config::FrameLengthController& _internal_frame_length_controller() const;
  ::webrtc::audio_network_adaptor::config::FrameLengthController* _internal_mutable_frame_length_controller();

  public:
  // .webrtc.audio_network_adaptor.config.ChannelController channel_controller = 23;
  bool has_channel_controller() const;
  private:
  bool _internal_has_channel_controller() const;

  public:
  void clear_channel_controller() ;
  const ::webrtc::audio_network_adaptor::config::ChannelController& channel_controller() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::ChannelController* release_channel_controller();
  ::webrtc::audio_network_adaptor::config::ChannelController* mutable_channel_controller();
  void set_allocated_channel_controller(::webrtc::audio_network_adaptor::config::ChannelController* value);
  void unsafe_arena_set_allocated_channel_controller(::webrtc::audio_network_adaptor::config::ChannelController* value);
  ::webrtc::audio_network_adaptor::config::ChannelController* unsafe_arena_release_channel_controller();

  private:
  const ::webrtc::audio_network_adaptor::config::ChannelController& _internal_channel_controller() const;
  ::webrtc::audio_network_adaptor::config::ChannelController* _internal_mutable_channel_controller();

  public:
  // .webrtc.audio_network_adaptor.config.DtxController dtx_controller = 24;
  bool has_dtx_controller() const;
  private:
  bool _internal_has_dtx_controller() const;

  public:
  void clear_dtx_controller() ;
  const ::webrtc::audio_network_adaptor::config::DtxController& dtx_controller() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::DtxController* release_dtx_controller();
  ::webrtc::audio_network_adaptor::config::DtxController* mutable_dtx_controller();
  void set_allocated_dtx_controller(::webrtc::audio_network_adaptor::config::DtxController* value);
  void unsafe_arena_set_allocated_dtx_controller(::webrtc::audio_network_adaptor::config::DtxController* value);
  ::webrtc::audio_network_adaptor::config::DtxController* unsafe_arena_release_dtx_controller();

  private:
  const ::webrtc::audio_network_adaptor::config::DtxController& _internal_dtx_controller() const;
  ::webrtc::audio_network_adaptor::config::DtxController* _internal_mutable_dtx_controller();

  public:
  // .webrtc.audio_network_adaptor.config.BitrateController bitrate_controller = 25;
  bool has_bitrate_controller() const;
  private:
  bool _internal_has_bitrate_controller() const;

  public:
  void clear_bitrate_controller() ;
  const ::webrtc::audio_network_adaptor::config::BitrateController& bitrate_controller() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::BitrateController* release_bitrate_controller();
  ::webrtc::audio_network_adaptor::config::BitrateController* mutable_bitrate_controller();
  void set_allocated_bitrate_controller(::webrtc::audio_network_adaptor::config::BitrateController* value);
  void unsafe_arena_set_allocated_bitrate_controller(::webrtc::audio_network_adaptor::config::BitrateController* value);
  ::webrtc::audio_network_adaptor::config::BitrateController* unsafe_arena_release_bitrate_controller();

  private:
  const ::webrtc::audio_network_adaptor::config::BitrateController& _internal_bitrate_controller() const;
  ::webrtc::audio_network_adaptor::config::BitrateController* _internal_mutable_bitrate_controller();

  public:
  // .webrtc.audio_network_adaptor.config.FecControllerRplrBased fec_controller_rplr_based = 26;
  bool has_fec_controller_rplr_based() const;
  private:
  bool _internal_has_fec_controller_rplr_based() const;

  public:
  void clear_fec_controller_rplr_based() ;
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased& fec_controller_rplr_based() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* release_fec_controller_rplr_based();
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* mutable_fec_controller_rplr_based();
  void set_allocated_fec_controller_rplr_based(::webrtc::audio_network_adaptor::config::FecControllerRplrBased* value);
  void unsafe_arena_set_allocated_fec_controller_rplr_based(::webrtc::audio_network_adaptor::config::FecControllerRplrBased* value);
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* unsafe_arena_release_fec_controller_rplr_based();

  private:
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased& _internal_fec_controller_rplr_based() const;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* _internal_mutable_fec_controller_rplr_based();

  public:
  // .webrtc.audio_network_adaptor.config.FrameLengthControllerV2 frame_length_controller_v2 = 27;
  bool has_frame_length_controller_v2() const;
  private:
  bool _internal_has_frame_length_controller_v2() const;

  public:
  void clear_frame_length_controller_v2() ;
  const ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2& frame_length_controller_v2() const;
  PROTOBUF_NODISCARD ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* release_frame_length_controller_v2();
  ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* mutable_frame_length_controller_v2();
  void set_allocated_frame_length_controller_v2(::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* value);
  void unsafe_arena_set_allocated_frame_length_controller_v2(::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* value);
  ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* unsafe_arena_release_frame_length_controller_v2();

  private:
  const ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2& _internal_frame_length_controller_v2() const;
  ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* _internal_mutable_frame_length_controller_v2();

  public:
  void clear_controller();
  ControllerCase controller_case() const;
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.Controller)
 private:
  class _Internal;
  void set_has_fec_controller();
  void set_has_frame_length_controller();
  void set_has_channel_controller();
  void set_has_dtx_controller();
  void set_has_bitrate_controller();
  void set_has_fec_controller_rplr_based();
  void set_has_frame_length_controller_v2();

  inline bool has_controller() const;
  inline void clear_has_controller();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 8, 8,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* scoring_point_;
    union ControllerUnion {
      constexpr ControllerUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::webrtc::audio_network_adaptor::config::FecController* fec_controller_;
      ::webrtc::audio_network_adaptor::config::FrameLengthController* frame_length_controller_;
      ::webrtc::audio_network_adaptor::config::ChannelController* channel_controller_;
      ::webrtc::audio_network_adaptor::config::DtxController* dtx_controller_;
      ::webrtc::audio_network_adaptor::config::BitrateController* bitrate_controller_;
      ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* fec_controller_rplr_based_;
      ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* frame_length_controller_v2_;
    } controller_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};// -------------------------------------------------------------------

class ControllerManager final :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:webrtc.audio_network_adaptor.config.ControllerManager) */ {
 public:
  inline ControllerManager() : ControllerManager(nullptr) {}
  ~ControllerManager() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerManager(::google::protobuf::internal::ConstantInitialized);

  inline ControllerManager(const ControllerManager& from)
      : ControllerManager(nullptr, from) {}
  ControllerManager(ControllerManager&& from) noexcept
    : ControllerManager() {
    *this = ::std::move(from);
  }

  inline ControllerManager& operator=(const ControllerManager& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerManager& operator=(ControllerManager&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ControllerManager& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerManager* internal_default_instance() {
    return reinterpret_cast<const ControllerManager*>(
               &_ControllerManager_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ControllerManager& a, ControllerManager& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerManager* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerManager* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerManager* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerManager>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)  final;
  void CopyFrom(const ControllerManager& from);
  void MergeFrom(const ControllerManager& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerManager* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "webrtc.audio_network_adaptor.config.ControllerManager";
  }
  protected:
  explicit ControllerManager(::google::protobuf::Arena* arena);
  ControllerManager(::google::protobuf::Arena* arena, const ControllerManager& from);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllersFieldNumber = 1,
    kMinReorderingTimeMsFieldNumber = 2,
    kMinReorderingSquaredDistanceFieldNumber = 3,
  };
  // repeated .webrtc.audio_network_adaptor.config.Controller controllers = 1;
  int controllers_size() const;
  private:
  int _internal_controllers_size() const;

  public:
  void clear_controllers() ;
  ::webrtc::audio_network_adaptor::config::Controller* mutable_controllers(int index);
  ::google::protobuf::RepeatedPtrField< ::webrtc::audio_network_adaptor::config::Controller >*
      mutable_controllers();
  private:
  const ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>& _internal_controllers() const;
  ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>* _internal_mutable_controllers();
  public:
  const ::webrtc::audio_network_adaptor::config::Controller& controllers(int index) const;
  ::webrtc::audio_network_adaptor::config::Controller* add_controllers();
  const ::google::protobuf::RepeatedPtrField< ::webrtc::audio_network_adaptor::config::Controller >&
      controllers() const;
  // optional int32 min_reordering_time_ms = 2;
  bool has_min_reordering_time_ms() const;
  void clear_min_reordering_time_ms() ;
  ::int32_t min_reordering_time_ms() const;
  void set_min_reordering_time_ms(::int32_t value);

  private:
  ::int32_t _internal_min_reordering_time_ms() const;
  void _internal_set_min_reordering_time_ms(::int32_t value);

  public:
  // optional float min_reordering_squared_distance = 3;
  bool has_min_reordering_squared_distance() const;
  void clear_min_reordering_squared_distance() ;
  float min_reordering_squared_distance() const;
  void set_min_reordering_squared_distance(float value);

  private:
  float _internal_min_reordering_squared_distance() const;
  void _internal_set_min_reordering_squared_distance(float value);

  public:
  // @@protoc_insertion_point(class_scope:webrtc.audio_network_adaptor.config.ControllerManager)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::webrtc::audio_network_adaptor::config::Controller > controllers_;
    ::int32_t min_reordering_time_ms_;
    float min_reordering_squared_distance_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_config_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FecController_Threshold

// optional int32 low_bandwidth_bps = 1;
inline bool FecController_Threshold::has_low_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FecController_Threshold::clear_low_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.low_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t FecController_Threshold::low_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_bps)
  return _internal_low_bandwidth_bps();
}
inline void FecController_Threshold::set_low_bandwidth_bps(::int32_t value) {
  _internal_set_low_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_bps)
}
inline ::int32_t FecController_Threshold::_internal_low_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.low_bandwidth_bps_;
}
inline void FecController_Threshold::_internal_set_low_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.low_bandwidth_bps_ = value;
}

// optional float low_bandwidth_packet_loss = 2;
inline bool FecController_Threshold::has_low_bandwidth_packet_loss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FecController_Threshold::clear_low_bandwidth_packet_loss() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.low_bandwidth_packet_loss_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float FecController_Threshold::low_bandwidth_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_packet_loss)
  return _internal_low_bandwidth_packet_loss();
}
inline void FecController_Threshold::set_low_bandwidth_packet_loss(float value) {
  _internal_set_low_bandwidth_packet_loss(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.low_bandwidth_packet_loss)
}
inline float FecController_Threshold::_internal_low_bandwidth_packet_loss() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.low_bandwidth_packet_loss_;
}
inline void FecController_Threshold::_internal_set_low_bandwidth_packet_loss(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.low_bandwidth_packet_loss_ = value;
}

// optional int32 high_bandwidth_bps = 3;
inline bool FecController_Threshold::has_high_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FecController_Threshold::clear_high_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.high_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t FecController_Threshold::high_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_bps)
  return _internal_high_bandwidth_bps();
}
inline void FecController_Threshold::set_high_bandwidth_bps(::int32_t value) {
  _internal_set_high_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_bps)
}
inline ::int32_t FecController_Threshold::_internal_high_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.high_bandwidth_bps_;
}
inline void FecController_Threshold::_internal_set_high_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.high_bandwidth_bps_ = value;
}

// optional float high_bandwidth_packet_loss = 4;
inline bool FecController_Threshold::has_high_bandwidth_packet_loss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FecController_Threshold::clear_high_bandwidth_packet_loss() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.high_bandwidth_packet_loss_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float FecController_Threshold::high_bandwidth_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_packet_loss)
  return _internal_high_bandwidth_packet_loss();
}
inline void FecController_Threshold::set_high_bandwidth_packet_loss(float value) {
  _internal_set_high_bandwidth_packet_loss(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.Threshold.high_bandwidth_packet_loss)
}
inline float FecController_Threshold::_internal_high_bandwidth_packet_loss() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.high_bandwidth_packet_loss_;
}
inline void FecController_Threshold::_internal_set_high_bandwidth_packet_loss(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.high_bandwidth_packet_loss_ = value;
}

// -------------------------------------------------------------------

// FecController

// optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_enabling_threshold = 1;
inline bool FecController::has_fec_enabling_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fec_enabling_threshold_ != nullptr);
  return value;
}
inline void FecController::clear_fec_enabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.fec_enabling_threshold_ != nullptr) _impl_.fec_enabling_threshold_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::_internal_fec_enabling_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold* p = _impl_.fec_enabling_threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecController_Threshold&>(::webrtc::audio_network_adaptor::config::_FecController_Threshold_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::fec_enabling_threshold() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
  return _internal_fec_enabling_threshold();
}
inline void FecController::unsafe_arena_set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_enabling_threshold_);
  }
  _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::release_fec_enabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* released = _impl_.fec_enabling_threshold_;
  _impl_.fec_enabling_threshold_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::unsafe_arena_release_fec_enabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* temp = _impl_.fec_enabling_threshold_;
  _impl_.fec_enabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::_internal_mutable_fec_enabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fec_enabling_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecController_Threshold>(GetArena());
    _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(p);
  }
  return _impl_.fec_enabling_threshold_;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::mutable_fec_enabling_threshold() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* _msg = _internal_mutable_fec_enabling_threshold();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
  return _msg;
}
inline void FecController::set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(_impl_.fec_enabling_threshold_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_enabling_threshold)
}

// optional .webrtc.audio_network_adaptor.config.FecController.Threshold fec_disabling_threshold = 2;
inline bool FecController::has_fec_disabling_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fec_disabling_threshold_ != nullptr);
  return value;
}
inline void FecController::clear_fec_disabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.fec_disabling_threshold_ != nullptr) _impl_.fec_disabling_threshold_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::_internal_fec_disabling_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::webrtc::audio_network_adaptor::config::FecController_Threshold* p = _impl_.fec_disabling_threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecController_Threshold&>(::webrtc::audio_network_adaptor::config::_FecController_Threshold_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecController_Threshold& FecController::fec_disabling_threshold() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
  return _internal_fec_disabling_threshold();
}
inline void FecController::unsafe_arena_set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_disabling_threshold_);
  }
  _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::release_fec_disabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* released = _impl_.fec_disabling_threshold_;
  _impl_.fec_disabling_threshold_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::unsafe_arena_release_fec_disabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* temp = _impl_.fec_disabling_threshold_;
  _impl_.fec_disabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::_internal_mutable_fec_disabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.fec_disabling_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecController_Threshold>(GetArena());
    _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(p);
  }
  return _impl_.fec_disabling_threshold_;
}
inline ::webrtc::audio_network_adaptor::config::FecController_Threshold* FecController::mutable_fec_disabling_threshold() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FecController_Threshold* _msg = _internal_mutable_fec_disabling_threshold();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
  return _msg;
}
inline void FecController::set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecController_Threshold* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(_impl_.fec_disabling_threshold_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController_Threshold*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecController.fec_disabling_threshold)
}

// optional int32 time_constant_ms = 3;
inline bool FecController::has_time_constant_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FecController::clear_time_constant_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_constant_ms_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t FecController::time_constant_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecController.time_constant_ms)
  return _internal_time_constant_ms();
}
inline void FecController::set_time_constant_ms(::int32_t value) {
  _internal_set_time_constant_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecController.time_constant_ms)
}
inline ::int32_t FecController::_internal_time_constant_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_constant_ms_;
}
inline void FecController::_internal_set_time_constant_ms(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.time_constant_ms_ = value;
}

// -------------------------------------------------------------------

// FecControllerRplrBased_Threshold

// optional int32 low_bandwidth_bps = 1;
inline bool FecControllerRplrBased_Threshold::has_low_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FecControllerRplrBased_Threshold::clear_low_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.low_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t FecControllerRplrBased_Threshold::low_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_bps)
  return _internal_low_bandwidth_bps();
}
inline void FecControllerRplrBased_Threshold::set_low_bandwidth_bps(::int32_t value) {
  _internal_set_low_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_bps)
}
inline ::int32_t FecControllerRplrBased_Threshold::_internal_low_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.low_bandwidth_bps_;
}
inline void FecControllerRplrBased_Threshold::_internal_set_low_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.low_bandwidth_bps_ = value;
}

// optional float low_bandwidth_recoverable_packet_loss = 2;
inline bool FecControllerRplrBased_Threshold::has_low_bandwidth_recoverable_packet_loss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FecControllerRplrBased_Threshold::clear_low_bandwidth_recoverable_packet_loss() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.low_bandwidth_recoverable_packet_loss_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float FecControllerRplrBased_Threshold::low_bandwidth_recoverable_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_recoverable_packet_loss)
  return _internal_low_bandwidth_recoverable_packet_loss();
}
inline void FecControllerRplrBased_Threshold::set_low_bandwidth_recoverable_packet_loss(float value) {
  _internal_set_low_bandwidth_recoverable_packet_loss(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.low_bandwidth_recoverable_packet_loss)
}
inline float FecControllerRplrBased_Threshold::_internal_low_bandwidth_recoverable_packet_loss() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.low_bandwidth_recoverable_packet_loss_;
}
inline void FecControllerRplrBased_Threshold::_internal_set_low_bandwidth_recoverable_packet_loss(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.low_bandwidth_recoverable_packet_loss_ = value;
}

// optional int32 high_bandwidth_bps = 3;
inline bool FecControllerRplrBased_Threshold::has_high_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FecControllerRplrBased_Threshold::clear_high_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.high_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t FecControllerRplrBased_Threshold::high_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_bps)
  return _internal_high_bandwidth_bps();
}
inline void FecControllerRplrBased_Threshold::set_high_bandwidth_bps(::int32_t value) {
  _internal_set_high_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_bps)
}
inline ::int32_t FecControllerRplrBased_Threshold::_internal_high_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.high_bandwidth_bps_;
}
inline void FecControllerRplrBased_Threshold::_internal_set_high_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.high_bandwidth_bps_ = value;
}

// optional float high_bandwidth_recoverable_packet_loss = 4;
inline bool FecControllerRplrBased_Threshold::has_high_bandwidth_recoverable_packet_loss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FecControllerRplrBased_Threshold::clear_high_bandwidth_recoverable_packet_loss() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.high_bandwidth_recoverable_packet_loss_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float FecControllerRplrBased_Threshold::high_bandwidth_recoverable_packet_loss() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_recoverable_packet_loss)
  return _internal_high_bandwidth_recoverable_packet_loss();
}
inline void FecControllerRplrBased_Threshold::set_high_bandwidth_recoverable_packet_loss(float value) {
  _internal_set_high_bandwidth_recoverable_packet_loss(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold.high_bandwidth_recoverable_packet_loss)
}
inline float FecControllerRplrBased_Threshold::_internal_high_bandwidth_recoverable_packet_loss() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.high_bandwidth_recoverable_packet_loss_;
}
inline void FecControllerRplrBased_Threshold::_internal_set_high_bandwidth_recoverable_packet_loss(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.high_bandwidth_recoverable_packet_loss_ = value;
}

// -------------------------------------------------------------------

// FecControllerRplrBased

// optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_enabling_threshold = 1;
inline bool FecControllerRplrBased::has_fec_enabling_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fec_enabling_threshold_ != nullptr);
  return value;
}
inline void FecControllerRplrBased::clear_fec_enabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.fec_enabling_threshold_ != nullptr) _impl_.fec_enabling_threshold_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& FecControllerRplrBased::_internal_fec_enabling_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* p = _impl_.fec_enabling_threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold&>(::webrtc::audio_network_adaptor::config::_FecControllerRplrBased_Threshold_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& FecControllerRplrBased::fec_enabling_threshold() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
  return _internal_fec_enabling_threshold();
}
inline void FecControllerRplrBased::unsafe_arena_set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_enabling_threshold_);
  }
  _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::release_fec_enabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* released = _impl_.fec_enabling_threshold_;
  _impl_.fec_enabling_threshold_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::unsafe_arena_release_fec_enabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* temp = _impl_.fec_enabling_threshold_;
  _impl_.fec_enabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::_internal_mutable_fec_enabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.fec_enabling_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold>(GetArena());
    _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(p);
  }
  return _impl_.fec_enabling_threshold_;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::mutable_fec_enabling_threshold() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* _msg = _internal_mutable_fec_enabling_threshold();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
  return _msg;
}
inline void FecControllerRplrBased::set_allocated_fec_enabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(_impl_.fec_enabling_threshold_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.fec_enabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_enabling_threshold)
}

// optional .webrtc.audio_network_adaptor.config.FecControllerRplrBased.Threshold fec_disabling_threshold = 2;
inline bool FecControllerRplrBased::has_fec_disabling_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fec_disabling_threshold_ != nullptr);
  return value;
}
inline void FecControllerRplrBased::clear_fec_disabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.fec_disabling_threshold_ != nullptr) _impl_.fec_disabling_threshold_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& FecControllerRplrBased::_internal_fec_disabling_threshold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* p = _impl_.fec_disabling_threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold&>(::webrtc::audio_network_adaptor::config::_FecControllerRplrBased_Threshold_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold& FecControllerRplrBased::fec_disabling_threshold() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
  return _internal_fec_disabling_threshold();
}
inline void FecControllerRplrBased::unsafe_arena_set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_disabling_threshold_);
  }
  _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::release_fec_disabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* released = _impl_.fec_disabling_threshold_;
  _impl_.fec_disabling_threshold_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::unsafe_arena_release_fec_disabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* temp = _impl_.fec_disabling_threshold_;
  _impl_.fec_disabling_threshold_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::_internal_mutable_fec_disabling_threshold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.fec_disabling_threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold>(GetArena());
    _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(p);
  }
  return _impl_.fec_disabling_threshold_;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* FecControllerRplrBased::mutable_fec_disabling_threshold() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* _msg = _internal_mutable_fec_disabling_threshold();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
  return _msg;
}
inline void FecControllerRplrBased::set_allocated_fec_disabling_threshold(::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(_impl_.fec_disabling_threshold_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.fec_disabling_threshold_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased_Threshold*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.FecControllerRplrBased.fec_disabling_threshold)
}

// -------------------------------------------------------------------

// FrameLengthController

// optional float fl_increasing_packet_loss_fraction = 1;
inline bool FrameLengthController::has_fl_increasing_packet_loss_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_increasing_packet_loss_fraction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_increasing_packet_loss_fraction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float FrameLengthController::fl_increasing_packet_loss_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increasing_packet_loss_fraction)
  return _internal_fl_increasing_packet_loss_fraction();
}
inline void FrameLengthController::set_fl_increasing_packet_loss_fraction(float value) {
  _internal_set_fl_increasing_packet_loss_fraction(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increasing_packet_loss_fraction)
}
inline float FrameLengthController::_internal_fl_increasing_packet_loss_fraction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_increasing_packet_loss_fraction_;
}
inline void FrameLengthController::_internal_set_fl_increasing_packet_loss_fraction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fl_increasing_packet_loss_fraction_ = value;
}

// optional float fl_decreasing_packet_loss_fraction = 2;
inline bool FrameLengthController::has_fl_decreasing_packet_loss_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_decreasing_packet_loss_fraction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_decreasing_packet_loss_fraction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float FrameLengthController::fl_decreasing_packet_loss_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decreasing_packet_loss_fraction)
  return _internal_fl_decreasing_packet_loss_fraction();
}
inline void FrameLengthController::set_fl_decreasing_packet_loss_fraction(float value) {
  _internal_set_fl_decreasing_packet_loss_fraction(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decreasing_packet_loss_fraction)
}
inline float FrameLengthController::_internal_fl_decreasing_packet_loss_fraction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_decreasing_packet_loss_fraction_;
}
inline void FrameLengthController::_internal_set_fl_decreasing_packet_loss_fraction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fl_decreasing_packet_loss_fraction_ = value;
}

// optional int32 fl_20ms_to_60ms_bandwidth_bps = 3;
inline bool FrameLengthController::has_fl_20ms_to_60ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_20ms_to_60ms_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_20ms_to_60ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t FrameLengthController::fl_20ms_to_60ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_60ms_bandwidth_bps)
  return _internal_fl_20ms_to_60ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_20ms_to_60ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_20ms_to_60ms_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_60ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_20ms_to_60ms_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_20ms_to_60ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_20ms_to_60ms_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.fl_20ms_to_60ms_bandwidth_bps_ = value;
}

// optional int32 fl_60ms_to_20ms_bandwidth_bps = 4;
inline bool FrameLengthController::has_fl_60ms_to_20ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_60ms_to_20ms_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_60ms_to_20ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t FrameLengthController::fl_60ms_to_20ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_20ms_bandwidth_bps)
  return _internal_fl_60ms_to_20ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_60ms_to_20ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_60ms_to_20ms_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_20ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_60ms_to_20ms_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_60ms_to_20ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_60ms_to_20ms_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.fl_60ms_to_20ms_bandwidth_bps_ = value;
}

// optional int32 fl_60ms_to_120ms_bandwidth_bps = 5;
inline bool FrameLengthController::has_fl_60ms_to_120ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_60ms_to_120ms_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_60ms_to_120ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t FrameLengthController::fl_60ms_to_120ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_120ms_bandwidth_bps)
  return _internal_fl_60ms_to_120ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_60ms_to_120ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_60ms_to_120ms_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_120ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_60ms_to_120ms_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_60ms_to_120ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_60ms_to_120ms_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.fl_60ms_to_120ms_bandwidth_bps_ = value;
}

// optional int32 fl_120ms_to_60ms_bandwidth_bps = 6;
inline bool FrameLengthController::has_fl_120ms_to_60ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_120ms_to_60ms_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_120ms_to_60ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t FrameLengthController::fl_120ms_to_60ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_120ms_to_60ms_bandwidth_bps)
  return _internal_fl_120ms_to_60ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_120ms_to_60ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_120ms_to_60ms_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_120ms_to_60ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_120ms_to_60ms_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_120ms_to_60ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_120ms_to_60ms_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.fl_120ms_to_60ms_bandwidth_bps_ = value;
}

// optional int32 fl_increase_overhead_offset = 7;
inline bool FrameLengthController::has_fl_increase_overhead_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_increase_overhead_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_increase_overhead_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t FrameLengthController::fl_increase_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increase_overhead_offset)
  return _internal_fl_increase_overhead_offset();
}
inline void FrameLengthController::set_fl_increase_overhead_offset(::int32_t value) {
  _internal_set_fl_increase_overhead_offset(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_increase_overhead_offset)
}
inline ::int32_t FrameLengthController::_internal_fl_increase_overhead_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_increase_overhead_offset_;
}
inline void FrameLengthController::_internal_set_fl_increase_overhead_offset(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.fl_increase_overhead_offset_ = value;
}

// optional int32 fl_decrease_overhead_offset = 8;
inline bool FrameLengthController::has_fl_decrease_overhead_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_decrease_overhead_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_decrease_overhead_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t FrameLengthController::fl_decrease_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decrease_overhead_offset)
  return _internal_fl_decrease_overhead_offset();
}
inline void FrameLengthController::set_fl_decrease_overhead_offset(::int32_t value) {
  _internal_set_fl_decrease_overhead_offset(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_decrease_overhead_offset)
}
inline ::int32_t FrameLengthController::_internal_fl_decrease_overhead_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_decrease_overhead_offset_;
}
inline void FrameLengthController::_internal_set_fl_decrease_overhead_offset(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.fl_decrease_overhead_offset_ = value;
}

// optional int32 fl_20ms_to_40ms_bandwidth_bps = 9;
inline bool FrameLengthController::has_fl_20ms_to_40ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_20ms_to_40ms_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_20ms_to_40ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t FrameLengthController::fl_20ms_to_40ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_40ms_bandwidth_bps)
  return _internal_fl_20ms_to_40ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_20ms_to_40ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_20ms_to_40ms_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_20ms_to_40ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_20ms_to_40ms_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_20ms_to_40ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_20ms_to_40ms_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.fl_20ms_to_40ms_bandwidth_bps_ = value;
}

// optional int32 fl_40ms_to_20ms_bandwidth_bps = 10;
inline bool FrameLengthController::has_fl_40ms_to_20ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_40ms_to_20ms_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_40ms_to_20ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t FrameLengthController::fl_40ms_to_20ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_20ms_bandwidth_bps)
  return _internal_fl_40ms_to_20ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_40ms_to_20ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_40ms_to_20ms_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_20ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_40ms_to_20ms_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_40ms_to_20ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_40ms_to_20ms_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.fl_40ms_to_20ms_bandwidth_bps_ = value;
}

// optional int32 fl_40ms_to_60ms_bandwidth_bps = 11;
inline bool FrameLengthController::has_fl_40ms_to_60ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_40ms_to_60ms_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_40ms_to_60ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t FrameLengthController::fl_40ms_to_60ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_60ms_bandwidth_bps)
  return _internal_fl_40ms_to_60ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_40ms_to_60ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_40ms_to_60ms_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_40ms_to_60ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_40ms_to_60ms_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_40ms_to_60ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_40ms_to_60ms_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.fl_40ms_to_60ms_bandwidth_bps_ = value;
}

// optional int32 fl_60ms_to_40ms_bandwidth_bps = 12;
inline bool FrameLengthController::has_fl_60ms_to_40ms_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void FrameLengthController::clear_fl_60ms_to_40ms_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_60ms_to_40ms_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t FrameLengthController::fl_60ms_to_40ms_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_40ms_bandwidth_bps)
  return _internal_fl_60ms_to_40ms_bandwidth_bps();
}
inline void FrameLengthController::set_fl_60ms_to_40ms_bandwidth_bps(::int32_t value) {
  _internal_set_fl_60ms_to_40ms_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthController.fl_60ms_to_40ms_bandwidth_bps)
}
inline ::int32_t FrameLengthController::_internal_fl_60ms_to_40ms_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_60ms_to_40ms_bandwidth_bps_;
}
inline void FrameLengthController::_internal_set_fl_60ms_to_40ms_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.fl_60ms_to_40ms_bandwidth_bps_ = value;
}

// -------------------------------------------------------------------

// FrameLengthControllerV2

// optional int32 min_payload_bitrate_bps = 1;
inline bool FrameLengthControllerV2::has_min_payload_bitrate_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FrameLengthControllerV2::clear_min_payload_bitrate_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_payload_bitrate_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t FrameLengthControllerV2::min_payload_bitrate_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthControllerV2.min_payload_bitrate_bps)
  return _internal_min_payload_bitrate_bps();
}
inline void FrameLengthControllerV2::set_min_payload_bitrate_bps(::int32_t value) {
  _internal_set_min_payload_bitrate_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthControllerV2.min_payload_bitrate_bps)
}
inline ::int32_t FrameLengthControllerV2::_internal_min_payload_bitrate_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_payload_bitrate_bps_;
}
inline void FrameLengthControllerV2::_internal_set_min_payload_bitrate_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.min_payload_bitrate_bps_ = value;
}

// optional bool use_slow_adaptation = 2;
inline bool FrameLengthControllerV2::has_use_slow_adaptation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FrameLengthControllerV2::clear_use_slow_adaptation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_slow_adaptation_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool FrameLengthControllerV2::use_slow_adaptation() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.FrameLengthControllerV2.use_slow_adaptation)
  return _internal_use_slow_adaptation();
}
inline void FrameLengthControllerV2::set_use_slow_adaptation(bool value) {
  _internal_set_use_slow_adaptation(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.FrameLengthControllerV2.use_slow_adaptation)
}
inline bool FrameLengthControllerV2::_internal_use_slow_adaptation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_slow_adaptation_;
}
inline void FrameLengthControllerV2::_internal_set_use_slow_adaptation(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.use_slow_adaptation_ = value;
}

// -------------------------------------------------------------------

// ChannelController

// optional int32 channel_1_to_2_bandwidth_bps = 1;
inline bool ChannelController::has_channel_1_to_2_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChannelController::clear_channel_1_to_2_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_1_to_2_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ChannelController::channel_1_to_2_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ChannelController.channel_1_to_2_bandwidth_bps)
  return _internal_channel_1_to_2_bandwidth_bps();
}
inline void ChannelController::set_channel_1_to_2_bandwidth_bps(::int32_t value) {
  _internal_set_channel_1_to_2_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ChannelController.channel_1_to_2_bandwidth_bps)
}
inline ::int32_t ChannelController::_internal_channel_1_to_2_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_1_to_2_bandwidth_bps_;
}
inline void ChannelController::_internal_set_channel_1_to_2_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.channel_1_to_2_bandwidth_bps_ = value;
}

// optional int32 channel_2_to_1_bandwidth_bps = 2;
inline bool ChannelController::has_channel_2_to_1_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChannelController::clear_channel_2_to_1_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_2_to_1_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ChannelController::channel_2_to_1_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ChannelController.channel_2_to_1_bandwidth_bps)
  return _internal_channel_2_to_1_bandwidth_bps();
}
inline void ChannelController::set_channel_2_to_1_bandwidth_bps(::int32_t value) {
  _internal_set_channel_2_to_1_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ChannelController.channel_2_to_1_bandwidth_bps)
}
inline ::int32_t ChannelController::_internal_channel_2_to_1_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_2_to_1_bandwidth_bps_;
}
inline void ChannelController::_internal_set_channel_2_to_1_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.channel_2_to_1_bandwidth_bps_ = value;
}

// -------------------------------------------------------------------

// DtxController

// optional int32 dtx_enabling_bandwidth_bps = 1;
inline bool DtxController::has_dtx_enabling_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DtxController::clear_dtx_enabling_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dtx_enabling_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t DtxController::dtx_enabling_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.DtxController.dtx_enabling_bandwidth_bps)
  return _internal_dtx_enabling_bandwidth_bps();
}
inline void DtxController::set_dtx_enabling_bandwidth_bps(::int32_t value) {
  _internal_set_dtx_enabling_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.DtxController.dtx_enabling_bandwidth_bps)
}
inline ::int32_t DtxController::_internal_dtx_enabling_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dtx_enabling_bandwidth_bps_;
}
inline void DtxController::_internal_set_dtx_enabling_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dtx_enabling_bandwidth_bps_ = value;
}

// optional int32 dtx_disabling_bandwidth_bps = 2;
inline bool DtxController::has_dtx_disabling_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DtxController::clear_dtx_disabling_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dtx_disabling_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t DtxController::dtx_disabling_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.DtxController.dtx_disabling_bandwidth_bps)
  return _internal_dtx_disabling_bandwidth_bps();
}
inline void DtxController::set_dtx_disabling_bandwidth_bps(::int32_t value) {
  _internal_set_dtx_disabling_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.DtxController.dtx_disabling_bandwidth_bps)
}
inline ::int32_t DtxController::_internal_dtx_disabling_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dtx_disabling_bandwidth_bps_;
}
inline void DtxController::_internal_set_dtx_disabling_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dtx_disabling_bandwidth_bps_ = value;
}

// -------------------------------------------------------------------

// BitrateController

// optional int32 fl_increase_overhead_offset = 1;
inline bool BitrateController::has_fl_increase_overhead_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BitrateController::clear_fl_increase_overhead_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_increase_overhead_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t BitrateController::fl_increase_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.BitrateController.fl_increase_overhead_offset)
  return _internal_fl_increase_overhead_offset();
}
inline void BitrateController::set_fl_increase_overhead_offset(::int32_t value) {
  _internal_set_fl_increase_overhead_offset(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.BitrateController.fl_increase_overhead_offset)
}
inline ::int32_t BitrateController::_internal_fl_increase_overhead_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_increase_overhead_offset_;
}
inline void BitrateController::_internal_set_fl_increase_overhead_offset(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fl_increase_overhead_offset_ = value;
}

// optional int32 fl_decrease_overhead_offset = 2;
inline bool BitrateController::has_fl_decrease_overhead_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BitrateController::clear_fl_decrease_overhead_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fl_decrease_overhead_offset_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BitrateController::fl_decrease_overhead_offset() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.BitrateController.fl_decrease_overhead_offset)
  return _internal_fl_decrease_overhead_offset();
}
inline void BitrateController::set_fl_decrease_overhead_offset(::int32_t value) {
  _internal_set_fl_decrease_overhead_offset(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.BitrateController.fl_decrease_overhead_offset)
}
inline ::int32_t BitrateController::_internal_fl_decrease_overhead_offset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fl_decrease_overhead_offset_;
}
inline void BitrateController::_internal_set_fl_decrease_overhead_offset(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.fl_decrease_overhead_offset_ = value;
}

// -------------------------------------------------------------------

// Controller_ScoringPoint

// optional int32 uplink_bandwidth_bps = 1;
inline bool Controller_ScoringPoint::has_uplink_bandwidth_bps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Controller_ScoringPoint::clear_uplink_bandwidth_bps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uplink_bandwidth_bps_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Controller_ScoringPoint::uplink_bandwidth_bps() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_bandwidth_bps)
  return _internal_uplink_bandwidth_bps();
}
inline void Controller_ScoringPoint::set_uplink_bandwidth_bps(::int32_t value) {
  _internal_set_uplink_bandwidth_bps(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_bandwidth_bps)
}
inline ::int32_t Controller_ScoringPoint::_internal_uplink_bandwidth_bps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uplink_bandwidth_bps_;
}
inline void Controller_ScoringPoint::_internal_set_uplink_bandwidth_bps(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uplink_bandwidth_bps_ = value;
}

// optional float uplink_packet_loss_fraction = 2;
inline bool Controller_ScoringPoint::has_uplink_packet_loss_fraction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Controller_ScoringPoint::clear_uplink_packet_loss_fraction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uplink_packet_loss_fraction_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Controller_ScoringPoint::uplink_packet_loss_fraction() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_packet_loss_fraction)
  return _internal_uplink_packet_loss_fraction();
}
inline void Controller_ScoringPoint::set_uplink_packet_loss_fraction(float value) {
  _internal_set_uplink_packet_loss_fraction(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.Controller.ScoringPoint.uplink_packet_loss_fraction)
}
inline float Controller_ScoringPoint::_internal_uplink_packet_loss_fraction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uplink_packet_loss_fraction_;
}
inline void Controller_ScoringPoint::_internal_set_uplink_packet_loss_fraction(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.uplink_packet_loss_fraction_ = value;
}

// -------------------------------------------------------------------

// Controller

// optional .webrtc.audio_network_adaptor.config.Controller.ScoringPoint scoring_point = 1;
inline bool Controller::has_scoring_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scoring_point_ != nullptr);
  return value;
}
inline void Controller::clear_scoring_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.scoring_point_ != nullptr) _impl_.scoring_point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint& Controller::_internal_scoring_point() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* p = _impl_.scoring_point_;
  return p != nullptr ? *p : reinterpret_cast<const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint&>(::webrtc::audio_network_adaptor::config::_Controller_ScoringPoint_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint& Controller::scoring_point() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.scoring_point)
  return _internal_scoring_point();
}
inline void Controller::unsafe_arena_set_allocated_scoring_point(::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scoring_point_);
  }
  _impl_.scoring_point_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.scoring_point)
}
inline ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* Controller::release_scoring_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* released = _impl_.scoring_point_;
  _impl_.scoring_point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* Controller::unsafe_arena_release_scoring_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.scoring_point)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* temp = _impl_.scoring_point_;
  _impl_.scoring_point_ = nullptr;
  return temp;
}
inline ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* Controller::_internal_mutable_scoring_point() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.scoring_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint>(GetArena());
    _impl_.scoring_point_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint*>(p);
  }
  return _impl_.scoring_point_;
}
inline ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* Controller::mutable_scoring_point() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* _msg = _internal_mutable_scoring_point();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.scoring_point)
  return _msg;
}
inline void Controller::set_allocated_scoring_point(::webrtc::audio_network_adaptor::config::Controller_ScoringPoint* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint*>(_impl_.scoring_point_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.scoring_point_ = reinterpret_cast<::webrtc::audio_network_adaptor::config::Controller_ScoringPoint*>(value);
  // @@protoc_insertion_point(field_set_allocated:webrtc.audio_network_adaptor.config.Controller.scoring_point)
}

// .webrtc.audio_network_adaptor.config.FecController fec_controller = 21;
inline bool Controller::has_fec_controller() const {
  return controller_case() == kFecController;
}
inline bool Controller::_internal_has_fec_controller() const {
  return controller_case() == kFecController;
}
inline void Controller::set_has_fec_controller() {
  _impl_._oneof_case_[0] = kFecController;
}
inline void Controller::clear_fec_controller() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (controller_case() == kFecController) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.fec_controller_;
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::FecController* Controller::release_fec_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.fec_controller)
  if (controller_case() == kFecController) {
    clear_has_controller();
    auto* temp = _impl_.controller_.fec_controller_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.fec_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::FecController& Controller::_internal_fec_controller() const {
  return controller_case() == kFecController ? *_impl_.controller_.fec_controller_ : reinterpret_cast<::webrtc::audio_network_adaptor::config::FecController&>(::webrtc::audio_network_adaptor::config::_FecController_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecController& Controller::fec_controller() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.fec_controller)
  return _internal_fec_controller();
}
inline ::webrtc::audio_network_adaptor::config::FecController* Controller::unsafe_arena_release_fec_controller() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.fec_controller)
  if (controller_case() == kFecController) {
    clear_has_controller();
    auto* temp = _impl_.controller_.fec_controller_;
    _impl_.controller_.fec_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_fec_controller(::webrtc::audio_network_adaptor::config::FecController* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_fec_controller();
    _impl_.controller_.fec_controller_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.fec_controller)
}
inline ::webrtc::audio_network_adaptor::config::FecController* Controller::_internal_mutable_fec_controller() {
  if (controller_case() != kFecController) {
    clear_controller();
    set_has_fec_controller();
    _impl_.controller_.fec_controller_ = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecController>(GetArena());
  }
  return _impl_.controller_.fec_controller_;
}
inline ::webrtc::audio_network_adaptor::config::FecController* Controller::mutable_fec_controller() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FecController* _msg = _internal_mutable_fec_controller();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.fec_controller)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.FrameLengthController frame_length_controller = 22;
inline bool Controller::has_frame_length_controller() const {
  return controller_case() == kFrameLengthController;
}
inline bool Controller::_internal_has_frame_length_controller() const {
  return controller_case() == kFrameLengthController;
}
inline void Controller::set_has_frame_length_controller() {
  _impl_._oneof_case_[0] = kFrameLengthController;
}
inline void Controller::clear_frame_length_controller() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (controller_case() == kFrameLengthController) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.frame_length_controller_;
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthController* Controller::release_frame_length_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
  if (controller_case() == kFrameLengthController) {
    clear_has_controller();
    auto* temp = _impl_.controller_.frame_length_controller_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.frame_length_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::FrameLengthController& Controller::_internal_frame_length_controller() const {
  return controller_case() == kFrameLengthController ? *_impl_.controller_.frame_length_controller_ : reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthController&>(::webrtc::audio_network_adaptor::config::_FrameLengthController_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FrameLengthController& Controller::frame_length_controller() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
  return _internal_frame_length_controller();
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthController* Controller::unsafe_arena_release_frame_length_controller() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
  if (controller_case() == kFrameLengthController) {
    clear_has_controller();
    auto* temp = _impl_.controller_.frame_length_controller_;
    _impl_.controller_.frame_length_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_frame_length_controller(::webrtc::audio_network_adaptor::config::FrameLengthController* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_frame_length_controller();
    _impl_.controller_.frame_length_controller_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthController* Controller::_internal_mutable_frame_length_controller() {
  if (controller_case() != kFrameLengthController) {
    clear_controller();
    set_has_frame_length_controller();
    _impl_.controller_.frame_length_controller_ = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FrameLengthController>(GetArena());
  }
  return _impl_.controller_.frame_length_controller_;
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthController* Controller::mutable_frame_length_controller() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FrameLengthController* _msg = _internal_mutable_frame_length_controller();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.frame_length_controller)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.ChannelController channel_controller = 23;
inline bool Controller::has_channel_controller() const {
  return controller_case() == kChannelController;
}
inline bool Controller::_internal_has_channel_controller() const {
  return controller_case() == kChannelController;
}
inline void Controller::set_has_channel_controller() {
  _impl_._oneof_case_[0] = kChannelController;
}
inline void Controller::clear_channel_controller() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (controller_case() == kChannelController) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.channel_controller_;
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::ChannelController* Controller::release_channel_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.channel_controller)
  if (controller_case() == kChannelController) {
    clear_has_controller();
    auto* temp = _impl_.controller_.channel_controller_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.channel_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::ChannelController& Controller::_internal_channel_controller() const {
  return controller_case() == kChannelController ? *_impl_.controller_.channel_controller_ : reinterpret_cast<::webrtc::audio_network_adaptor::config::ChannelController&>(::webrtc::audio_network_adaptor::config::_ChannelController_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::ChannelController& Controller::channel_controller() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.channel_controller)
  return _internal_channel_controller();
}
inline ::webrtc::audio_network_adaptor::config::ChannelController* Controller::unsafe_arena_release_channel_controller() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.channel_controller)
  if (controller_case() == kChannelController) {
    clear_has_controller();
    auto* temp = _impl_.controller_.channel_controller_;
    _impl_.controller_.channel_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_channel_controller(::webrtc::audio_network_adaptor::config::ChannelController* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_channel_controller();
    _impl_.controller_.channel_controller_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.channel_controller)
}
inline ::webrtc::audio_network_adaptor::config::ChannelController* Controller::_internal_mutable_channel_controller() {
  if (controller_case() != kChannelController) {
    clear_controller();
    set_has_channel_controller();
    _impl_.controller_.channel_controller_ = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::ChannelController>(GetArena());
  }
  return _impl_.controller_.channel_controller_;
}
inline ::webrtc::audio_network_adaptor::config::ChannelController* Controller::mutable_channel_controller() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::ChannelController* _msg = _internal_mutable_channel_controller();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.channel_controller)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.DtxController dtx_controller = 24;
inline bool Controller::has_dtx_controller() const {
  return controller_case() == kDtxController;
}
inline bool Controller::_internal_has_dtx_controller() const {
  return controller_case() == kDtxController;
}
inline void Controller::set_has_dtx_controller() {
  _impl_._oneof_case_[0] = kDtxController;
}
inline void Controller::clear_dtx_controller() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (controller_case() == kDtxController) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.dtx_controller_;
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::DtxController* Controller::release_dtx_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
  if (controller_case() == kDtxController) {
    clear_has_controller();
    auto* temp = _impl_.controller_.dtx_controller_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.dtx_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::DtxController& Controller::_internal_dtx_controller() const {
  return controller_case() == kDtxController ? *_impl_.controller_.dtx_controller_ : reinterpret_cast<::webrtc::audio_network_adaptor::config::DtxController&>(::webrtc::audio_network_adaptor::config::_DtxController_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::DtxController& Controller::dtx_controller() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
  return _internal_dtx_controller();
}
inline ::webrtc::audio_network_adaptor::config::DtxController* Controller::unsafe_arena_release_dtx_controller() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
  if (controller_case() == kDtxController) {
    clear_has_controller();
    auto* temp = _impl_.controller_.dtx_controller_;
    _impl_.controller_.dtx_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_dtx_controller(::webrtc::audio_network_adaptor::config::DtxController* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_dtx_controller();
    _impl_.controller_.dtx_controller_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
}
inline ::webrtc::audio_network_adaptor::config::DtxController* Controller::_internal_mutable_dtx_controller() {
  if (controller_case() != kDtxController) {
    clear_controller();
    set_has_dtx_controller();
    _impl_.controller_.dtx_controller_ = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::DtxController>(GetArena());
  }
  return _impl_.controller_.dtx_controller_;
}
inline ::webrtc::audio_network_adaptor::config::DtxController* Controller::mutable_dtx_controller() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::DtxController* _msg = _internal_mutable_dtx_controller();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.dtx_controller)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.BitrateController bitrate_controller = 25;
inline bool Controller::has_bitrate_controller() const {
  return controller_case() == kBitrateController;
}
inline bool Controller::_internal_has_bitrate_controller() const {
  return controller_case() == kBitrateController;
}
inline void Controller::set_has_bitrate_controller() {
  _impl_._oneof_case_[0] = kBitrateController;
}
inline void Controller::clear_bitrate_controller() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (controller_case() == kBitrateController) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.bitrate_controller_;
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::BitrateController* Controller::release_bitrate_controller() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
  if (controller_case() == kBitrateController) {
    clear_has_controller();
    auto* temp = _impl_.controller_.bitrate_controller_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.bitrate_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::BitrateController& Controller::_internal_bitrate_controller() const {
  return controller_case() == kBitrateController ? *_impl_.controller_.bitrate_controller_ : reinterpret_cast<::webrtc::audio_network_adaptor::config::BitrateController&>(::webrtc::audio_network_adaptor::config::_BitrateController_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::BitrateController& Controller::bitrate_controller() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
  return _internal_bitrate_controller();
}
inline ::webrtc::audio_network_adaptor::config::BitrateController* Controller::unsafe_arena_release_bitrate_controller() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
  if (controller_case() == kBitrateController) {
    clear_has_controller();
    auto* temp = _impl_.controller_.bitrate_controller_;
    _impl_.controller_.bitrate_controller_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_bitrate_controller(::webrtc::audio_network_adaptor::config::BitrateController* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_bitrate_controller();
    _impl_.controller_.bitrate_controller_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
}
inline ::webrtc::audio_network_adaptor::config::BitrateController* Controller::_internal_mutable_bitrate_controller() {
  if (controller_case() != kBitrateController) {
    clear_controller();
    set_has_bitrate_controller();
    _impl_.controller_.bitrate_controller_ = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::BitrateController>(GetArena());
  }
  return _impl_.controller_.bitrate_controller_;
}
inline ::webrtc::audio_network_adaptor::config::BitrateController* Controller::mutable_bitrate_controller() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::BitrateController* _msg = _internal_mutable_bitrate_controller();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.bitrate_controller)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.FecControllerRplrBased fec_controller_rplr_based = 26;
inline bool Controller::has_fec_controller_rplr_based() const {
  return controller_case() == kFecControllerRplrBased;
}
inline bool Controller::_internal_has_fec_controller_rplr_based() const {
  return controller_case() == kFecControllerRplrBased;
}
inline void Controller::set_has_fec_controller_rplr_based() {
  _impl_._oneof_case_[0] = kFecControllerRplrBased;
}
inline void Controller::clear_fec_controller_rplr_based() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (controller_case() == kFecControllerRplrBased) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.fec_controller_rplr_based_;
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* Controller::release_fec_controller_rplr_based() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
  if (controller_case() == kFecControllerRplrBased) {
    clear_has_controller();
    auto* temp = _impl_.controller_.fec_controller_rplr_based_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.fec_controller_rplr_based_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased& Controller::_internal_fec_controller_rplr_based() const {
  return controller_case() == kFecControllerRplrBased ? *_impl_.controller_.fec_controller_rplr_based_ : reinterpret_cast<::webrtc::audio_network_adaptor::config::FecControllerRplrBased&>(::webrtc::audio_network_adaptor::config::_FecControllerRplrBased_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FecControllerRplrBased& Controller::fec_controller_rplr_based() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
  return _internal_fec_controller_rplr_based();
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* Controller::unsafe_arena_release_fec_controller_rplr_based() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
  if (controller_case() == kFecControllerRplrBased) {
    clear_has_controller();
    auto* temp = _impl_.controller_.fec_controller_rplr_based_;
    _impl_.controller_.fec_controller_rplr_based_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_fec_controller_rplr_based(::webrtc::audio_network_adaptor::config::FecControllerRplrBased* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_fec_controller_rplr_based();
    _impl_.controller_.fec_controller_rplr_based_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* Controller::_internal_mutable_fec_controller_rplr_based() {
  if (controller_case() != kFecControllerRplrBased) {
    clear_controller();
    set_has_fec_controller_rplr_based();
    _impl_.controller_.fec_controller_rplr_based_ = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FecControllerRplrBased>(GetArena());
  }
  return _impl_.controller_.fec_controller_rplr_based_;
}
inline ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* Controller::mutable_fec_controller_rplr_based() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FecControllerRplrBased* _msg = _internal_mutable_fec_controller_rplr_based();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.fec_controller_rplr_based)
  return _msg;
}

// .webrtc.audio_network_adaptor.config.FrameLengthControllerV2 frame_length_controller_v2 = 27;
inline bool Controller::has_frame_length_controller_v2() const {
  return controller_case() == kFrameLengthControllerV2;
}
inline bool Controller::_internal_has_frame_length_controller_v2() const {
  return controller_case() == kFrameLengthControllerV2;
}
inline void Controller::set_has_frame_length_controller_v2() {
  _impl_._oneof_case_[0] = kFrameLengthControllerV2;
}
inline void Controller::clear_frame_length_controller_v2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (controller_case() == kFrameLengthControllerV2) {
    if (GetArena() == nullptr) {
      delete _impl_.controller_.frame_length_controller_v2_;
    }
    clear_has_controller();
  }
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* Controller::release_frame_length_controller_v2() {
  // @@protoc_insertion_point(field_release:webrtc.audio_network_adaptor.config.Controller.frame_length_controller_v2)
  if (controller_case() == kFrameLengthControllerV2) {
    clear_has_controller();
    auto* temp = _impl_.controller_.frame_length_controller_v2_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.controller_.frame_length_controller_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2& Controller::_internal_frame_length_controller_v2() const {
  return controller_case() == kFrameLengthControllerV2 ? *_impl_.controller_.frame_length_controller_v2_ : reinterpret_cast<::webrtc::audio_network_adaptor::config::FrameLengthControllerV2&>(::webrtc::audio_network_adaptor::config::_FrameLengthControllerV2_default_instance_);
}
inline const ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2& Controller::frame_length_controller_v2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.Controller.frame_length_controller_v2)
  return _internal_frame_length_controller_v2();
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* Controller::unsafe_arena_release_frame_length_controller_v2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:webrtc.audio_network_adaptor.config.Controller.frame_length_controller_v2)
  if (controller_case() == kFrameLengthControllerV2) {
    clear_has_controller();
    auto* temp = _impl_.controller_.frame_length_controller_v2_;
    _impl_.controller_.frame_length_controller_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Controller::unsafe_arena_set_allocated_frame_length_controller_v2(::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_controller();
  if (value) {
    set_has_frame_length_controller_v2();
    _impl_.controller_.frame_length_controller_v2_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:webrtc.audio_network_adaptor.config.Controller.frame_length_controller_v2)
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* Controller::_internal_mutable_frame_length_controller_v2() {
  if (controller_case() != kFrameLengthControllerV2) {
    clear_controller();
    set_has_frame_length_controller_v2();
    _impl_.controller_.frame_length_controller_v2_ = CreateMaybeMessage<::webrtc::audio_network_adaptor::config::FrameLengthControllerV2>(GetArena());
  }
  return _impl_.controller_.frame_length_controller_v2_;
}
inline ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* Controller::mutable_frame_length_controller_v2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::webrtc::audio_network_adaptor::config::FrameLengthControllerV2* _msg = _internal_mutable_frame_length_controller_v2();
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.Controller.frame_length_controller_v2)
  return _msg;
}

inline bool Controller::has_controller() const {
  return controller_case() != CONTROLLER_NOT_SET;
}
inline void Controller::clear_has_controller() {
  _impl_._oneof_case_[0] = CONTROLLER_NOT_SET;
}
inline Controller::ControllerCase Controller::controller_case() const {
  return Controller::ControllerCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ControllerManager

// repeated .webrtc.audio_network_adaptor.config.Controller controllers = 1;
inline int ControllerManager::_internal_controllers_size() const {
  return _internal_controllers().size();
}
inline int ControllerManager::controllers_size() const {
  return _internal_controllers_size();
}
inline void ControllerManager::clear_controllers() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.controllers_.Clear();
}
inline ::webrtc::audio_network_adaptor::config::Controller* ControllerManager::mutable_controllers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return _internal_mutable_controllers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>* ControllerManager::mutable_controllers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_controllers();
}
inline const ::webrtc::audio_network_adaptor::config::Controller& ControllerManager::controllers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return _internal_controllers().Get(index);
}
inline ::webrtc::audio_network_adaptor::config::Controller* ControllerManager::add_controllers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::webrtc::audio_network_adaptor::config::Controller* _add = _internal_mutable_controllers()->Add();
  // @@protoc_insertion_point(field_add:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>& ControllerManager::controllers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:webrtc.audio_network_adaptor.config.ControllerManager.controllers)
  return _internal_controllers();
}
inline const ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>&
ControllerManager::_internal_controllers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.controllers_;
}
inline ::google::protobuf::RepeatedPtrField<::webrtc::audio_network_adaptor::config::Controller>*
ControllerManager::_internal_mutable_controllers() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.controllers_;
}

// optional int32 min_reordering_time_ms = 2;
inline bool ControllerManager::has_min_reordering_time_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ControllerManager::clear_min_reordering_time_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_reordering_time_ms_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ControllerManager::min_reordering_time_ms() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_time_ms)
  return _internal_min_reordering_time_ms();
}
inline void ControllerManager::set_min_reordering_time_ms(::int32_t value) {
  _internal_set_min_reordering_time_ms(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_time_ms)
}
inline ::int32_t ControllerManager::_internal_min_reordering_time_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_reordering_time_ms_;
}
inline void ControllerManager::_internal_set_min_reordering_time_ms(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.min_reordering_time_ms_ = value;
}

// optional float min_reordering_squared_distance = 3;
inline bool ControllerManager::has_min_reordering_squared_distance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ControllerManager::clear_min_reordering_squared_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_reordering_squared_distance_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float ControllerManager::min_reordering_squared_distance() const {
  // @@protoc_insertion_point(field_get:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_squared_distance)
  return _internal_min_reordering_squared_distance();
}
inline void ControllerManager::set_min_reordering_squared_distance(float value) {
  _internal_set_min_reordering_squared_distance(value);
  // @@protoc_insertion_point(field_set:webrtc.audio_network_adaptor.config.ControllerManager.min_reordering_squared_distance)
}
inline float ControllerManager::_internal_min_reordering_squared_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_reordering_squared_distance_;
}
inline void ControllerManager::_internal_set_min_reordering_squared_distance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.min_reordering_squared_distance_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace config
}  // namespace audio_network_adaptor
}  // namespace webrtc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_config_2eproto_2epb_2eh
